[
    {
        "id": 1,
        "Question": "Assume the R is a relation on a set A, aRb is partially ordered such that a and b are _____________",
        "Options": [
            "a) reflexive",
            "b) transitive",
            "c) symmetric",
            "d) reflexive and transitive"
        ],
        "Answer": "Answer: d\nExplanation: A partially ordered relation refers to one which is Reflexive, Transitive and Antisymmetric."
    },
    {
        "id": 2,
        "Question": "The non- Kleene Star operation accepts the following string of finite length over set A = {0,1} | where string s contains even number of 0 and 1",
        "Options": [
            "a) 01,0011,010101",
            "b) 0011,11001100",
            "c) ε,0011,11001100",
            "d) ε,0011,11001100"
        ],
        "Answer": "Answer: b\nExplanation: The Kleene star of A, denoted by A*, is the set of all strings obtained by concatenating zero or more strings from A."
    },
    {
        "id": 3,
        "Question": "A regular language over an alphabet ∑ is one that cannot be obtained from the basic languages using the operation",
        "Options": [
            "a) Union",
            "b) Concatenation",
            "c) Kleene*",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Union, Intersection, Concatenation, Kleene*, Reverse are all the closure properties of Regular Language."
    },
    {
        "id": 4,
        "Question": "The minimum number of states required to recognize an octal number divisible by 3 are/is",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 5",
            "d) 7"
        ],
        "Answer": "Answer: d\nExplanation: It is possible to represent a finite automaton graphically, with nodes for states, and arcs for transitions."
    },
    {
        "id": 5,
        "Question": "Which of the following is not a part of 5-tuple finite automata?",
        "Options": [
            "a) Input alphabet",
            "b) Transition function",
            "c) Initial State",
            "d) Output Alphabet"
        ],
        "Answer": "Answer: b\nExplanation: According to the question, minimum of 3 states are required to recognize an octal number divisible by 3."
    },
    {
        "id": 6,
        "Question": "If an Infinite language is passed to Machine M, the subsidiary which gives a finite solution to the infinite input tape is ______________",
        "Options": [
            "a) Compiler",
            "b) Interpreter",
            "c) Loader and Linkers",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: A FA can be represented as FA = (Q, ∑, δ, q0, F) where Q=Finite Set of States, ∑=Finite Input Alphabet, δ=Transition Function, q0=Initial State, F=Final/Acceptance State)."
    },
    {
        "id": 7,
        "Question": "The number of elements in the set for the Language L={xϵ(∑r) *|length if x is at most 2} and ∑={0,1} is _________",
        "Options": [
            "a) 7",
            "b) 6",
            "c) 8",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: A Compiler is used to give a finite solution to an infinite phenomenon. An example of an infinite phenomenon is Language C, etc."
    },
    {
        "id": 8,
        "Options": [
            "9. For the following change of state in FA, which of the following codes is an incorrect option?",
            "a) δ (m, 1) = n",
            "b) δ (0, n) = m",
            "c) δ (m,0) = ε",
            "d)"
        ],
        "Answer": "Answer: a\nExplanation: ∑r = {1,0} and a Kleene* operation would lead to the following set=COUNT{ε,0,1,00,11,01,10} = 7."
    },
    {
        "id": 9,
        "Question": "Moore Machine is an application of:",
        "Options": [
            "a) Finite automata without input",
            "b) Finite automata with output",
            "c) Non Finite automata with output",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Finite automaton with output is categorized din two parts: Moore M/C and Mealy M/C."
    },
    {
        "id": 10,
        "Question": "In Moore machine, output is produced over the change of:",
        "Options": [
            "a) transitions",
            "b) states",
            "c) all of the mentioned",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Moore machine produces an output over the change of transition states while mealy machine does it so for transitions itself."
    },
    {
        "id": 11,
        "Question": "For a give Moore Machine, Given Input=’101010’, thus the output would be of length:",
        "Options": [
            "a) |Input|+1",
            "b) |Input|",
            "c) |Input-1|",
            "d) Cannot be predicted"
        ],
        "Answer": "Answer: a\nExplanation: Initial state, from which the operations begin is also initialized with a value."
    },
    {
        "id": 12,
        "Question": "The total number of states and transitions required to form a moore machine that will produce residue mod 3.",
        "Options": [
            "a) 3 and 6",
            "b) 3 and 5",
            "c) 2 and 4",
            "d) 2 and 5"
        ],
        "Answer": "Answer: a\nExplanation: Even ε, when passed as an input to Moore machine produces an output."
    },
    {
        "id": 13,
        "Options": [
            "a) Q0, Q2, 0",
            "b) Q0, Q2, 1",
            "c) Q1, Q2, 1",
            "d) Q1, Q0, 0"
        ],
        "Answer": "Answer: a\nExplanation:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-moore-machine-q5.png\" alt=\"Find the total number of states to form a moore machine from the given diagram\" width=\"497\" height=\"168\" class=\"alignnone size-full wp-image-160170\" />\n"
    },
    {
        "id": 14,
        "Question": "The output alphabet can be represented as:",
        "Options": [
            "a) δ",
            "b) ∆",
            "c) ∑",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The table can be filled accordingly seeing the graph."
    },
    {
        "id": 15,
        "Question": "The O/P of Moore machine can be represented in the following format:",
        "Options": [
            "a) Op(t)=δ(Op(t))",
            "b) Op(t)=δ(Op(t)i(t))",
            "c) Op(t): ∑",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The outputs are as per the input, produced."
    },
    {
        "id": 16,
        "Question": "Which of the following is a correct statement?",
        "Options": [
            "a) Moore machine has no accepting states",
            "b) Mealy machine has accepting states",
            "c) We can convert Mealy to Moore but not vice versa",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Source-The tuple definition of Moore and mealy machine comprises one new member i.e. output alphabet as these are finite machines with output."
    },
    {
        "id": 17,
        "Question": "In mealy machine, the O/P depends upon?",
        "Options": [
            "a) State",
            "b) Previous State",
            "c) State and Input",
            "d) Only Input"
        ],
        "Answer": "Answer: c\nExplanation: Definition of Mealy Machine."
    },
    {
        "id": 18,
        "Question": "Which of the given are correct?",
        "Options": [
            "a) Moore machine has 6-tuples",
            "b) Mealy machine has 6-tuples",
            "c) Both Mealy and Moore has 6-tuples",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Finite Automaton with Output has a common definition for both the categories."
    },
    {
        "id": 19,
        "Question": "The O/P of Mealy machine can be represented in the following format:",
        "Options": [
            "a) Op(t)= δ(Op(t))",
            "b) Op(t)= δ(Op(t)i(t))",
            "c) Op(t): ∑",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The input can be taken in form of a binary string and can be verified."
    },
    {
        "id": 20,
        "Question": "5.The ratio of number of input to the number of output in a mealy machine can be given as:",
        "Options": [
            "a) 1",
            "b) n: n+1",
            "c) n+1: n",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The output of mealy machine depends on the present state as well as the input to that state."
    },
    {
        "id": 21,
        "Question": "Mealy and Moore machine can be categorized as:",
        "Options": [
            "a) Inducers",
            "b) Transducers",
            "c) Turing Machines",
            "d) Linearly Bounder Automata"
        ],
        "Answer": "Answer: a\nExplanation: The number of output here follows the transitions in place of states as in Moore machine."
    },
    {
        "id": 22,
        "Question": "The major difference between Mealy and Moore machine is about:",
        "Options": [
            "a) Output Variations",
            "b) Input Variations",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: They are collectively known as Transducers."
    },
    {
        "id": 23,
        "Question": "Which of the following does not belong to input alphabet if S={a, b}* for any language?",
        "Options": [
            "a) a",
            "b) b",
            "c) e",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The automaton may be allowed to change its state without reading the input symbol using epsilon but this does not mean that epsilon has become an input symbol. On the contrary, one assumes that the symbol epsilon does not belong to any alphabet."
    },
    {
        "id": 24,
        "Question": "An e-NFA is ___________ in representation.",
        "Options": [
            "a) Quadruple",
            "b) Quintuple",
            "c) Triple",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-mealy-machine-1-q2.png\" alt=\"Find the number of final states from the given diagram\" width=\"258\" height=\"300\" class=\"alignnone size-full wp-image-160179\" />\n"
    },
    {
        "id": 25,
        "Options": [
            "4. State true or false:",
            "Statement: Both NFA and e-NFA recognize exactly the same languages.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: An e-NFA consist of 5 tuples: A=(Q, S, d, q0. F)\nNote: e is never a member of S."
    },
    {
        "id": 26,
        "Question": "Which of the following not an example Bounded Information?",
        "Options": [
            "a) fan switch outputs {on, off}",
            "b) electricity meter reading",
            "c) colour of the traffic light at the moment",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Bounded information refers to one whose output is limited and it cannot be said what were the recorded outputs previously until memorized."
    },
    {
        "id": 27,
        "Question": "A Language for which no DFA exist is a________",
        "Options": [
            "a) Regular Language",
            "b) Non-Regular Language",
            "c) May be Regular",
            "d) Cannot be said"
        ],
        "Answer": "Answer: b\nExplanation: A language for which there is no existence of a deterministic finite automata is always Non Regular and methods like Pumping Lemma can be used to prove the same."
    },
    {
        "id": 28,
        "Question": "A DFA cannot be represented in the following format",
        "Options": [
            "a) Transition graph",
            "b) Transition Table",
            "c) C code",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: A DFA can be represented in the following formats: Transition Graph, Transition Table, Transition tree/forest/Any programming Language."
    },
    {
        "id": 29,
        "Question": "When are 2 finite states equivalent?",
        "Options": [
            "a) Same number of transitions",
            "b) Same number of states",
            "c) Same number of states as well as transitions",
            "d) Both are final states"
        ],
        "Answer": "Answer: a\nExplanation: Strings such as {1101,101,10101} are being accepted while {1001,11001} are not. Thus, this conclusion leads to option a."
    },
    {
        "id": 30,
        "Question": "Can a DFA recognize a palindrome number?",
        "Options": [
            "a) Yes",
            "b) No",
            "c) Yes, with input alphabet as ∑*",
            "d) Can’t be determined"
        ],
        "Answer": "Answer: c\nExplanation: Two states are said to be equivalent if and only if they have same number of states as well as transitions."
    },
    {
        "id": 31,
        "Question": "Which of the following is not an example of finite state machine system?",
        "Options": [
            "a) Control Mechanism of an elevator",
            "b) Combinational Locks",
            "c) Traffic Lights",
            "d) Digital Watches"
        ],
        "Answer": "Answer: c\nExplanation: The figure represents the initial as well as the final state with an iteration of x."
    },
    {
        "id": 32,
        "Question": "The password to the admins account=”administrator”. The total number of states required to make a password-pass system using DFA would be __________",
        "Options": [
            "a) 14 states",
            "b) 13 states",
            "c) 12 states",
            "d) A password pass system cannot be created using DFA"
        ],
        "Answer": "Answer: a\nExplanation: For a string of n characters with no repetitive substrings, the number of states required to pass the string is n+1."
    },
    {
        "id": 33,
        "Question": "Let ∑= {a, b, …. z} and A = {Hello, World}, B= {Input, Output}, then (A*∩B) U (B*∩A) can be represented as:",
        "Options": [
            "a) {Hello, World, Input, Output, ε}",
            "b) {Hello, World, ε}",
            "c) {Input, Output, ε}",
            "d) {}"
        ],
        "Answer": "Answer: b\nExplanation: The Language can be anonymously checked and thus the answer can be predicted. The language needs to be accepted by the automata (acceptance state) in order to prove its regularity."
    },
    {
        "id": 34,
        "Question": "For a machine to surpass all the letters of alphabet excluding vowels, how many number of states in DFA would be required?",
        "Options": [
            "a) 3",
            "b) 2",
            "c) 22",
            "d) 27"
        ],
        "Answer": "Answer: d\nExplanation: Union operation creates the universal set by combining all the elements of first and second set while intersection operation creates a set of common elements of the first and the second state."
    },
    {
        "id": 35,
        "Options": [
            "8. Given:",
            "L= {xϵ∑= {0,1} |x=0n1n for n>=1}; Can there be a DFA possible for the language?",
            "a) Yes",
            "b) No"
        ],
        "Answer": "Answer: b\nExplanation: Use the equivalence theorem or Myphill Nerode theorem to minimize the DFA."
    },
    {
        "id": 36,
        "Question": "2.Let u=’1101’, v=’0001’, then uv=11010001 and vu= 00011101.Using the given information what is the identity element for the string?",
        "Options": [
            "a) u-1",
            "b) v-1",
            "c) u-1v-1",
            "d) ε"
        ],
        "Answer": "Answer: a\nExplanation: The states transited has been written corresponding to the transitions as per the row and column. The row represents the transitions made and the ultimate."
    },
    {
        "id": 37,
        "Question": "<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/06/automata-theory-questions-answers-simpler-notations-q3.png\" alt=\"Find the DFA notation accepts of string from the given diagram\" width=\"371\" height=\"120\" class=\"aligncenter size-full wp-image-145260\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/06/automata-theory-questions-answers-simpler-notations-q3.png 371w, https://www.sanfoundry.com/wp-content/uploads/2017/06/automata-theory-questions-answers-simpler-notations-q3-300x97.png 300w\" sizes=\"(max-width: 371px) 100vw, 371px\" />",
        "Options": [
            "a) 0101011",
            "b) 0101010",
            "c) 010100",
            "d) 100001"
        ],
        "Answer": "Answer: d\nExplanation:  Identity relation: εw = wε = w, thus the one satisfying the given relation will be the identity element."
    },
    {
        "id": 38,
        "Question": "7.The complement of a language will only be defined when and only when the __________ over the language is defined.",
        "Options": [
            "a) String",
            "b) Word",
            "c) Alphabet",
            "d) Grammar"
        ],
        "Answer": "Answer: c\nExplanation: The given DFA notation accepts the string of even length and prefix ‘01’."
    },
    {
        "id": 39,
        "Question": "8.Which among the following is not notated as infinite language?",
        "Options": [
            "a) Palindrome",
            "b) Reverse",
            "c) Factorial",
            "d) L={ab}*"
        ],
        "Answer": "Answer: b\nExplanation: Here, δ refers to transition function and results into new state or function when an transition is performed over its state."
    },
    {
        "id": 40,
        "Question": "How many languages are over the alphabet R?",
        "Options": [
            "a) countably infinite",
            "b) countably finite",
            "c) uncountable finite",
            "d) uncountable infinite"
        ],
        "Answer": "Answer: d\nExplanation: A language over an alphabet R is a set of strings over A which is uncountable and infinite."
    },
    {
        "id": 41,
        "Question": "δˆ tells us the best:",
        "Options": [
            "a) how the DFA S behaves on a word u",
            "b) the state is the dumping state",
            "c) the final state has been reached",
            "d) Kleene operation is performed on the set"
        ],
        "Answer": "Answer: b\nExplanation: Q is the Finite set of states, whose elements i.e. the states constitute the finite automata."
    },
    {
        "id": 42,
        "Question": "For a DFA accepting binary numbers whose decimal equivalent is divisible by 4, what are all the possible remainders?",
        "Options": [
            "a) 0",
            "b) 0,2",
            "c) 0,2,4",
            "d) 0,1,2,3"
        ],
        "Answer": "Answer: a\nExplanation: δ or the Transition function describes the best, how a DFA behaves on a string where to transit next, which direction to take."
    },
    {
        "id": 43,
        "Question": "The sum of minimum and maximum number of final states for a DFA n states is equal to:",
        "Options": [
            "a) n+1",
            "b) n",
            "c) n-1",
            "d) n+2"
        ],
        "Answer": "Answer: b\nExplanation: As the question has dot operation, ε will not be a part of the concatenated set. Had it been a union operation, ε would be a part of the operated set."
    },
    {
        "id": 44,
        "Question": "There are ________ tuples in finite state machine.",
        "Options": [
            "a) 4",
            "b) 5",
            "c) 6",
            "d) unlimited"
        ],
        "Answer": " Answer:b\nExplanation: States, input symbols, initial state, accepting state and transition function.\n"
    },
    {
        "id": 45,
        "Question": "Transition function maps.",
        "Options": [
            "a) Σ * Q -> Σ",
            "b) Q * Q -> Σ",
            "c) Σ * Σ -> Q",
            "d) Q * Σ -> Q"
        ],
        "Answer": " Answer:d\nExplanation: Inputs are state and input string output is states.\n"
    },
    {
        "id": 46,
        "Question": "Number of states require to accept string ends with 10.",
        "Options": [
            "a) 3",
            "b) 2",
            "c) 1",
            "d) can’t be represented."
        ],
        "Answer": " Answer:a\nExplanation: This is minimal finite automata.\n"
    },
    {
        "id": 47,
        "Question": "Extended transition function is .",
        "Options": [
            "a) Q * Σ* -> Q",
            "b) Q * Σ -> Q",
            "c) Q* * Σ* -> Σ",
            "d) Q * Σ -> Σ"
        ],
        "Answer": " Answer:a\nExplanation: This takes single state and string of input to produce a state.\n"
    },
    {
        "id": 48,
        "Question": "δ*(q,ya) is equivalent to .",
        "Options": [
            "a) δ((q,y),a)",
            "b) δ(δ*(q,y),a)",
            "c) δ(q,ya)",
            "d) independent from δ notation"
        ],
        "Answer": " Answer:b\nExplanation: First it parse y string after that it parse a.\n"
    },
    {
        "id": 49,
        "Question": "String X is accepted by finite automata if .",
        "Options": [
            "a) δ*(q,x) E A",
            "b) δ(q,x) E A",
            "c) δ*(Q0,x) E A",
            "d) δ(Q0,x) E A"
        ],
        "Answer": " Answer:c\nExplanation: If automata starts with starting state and after finite moves if reaches to final step then it called accepted.\n"
    },
    {
        "id": 50,
        "Question": "Languages of a automata is",
        "Options": [
            "a) If it is accepted by automata",
            "b) If it halts",
            "c) If automata touch final state in its life time",
            "d) All language are language of automata"
        ],
        "Answer": " Answer:a\nExplanation: If a string accepted by automata it is called language of automata.\n"
    },
    {
        "id": 51,
        "Question": "Language of finite automata is.",
        "Options": [
            "a) Type 0",
            "b) Type 1",
            "c) Type 2",
            "d) Type 3"
        ],
        "Answer": " Answer:d\nExplanation: According to Chomsky classification.\n"
    },
    {
        "id": 52,
        "Question": "Finite automata requires minimum _______ number of stacks.",
        "Options": [
            "a) 1",
            "b) 0",
            "c) 2",
            "d) None of the mentioned"
        ],
        "Answer": " Answer:b\nExplanation: Finite automata doesn’t require any stack operation.\n"
    },
    {
        "id": 53,
        "Question": "Number of final state require to accept Φ in minimal finite automata.",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) None of the mentioned"
        ],
        "Answer": " Answer:d\nExplanation: No final state requires.\n"
    },
    {
        "id": 54,
        "Question": "Regular expression for all strings starts with ab and ends with bba is.",
        "Options": [
            "a) aba*b*bba",
            "b) ab(ab)*bba",
            "c) ab(a+b)*bba",
            "d) All of the mentioned"
        ],
        "Answer": " Answer:c\nExplanation: Starts with ab then any number of a or b and ends with bba.\n"
    },
    {
        "id": 55,
        "Question": "How many DFA’s exits with two states over input alphabet {0,1} ?",
        "Options": [
            "a) 16",
            "b) 26",
            "c) 32",
            "d) 64"
        ],
        "Answer": " Answer:d\nExplanation: Number of DFA’s = 2n * n(2*n).\n"
    },
    {
        "id": 56,
        "Question": "The basic limitation of finite automata is that",
        "Options": [
            "a) It can’t remember arbitrary large amount of information.",
            "b) It sometimes recognize grammar that are not regular.",
            "c) It sometimes fails to recognize regular grammar.",
            "d) All of the mentioned"
        ],
        "Answer": " Answer:a\nExplanation:Because there is no memory associated with automata.\n"
    },
    {
        "id": 57,
        "Question": "Number of states require to simulate a computer with memory capable of storing ‘3’ words each of length ‘8’.",
        "Options": [
            "a) 3 * 28",
            "b) 2(3*8)",
            "c) 2(3+8)",
            "d) None of the mentioned"
        ],
        "Answer": " Answer:b\nExplanation: 2(m*n) states requires.\n"
    },
    {
        "id": 58,
        "Question": "FSM with output capability can be used to add two given integer in binary representation. This is",
        "Options": [
            "a) True",
            "b) False",
            "c) May be true",
            "d) None of the mentioned"
        ],
        "Answer": " Answer:a\nExplanation: Use them as a flip flop output.\n"
    },
    {
        "id": 59,
        "Question": "An automaton that presents output based on previous state or current input:",
        "Options": [
            "a) Acceptor",
            "b) Classifier",
            "c) Transducer",
            "d) None of the mentioned."
        ],
        "Answer": "Answer: a\nExplanation: Statement 1 and 2 always true for a given Language."
    },
    {
        "id": 60,
        "Question": "If NFA of 6 states excluding the initial state is converted into DFA, maximum possible number of states for the DFA is ?",
        "Options": [
            "a) 64",
            "b) 32",
            "c) 128",
            "d) 127"
        ],
        "Answer": "Answer: a\nExplanation: Construct the DFA and NFA individually, and the attain the difference of states."
    },
    {
        "id": 61,
        "Question": "NFA, in its name has ’non-deterministic’ because of :",
        "Options": [
            "a) The result is undetermined",
            "b) The choice of path is non-deterministic",
            "c) The state to be transited next is non-deterministic",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: A transducer is an automaton that produces an output on the basis of what input has been given currently or previous state."
    },
    {
        "id": 62,
        "Question": "The construction time for DFA from an equivalent NFA (m number of node)is:",
        "Options": [
            "a) O(m2)",
            "b) O(2m)",
            "c) O(m)",
            "d) O(log m)"
        ],
        "Answer": "Answer: c\nExplanation: The maximum number of sets for DFA converted from NFA would be not greater than 2n."
    },
    {
        "id": 63,
        "Question": "If n is the length of Input string and m is the number of nodes, the running time of DFA  is x that of NFA.Find x?",
        "Options": [
            "a) 1/m2",
            "b) 2m",
            "c) 1/m",
            "d) log m"
        ],
        "Answer": "Answer: b\nExplanation: Non deterministic or deterministic depends upon the definite path defined for the transition from one state to another or undefined(multiple paths)."
    },
    {
        "id": 64,
        "Question": "Which of the following option is correct?",
        "Options": [
            "a) NFA is slower to process and its representation uses more memory than DFA",
            "b) DFA is faster to process and its representation uses less memory than NFA",
            "c) NFA is slower to process and its representation uses less memory than DFA",
            "d) DFA is slower to process and its representation uses less memory than NFA"
        ],
        "Answer": "Answer: b\nExplanation: DFA is a specific case of NFA."
    },
    {
        "id": 65,
        "Question": "The number of tuples in an extended Non Deterministic Finite Automaton:",
        "Options": [
            "a) 5",
            "b) 6",
            "c) 7",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: For NFA or extended transition function on NFA, the tuple elements remains same i.e. 5."
    },
    {
        "id": 66,
        "Question": "What is the relation between DFA and NFA on the basis of computational power?",
        "Options": [
            "a) DFA > NFA",
            "b) NFA > DFA",
            "c) Equal",
            "d) Can’t be said"
        ],
        "Answer": "Answer: c\nExplanation: The given figure is an NFA. The statement contradicts itself."
    },
    {
        "id": 67,
        "Question": "If a string S is accepted by a finite state automaton, S=s1s2s3……sn where siϵ∑ and there exists a sequence of states r0, r1, r2…… rn such that δ(r(i), si+1) =ri+1 for each 0, 1, …n-1, then r(n) is:",
        "Options": [
            "a) initial state",
            "b) transition symbol",
            "c) accepting state",
            "d) intermediate state"
        ],
        "Answer": "Answer: c\nExplanation: q3 does not belong to Q where Q= set of finite states."
    },
    {
        "id": 68,
        "Question": "Subset Construction method refers to:",
        "Options": [
            "a) Conversion of NFA to DFA",
            "b) DFA minimization",
            "c) Eliminating Null references",
            "d) ε-NFA to NFA"
        ],
        "Answer": "Answer: a\nExplanation:  The conversion of a non-deterministic automata into a deterministic one is a process we call subset construction or power set construction."
    },
    {
        "id": 69,
        "Question": "If L is a regular language, Lc and Lr both will be:",
        "Options": [
            "a) Accepted by NFA",
            "b) Rejected by NFA",
            "c) One of them will be accepted",
            "d) Cannot be said"
        ],
        "Answer": "Answer: b\nExplanation: The finite automaton for the given language is made and thus, the answer can be obtained."
    },
    {
        "id": 70,
        "Question": "In NFA, this very state is like dead-end non final state:",
        "Options": [
            "a) ACCEPT",
            "b) REJECT",
            "c) DISTINCT",
            "d) START"
        ],
        "Answer": "Answer: c\nExplanation: The given diagram can be analysed and thus the option can be seeked."
    },
    {
        "id": 71,
        "Question": "We can represent one language in more one FSMs, true or false?",
        "Options": [
            "a) TRUE",
            "b) FALSE",
            "c) May be true",
            "d) Cannot be said"
        ],
        "Answer": "Answer: a\nExplanation:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-the-language-nfa-q4a.png\" alt=\"Find the equivalents DFA from the given diagram\" width=\"473\" height=\"159\" class=\"alignnone size-full wp-image-160266\" />\n"
    },
    {
        "id": 72,
        "Question": "The production of form non-terminal -> ε is called:",
        "Options": [
            "a) Sigma Production",
            "b) Null Production",
            "c) Epsilon Production",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: If L is a regular Language, Lc and Lr  both are regular even."
    },
    {
        "id": 73,
        "Question": "Which of the following is a regular language?",
        "Options": [
            "a) String whose length is a sequence of prime numbers",
            "b) String with substring wwr in between",
            "c) Palindrome string",
            "d) String with even number of Zero’s"
        ],
        "Answer": "Answer: b\nExplanation: REJECT state will be like a halting state which rejects a particular invalid input."
    },
    {
        "id": 74,
        "Question": "Which of the following recognizes the same formal language as of DFA and NFA?",
        "Options": [
            "a) Power set Construction",
            "b) Subset Construction",
            "c) Robin-Scott Construction",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: We can represent one language in more one FSMs, example for a same language we have a DFA and an equivalent NFA."
    },
    {
        "id": 75,
        "Question": "Under which of the following operation, NFA is not closed?",
        "Options": [
            "a) Negation",
            "b) Kleene",
            "c) Concatenation",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: NFA is said to be closed under the following operations:\na) Union\nb) Intersection\nc) Concatenation\nd) Kleene\ne) Negation\n"
    },
    {
        "id": 76,
        "Question": "It is less complex to prove the closure properties over regular languages using",
        "Options": [
            "a) NFA",
            "b) DFA",
            "c) PDA",
            "d) Can’t be said"
        ],
        "Answer": "Answer: a\nExplanation: We use the construction method to prove the validity of closure properties of regular languages. Thus, it can be observe, how tedious and complex is the construction of a DFA as compared to an NFA with respect to space.\n"
    },
    {
        "id": 77,
        "Question": "Which of the following is an application of Finite Automaton?",
        "Options": [
            "a) Compiler Design",
            "b) Grammar Parsers",
            "c) Text Search",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: There are many applications of finite automata, mainly in the field of Compiler Design and Parsers and Search Engines."
    },
    {
        "id": 78,
        "Question": "John is asked to make an automaton which accepts a given string for all the occurrence of ‘1001’ in it. How many number of transitions would John use such that, the string processing application works?",
        "Options": [
            "a) 9",
            "b) 11",
            "c) 12",
            "d) 15"
        ],
        "Answer": "Answer: a\nExplanation:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-equivalence-nfa-dfa-q4.png\" alt=\"Find the string processing application from the given diagram\" width=\"706\" height=\"151\" class=\"alignnone size-full wp-image-160270\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-equivalence-nfa-dfa-q4.png 706w, https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-equivalence-nfa-dfa-q4-300x64.png 300w\" sizes=\"(max-width: 706px) 100vw, 706px\" />\n"
    },
    {
        "id": 79,
        "Question": "Which of the following do we use to form an NFA from a regular expression?",
        "Options": [
            "a) Subset Construction Method",
            "b) Power Set Construction Method",
            "c) Thompson Construction Method",
            "d) Scott Construction Method"
        ],
        "Answer": "Answer: c\nExplanation: Thompson Construction method is used to turn a regular expression in an NFA by fragmenting the given regular expression through the operations performed on the input alphabets."
    },
    {
        "id": 80,
        "Question": "Which among the following can be an example of application of finite state machine(FSM)?",
        "Options": [
            "a) Communication Link",
            "b) Adder",
            "c) Stack",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Idle is the state when data in form of packets is send and returns if NAK is received else waits for the NAK to be received."
    },
    {
        "id": 81,
        "Question": "Which among the following is not an application of FSM?",
        "Options": [
            "a) Lexical Analyser",
            "b) BOT",
            "c) State charts",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Finite state automation is used in Lexical Analyser, Computer BOT (used in games), State charts, etc."
    },
    {
        "id": 82,
        "Question": "A binary string is divisible by 4 if and only if it ends with:",
        "Options": [
            "a) 100",
            "b) 1000",
            "c) 1100",
            "d) 0011"
        ],
        "Answer": "Answer: c\nExplanation: The DFA for the given language can be constructed as follows:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-aplications-dfa-q1.png\" alt=\"Find the total number of final states from the given diagram\" width=\"300\" height=\"90\" class=\"alignnone size-full wp-image-160275\" />\n"
    },
    {
        "id": 83,
        "Question": "Let L be a language whose FA consist of 5 acceptance states and 11 non final states. It further consists of a dumping state. Predict the number of acceptance states in Lc.",
        "Options": [
            "a) 16",
            "b) 11",
            "c) 5",
            "d) 6"
        ],
        "Answer": "Answer: a\nExplanation: If the string is divisible by four, it surely ends with the substring ‘100’ while a binary string divisible by 2 would surely end with the substring ‘10’."
    },
    {
        "id": 84,
        "Question": "If L1 and L2 are regular languages, which among the following is an exception?",
        "Options": [
            "a) L1 U L2",
            "b) L1 – L2",
            "c) L1 ∩ L2",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: If L leads to FA1, then for Lc, the FA can be obtained by exchanging the final and non-final states."
    },
    {
        "id": 85,
        "Options": [
            "8. Which of the following options is correct for the given statement?",
            "Statement: If K is the number of states in NFA, the DFA simulating the same language would have states less than 2k.",
            "a) True",
            "b) False"
        ],
        "Answer": "Answer: d\nExplanation: It the closure property of Regular language which lays down the following statement:\nIf L1, L2 are 2- regular languages, then L1 U L2, L1 ∩ L2, L1C, L1 – L2 are regular language."
    },
    {
        "id": 86,
        "Question": "Let N (Q, ∑, δ, q0, A) be the NFA recognizing a language L. Then for a DFA (Q’, ∑, δ’, q0’, A’), which among the following is true?",
        "Options": [
            "a) Q’ = P(Q)",
            "b) Δ’ = δ’ (R, a) = {q ϵ Q | q ϵ δ (r, a), for some r ϵ R}",
            "c) Q’ = {q0}",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: When set operation ‘-‘ is performed between two sets, it points to those values of prior set which belongs to it but not to the latter set analogous to basic subtraction operation."
    },
    {
        "id": 87,
        "Question": "There exists an initial state, 17 transition states, 7 final states and one dumping state, Predict the maximum number of states in its equivalent DFA?",
        "Options": [
            "a) 226",
            "b) 224",
            "c) 225",
            "d) 223"
        ],
        "Answer": "Answer: a\nExplanation: The NFA accepts all binary strings such that the third bit from right end is 1 and if not, is send to Dumping state. Note: It is assumed that the input is given from the right end bit by bit."
    },
    {
        "id": 88,
        "Question": "Under which of the following operation, NFA is not closed?",
        "Options": [
            "a) Negation",
            "b) Kleene",
            "c) Concatenation",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: NFA is said to be closed under the following operations:\na) Union\nb) Intersection\nc) Concatenation\nd) Kleene\ne) Negation."
    },
    {
        "id": 89,
        "Question": "It is less complex to prove the closure properties over regular languages using:",
        "Options": [
            "a) NFA",
            "b) DFA",
            "c) PDA",
            "d) Can’t be said"
        ],
        "Answer": "Answer: a\nExplanation: None."
    },
    {
        "id": 90,
        "Question": "Which of the following is an application of Finite Automaton?",
        "Options": [
            "a) Compiler Design",
            "b) Grammar Parsers",
            "c) Text Search",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: There are many applications of finite automata, mainly in the field of Compiler Design and Parsers and Search Engines."
    },
    {
        "id": 91,
        "Question": "John is asked to make an automaton which accepts a given string for all the occurrence of ‘1001’ in it. How many number of transitions would John use such that, the string processing application works?",
        "Options": [
            "a) 9",
            "b) 11",
            "c) 12",
            "d) 15"
        ],
        "Answer": "Answer: a\nExplanation: None."
    },
    {
        "id": 92,
        "Question": "Which of the following do we use to form an NFA from a regular expression?",
        "Options": [
            "a) Subset Construction Method",
            "b) Power Set Construction Method",
            "c) Thompson Construction Method",
            "d) Scott Construction Method"
        ],
        "Answer": "Answer: c\nExplanation: Thompson Construction method is used to turn a regular expression in an NFA by fragmenting the given regular expression through the operations performed on the input alphabets."
    },
    {
        "id": 93,
        "Question": "Which among the following can be an example of application of finite state machine(FSM)?",
        "Options": [
            "a) Communication Link",
            "b) Adder",
            "c) Stack",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Idle is the state when data in form of packets is send and returns if NAK is received else waits for the NAK to be received."
    },
    {
        "id": 94,
        "Question": "Which among the following is not an application of FSM?",
        "Options": [
            "a) Lexical Analyser",
            "b) BOT",
            "c) State charts",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Finite state automation is used in Lexical Analyser, Computer BOT (used in games), State charts, etc."
    },
    {
        "id": 95,
        "Options": [
            "2. State true or false?",
            "Statement: An NFA can be modified to allow transition without input alphabets, along with one or more transitions on input symbols.",
            "a) True",
            "b) False"
        ],
        "Answer": "Answer: d\nExplanation: The set of states which can be reached from q using ε-transitions, is called the ε-closure over state q."
    },
    {
        "id": 96,
        "Question": "",
        "Options": [
            "3. State true or false?",
            "Statement: ε (Input) does not appears on Input tape.",
            "a) True",
            "b) False"
        ],
        "Answer": "Answer: a\nExplanation: It is possible to construct an NFA with ε-transitions, presence of no input symbols, and that is called NFA with ε-moves."
    },
    {
        "id": 97,
        "Question": "ε- closure of q1 in the given transition graph:",
        "Options": [
            "a) {q1}",
            "b) {q0, q2}",
            "c) {q1, q2}",
            "d) {q0, q1, q2}"
        ],
        "Answer": "Answer: a\nExplanation: ε does not appears on Input tape, ε transition means a transition without scanning a symbol i.e. without moving the read head."
    },
    {
        "id": 98,
        "Question": "Predict the total number of final states after removing the ε-moves from the given NFA?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 0"
        ],
        "Answer": "Answer: c\nExplanation: The transition with ε leads to a jump but without any shift in read head. Further, the method can be called one to introduce hidden non-determinism."
    },
    {
        "id": 99,
        "Question": "For NFA with ε-moves, which among the following is correct?",
        "Options": [
            "a) Δ: Q X (∑ U {ε}) -> P(Q)",
            "b) Δ: Q X (∑) -> P(Q)",
            "c) Δ: Q X (∑*) -> P(Q)",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: ε-closure is defined as the set of states being reached through ε-transitions from a starting state."
    },
    {
        "id": 100,
        "Question": "The automaton which allows transformation to a new state without consuming any input symbols:",
        "Options": [
            "a) NFA",
            "b) DFA",
            "c) NFA-l",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The NFA which would result after eliminating ε-moves can be shown diagramatically."
    },
    {
        "id": 101,
        "Question": "e-transitions are",
        "Options": [
            "a) conditional",
            "b) unconditional",
            "c) input dependent",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Due to the presence of ε symbol, or rather an epsilon-move, the input alphabets unites with it to form a set including ε."
    },
    {
        "id": 102,
        "Question": "The __________ of a set of states, P, of an NFA is defined as the set of states reachable from any state in P following e-transitions.",
        "Options": [
            "a) e-closure",
            "b) e-pack",
            "c) Q in the tuple",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All the mentioned are the closure properties of ε and encircles all the elements if it satisfies the following options:\na) Every element of S ϵ Q\nb) For any q ϵ ε(S), every element of δ (q, ε) is in ε(S)\nc) No other element is in ε(S)"
    },
    {
        "id": 103,
        "Question": "The e-NFA  recognizable languages are not closed under :",
        "Options": [
            "a) Union",
            "b) Negation",
            "c) Kleene Closure",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: NFA-l or e-NFA is an extension of Non deterministic Finite Automata which are usually called NFA with epsilon moves or lambda transitions."
    },
    {
        "id": 104,
        "Question": "The automaton which allows transformation to a new state without consuming any input symbols:",
        "Options": [
            "a) NFA",
            "b) DFA",
            "c) NFA-l",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: NFA-l or e-NFA is an extension of Non deterministic Finite Automata which are usually called NFA with epsilon moves or lambda transitions."
    },
    {
        "id": 105,
        "Question": "e-transitions are",
        "Options": [
            "a) conditional",
            "b) unconditional",
            "c) input dependent",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: An epsilon move is a transition from one state to another that doesn’t require any specific condition."
    },
    {
        "id": 106,
        "Question": "The __________ of a set of states, P, of an NFA is defined as the set of states reachable from any state in P following e-transitions.",
        "Options": [
            "a) e-closure",
            "b) e-pack",
            "c) Q in the tuple",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The e-closure of a set of states, P, of an NFAis defined as the set of states reachable from any state in P following e-transitions."
    },
    {
        "id": 107,
        "Question": "The e-NFA  recognizable languages are not closed under ___________",
        "Options": [
            "a) Union",
            "b) Negation",
            "c) Kleene Closure",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The languages which are recognized by an epsilon Non deterministic automata are closed under the following operations:\ni) Union\nii) Intersection\niii) Concatenation\niv) Negation\nv) Star\nvi) Kleene closure"
    },
    {
        "id": 108,
        "Question": "An e-NFA is ___________ in representation.",
        "Options": [
            "a) Quadruple",
            "b) Quintuple",
            "c) Triple",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Yes, the language is preserved during the dteps of construction: L(N)=L(N1)=L(N2)=L(3)."
    },
    {
        "id": 109,
        "Options": [
            "7. State true or false:",
            "Statement: Both NFA and e-NFA recognize exactly the same languages.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: An e-NFA consist of 5 tuples: A=(Q, S, d, q0, F)\nNote: e is never a member of S."
    },
    {
        "id": 110,
        "Question": "Which of the following does not belong to input alphabet if S={a, b}* for any language?",
        "Options": [
            "a) a",
            "b) b",
            "c) e",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The automaton may be allowed to change its state without reading the input symbol using epsilon but this does not mean that epsilon has become an input symbol. On the contrary, one assumes that the symbol epsilon does not belong to any alphabet."
    },
    {
        "id": 111,
        "Options": [
            "3. State true or false:",
            "Statement: Both NFA and e-NFA recognize exactly the same languages.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-epsilon-closures-q2.png\" alt=\"Find the language even or divisible by 3 from the given diagram\" width=\"303\" height=\"353\" class=\"alignnone size-full wp-image-160285\" />\n"
    },
    {
        "id": 112,
        "Question": "Regular sets are closed under union,concatenation and kleene closure.",
        "Options": [
            "a) True",
            "b) False",
            "c) Depends on regular set",
            "d) Can’t say"
        ],
        "Answer": " Answer:a\nExplanation: Regular sets are closed under these three operation.\n"
    },
    {
        "id": 113,
        "Question": "Complement of a DFA can be obtained by",
        "Options": [
            "a) making starting state as final state",
            "b) no trival method",
            "c) making final states non-final and non-final to final",
            "d) make final as a starting state"
        ],
        "Answer": " Answer:c\nExplanation: String accepted in previous DFA will not be accepted and non accepting string will be accepted .\n"
    },
    {
        "id": 114,
        "Question": "Complement of regular sets are _________",
        "Options": [
            "a) Regular",
            "b) CFG",
            "c) CSG",
            "d) RE"
        ],
        "Answer": " Answer:a\nExplanation: Regular sets are closed under complement operation.\n"
    },
    {
        "id": 115,
        "Question": "If L1 and L2 are regular sets then intersection of these two will be",
        "Options": [
            "a) Regular",
            "b) Non Regular",
            "c) Recursive",
            "d) Non Recursive"
        ],
        "Answer": " Answer:a\nExplanation: Regular expression are also colsed under intersection.\n"
    },
    {
        "id": 116,
        "Question": "If L1 is regular L2 is unknown but L1-L2 is regular ,then L2 must be",
        "Options": [
            "a) Empty set",
            "b) CFG",
            "c) Decidable",
            "d) Regular"
        ],
        "Answer": " Answer:d\nExplanation: Regular is closed under difference.\n"
    },
    {
        "id": 117,
        "Question": "Reverse of a DFA can be formed by",
        "Options": [
            "a) using PDA",
            "b) making final state as non-final",
            "c) making final as starting state and starting state as final state",
            "d) None of the mentioned"
        ],
        "Answer": " Answer:c\nExplanation: By making final state as starting state string starting from end will be accepted.\n"
    },
    {
        "id": 118,
        "Question": "Reverse of (0+1)* will be",
        "Options": [
            "a) Phi",
            "b) Null",
            "c) (0+1)*",
            "d) (0+1)"
        ],
        "Answer": " Answer:c\nExplanation: There is only one state which is start and final state of DFA so interchanging starting start and final state doesn’t change DFA.\n"
    },
    {
        "id": 119,
        "Question": "A ___________ is a substitution such that h(a) contains a string for each a.",
        "Options": [
            "a) Closure",
            "b) Interchange",
            "c) Homomorphism",
            "d) Inverse Homomorphism"
        ],
        "Answer": " Answer:c\nExplanation: This operation replace using a function .\n"
    },
    {
        "id": 120,
        "Question": "Homomorphism of a regular set is _______",
        "Options": [
            "a) Universal set",
            "b) Null set",
            "c) Regular set",
            "d) Non regular set"
        ],
        "Answer": " Answer:c\nExplanation: Regular set are closed under homomorphism.\n"
    },
    {
        "id": 121,
        "Question": "(a ^ 5b ^ 5)* is example of ________",
        "Options": [
            "a) Type 0 language",
            "b) Type 1 language",
            "c) Type 2 language",
            "d) Type 3 language"
        ],
        "Answer": " Answer:d\nExplanation: It is a regular expression.\n"
    },
    {
        "id": 122,
        "Question": "Which of the following is type 3 language ?",
        "Options": [
            "a) Strings of 0’s whose length is perfect square",
            "b) Palindromes string",
            "c) Strings of 0’s having length prime number",
            "d) String of odd number of 0’s"
        ],
        "Answer": " Answer:d\nExplanation: Only d is regular language.\n"
    },
    {
        "id": 123,
        "Question": "a ^ nb ^ n where (n+m) is even .",
        "Options": [
            "a) Type 0",
            "b) Type 1",
            "c) Type 2",
            "d) Type 3"
        ],
        "Answer": " Answer:d\nExplanation: It is a regular expression.\n"
    },
    {
        "id": 124,
        "Question": "Complement of a ^ nb ^ m where n >= 4 and m <= 3 is example of",
        "Options": [
            "a) Type 0",
            "b) Type 1",
            "c) Type 2",
            "d) Type 3"
        ],
        "Answer": " Answer:d\nExplanation: It is a regular expression.\n"
    },
    {
        "id": 125,
        "Question": "a ^ nb ^ m where n >= 1, m >= 1, nm >= 3 is example of",
        "Options": [
            "a) Type 0",
            "b) Type 1",
            "c) Type 2",
            "d) Type 3"
        ],
        "Answer": " Answer:d\nExplanation: It is a regular expression.\n"
    },
    {
        "id": 126,
        "Question": "Complement of (a + b)* will be",
        "Options": [
            "a) phi",
            "b) null",
            "c) a",
            "d) b"
        ],
        "Answer": " Answer:a\nExplanation: Given expression accept all string so complement will accept nothing.\n"
    },
    {
        "id": 127,
        "Question": "L is a regular Language if and only If the set of __________ classes of IL is finite.",
        "Options": [
            "a) Equivalence",
            "b) Reflexive",
            "c) Myhill",
            "d) Nerode"
        ],
        "Answer": "Answer: a\nExplanation: According to Myhill Nerode theorem, the corollary proves the given statement correct for equivalence classes. "
    },
    {
        "id": 128,
        "Question": "A language can be generated from simple primitive language in a simple way if and only if",
        "Options": [
            "a) It is recognized by a device of infinite states",
            "b) It takes no auxiliary memory",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A language is regular if and only if it can be accepted by a finite automaton. Secondly, It supports no concept of auxiliary memory as it loses the data as soon as the device is shut down."
    },
    {
        "id": 129,
        "Question": "Concatenation Operation refers to which of the following set operations:",
        "Options": [
            "a) Union",
            "b) Dot",
            "c) Kleene",
            "d) Two of the options are correct"
        ],
        "Answer": "Answer: d\nExplanation: The given option represents {0, 01} in different forms using set operations and Regular Expressions. The operator like ^, v, etc. are logical operation and they form invalid regular expressions when used."
    },
    {
        "id": 130,
        "Question": "Concatenation of R with Ф outputs:",
        "Options": [
            "a) R",
            "b) Ф",
            "c) R.Ф",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The extended notation would be (0+1)4 but however, we may allow some or all the factors to be ε. Thus ε needs to be included in the given regular expression."
    },
    {
        "id": 131,
        "Question": "RR* can be expressed in which of the forms:",
        "Options": [
            "a) R+",
            "b) R-",
            "c) R+ U R-",
            "d) R"
        ],
        "Answer": "Answer: a\nExplanation: The given regular expression corresponds to a language of binary strings which is of even length including a length of 0."
    },
    {
        "id": 132,
        "Question": "A finite automaton accepts which type of language:",
        "Options": [
            "a) Type 0",
            "b) Type 1",
            "c) Type 2",
            "d) Type 3"
        ],
        "Answer": "Answer: d\nExplanation: Type 3 refers to Regular Languages which is accepted by a finite automaton."
    },
    {
        "id": 133,
        "Question": "Which among the following are incorrect regular identities?",
        "Options": [
            "a) εR=R",
            "b) ε*=ε",
            "c) Ф*=ε",
            "d) RФ=R"
        ],
        "Answer": "Answer: d\nExplanation: There are few identities over Regular Expressions which include: RФ=ФR=Ф≠R"
    },
    {
        "id": 134,
        "Question": "Arden’s theorem is true for:",
        "Options": [
            "a) More than one initial states",
            "b) Null transitions",
            "c) Non-null transitions",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: ε+1*(011) *(1*(011) *) *\nε + RR*= ε + R*R= ε + R+= R*"
    },
    {
        "id": 135,
        "Question": "The difference between number of states with regular expression (a + b) and (a + b) * is:",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 0"
        ],
        "Answer": "Answer: b\nExplanation: The given statement is the Arden’s Theorem and it tends to have a unique solution as QP*.\nLet P and Q be regular expressions,\nR=Q+RP\nR=Q+(Q+RP) P\nR=Q+((Q+RP) +RP) +P=Q+QP+RPP+RPP=Q+QP+(Q+RP) PP+(Q+RP) PP=Q+QP+QPP+RPPP+QPP+RPPP,\nIf we do this recursively, we get:\nR= QP*"
    },
    {
        "id": 136,
        "Question": "In order to represent a regular expression, the first step to create the transition diagram is:",
        "Options": [
            "a) Create the NFA using Null moves",
            "b)  Null moves are not acceptable, thus should not be used",
            "c) Predict the number of states to be used in order to construct the Regular expression",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Arden’s theorem strictly assumes the following;\na) No null transitions in the transition diagrams\nb) True for only single initial state"
    },
    {
        "id": 137,
        "Question": "(0+ε) (1+ε) represents",
        "Options": [
            "a) {0, 1, 01, ε}",
            "b) {0, 1, ε}",
            "c) {0, 1, 01 ,11, 00, 10, ε}",
            "d) {0, 1}"
        ],
        "Answer": "Answer: a\nExplanation:\n"
    },
    {
        "id": 138,
        "Question": "Regular Expression denote precisely the ________ of Regular Language.",
        "Options": [
            "a) Class",
            "b) Power Set",
            "c) Super Set",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Two steps are to be followed while converting a regular expression into a transition diagram:\na) Construct the NFA using null moves.\nb) Remove the null transitions and convert it into its equivalent DFA."
    },
    {
        "id": 139,
        "Question": "The appropriate precedence order of operations over a Regular Language is",
        "Options": [
            "a) Kleene, Union, Concatenate",
            "b) Kleene, Star, Union",
            "c) Kleene, Dot, Union",
            "d) Star, Union, Dot"
        ],
        "Answer": "Answer: a\nExplanation: ε represents a single string in the set namely, the empty string while Statement 2 is also correct. "
    },
    {
        "id": 140,
        "Question": "Regular Expression R and the language it describes can be represented as:",
        "Options": [
            "a) R, R(L)",
            "b) L(R), R(L)",
            "c) R, L(R)",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: If a regular language expression is given, the appropriate order of precedence if the parenthesis is ignored is: Star or Kleene, Dot or Concatenation, Union or Plus. "
    },
    {
        "id": 141,
        "Question": "Let for ∑= {0,1} R= (∑∑∑) *, the language of R would be",
        "Options": [
            "a) {w | w is a string of odd length}",
            "b) {w | w is a string of length multiple of 3}",
            "c) {w | w is a string of length 3}",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: When we wish to distinguish between a regular expression R and the language it represents; we write L(R) to be the language of R."
    },
    {
        "id": 142,
        "Question": "If ∑= {0,1}, then Ф* will result to:",
        "Options": [
            "a) ε",
            "b) Ф",
            "c) ∑",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: This regular expression can be used to eliminate the answers and get the result. The length can be even and as well more than 3 when R= (∑∑∑) (∑∑∑) (particular case)."
    },
    {
        "id": 143,
        "Question": "The given NFA represents which of the following NFA",
        "Options": [
            "a) (ab U a) *",
            "b) (a*b* U a*)",
            "c) (ab U a*)",
            "d) (ab)* U a*"
        ],
        "Answer": "Answer: a\nExplanation: The star operation brings together any number of strings from the language to get a string in the result. If the language is empty, the star operation can put together 0 strings, resulting only the empty string."
    },
    {
        "id": 144,
        "Question": "Which of the following represents a language which has no pair of consecutive 1’s if ∑= {0,1}?",
        "Options": [
            "a) (0+10)*(1+ε)",
            "b) (0+10)*(1+ε)*",
            "c) (0+101)*(0+ε)",
            "d) (1+010)*(1+ε)"
        ],
        "Answer": "Answer: a\nExplanation: The Regular expression (ab U a) * is converted to NFA in a sequence of stages as it can be clearly seen in the diagram. This NFA consist of 8 stated while its minimized form only contains 2 states."
    },
    {
        "id": 145,
        "Question": "The finite automata accept the following languages:",
        "Options": [
            "a) Context Free Languages",
            "b) Context Sensitive Languages",
            "c) Regular Languages",
            "d) All the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: All the options except ‘a’ accept those strings which comprises minimum one pair of 1’s together."
    },
    {
        "id": 146,
        "Question": "(a + b*c) most correctly represents:",
        "Options": [
            "a) (a +b) *c",
            "b) (a)+((b)*.c)",
            "c) (a + (b*)).c",
            "d) a+ ((b*).c)"
        ],
        "Answer": "Answer: c\nExplanation: A finite automaton accepts the languages which are regular and for which a DFA can be constructed."
    },
    {
        "id": 147,
        "Question": " Which of the following regular expressions represents the set of strings which do not contain a substring ‘rt’ if ∑= {r, t}",
        "Options": [
            "a) (rt)*",
            "b) (tr)*",
            "c) (r*t*)",
            "d) (t*r*)"
        ],
        "Answer": "Answer: d\nExplanation: Following the rules of precedence, Kleene or star operation would be done first, then concatenation and finally union or plus operation."
    },
    {
        "id": 148,
        "Question": "According to the precedence rules, x-y-z is equivalent to which of the following?",
        "Options": [
            "a) (x-y)-z",
            "b) x-(y-z)",
            "c) Both (x-y)-z and x-(y-z)",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: As Kleene operation is not on the whole of the substring, it will not repeat and maintain the order of t, r."
    },
    {
        "id": 149,
        "Question": "Dot operator in regular expression resembles which of the following?",
        "Options": [
            "a) Expressions are juxtaposed",
            "b) Expressions are multiplied",
            "c) Cross operation",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: In arithmetic, we group two of the same operators from the left, hence x-y-z is equivalent to (x-y)-z and not x-(y—z)."
    },
    {
        "id": 150,
        "Question": "Which among the following is not an associative operation?",
        "Options": [
            "a) Union",
            "b) Concatenation",
            "c) Dot",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Dot operation or concatenation operation means that the two expressions are juxtaposed i.e. there are no intervening operators in between. In fact, UNIX regular expressions use the dot for an entirely different purpose: representing any ASCII character."
    },
    {
        "id": 151,
        "Question": "Which of the following statements is not true?",
        "Options": [
            "a) Every language defined by any of the automata is also defined by a regular expression",
            "b) Every language defined by a regular expression can be represented using a DFA",
            "c) Every language defined by a regular expression can be represented using NFA with e moves",
            "d) Regular expression is just another representation for any automata definition"
        ],
        "Answer": "Answer: a\nExplanation: There needs to be 001 together in the string as an essential substring. Thus, the other components can be anything, 0 or 1 or e."
    },
    {
        "id": 152,
        "Question": "The minimum number of states required in a DFA (along with a dumping state)  to check whether the 3rd bit is 1 or not for |n|>=3",
        "Options": [
            "a) 3",
            "b) 4",
            "c) 5",
            "d) 1"
        ],
        "Answer": "Answer: b\nExplanation: Using NFA with e moves, we can represent all the regular expressions as an automata. As regular expressions include e, we need to use  e moves."
    },
    {
        "id": 153,
        "Question": "Which of the following is an utility of state elimination phenomenon?",
        "Options": [
            "a) DFA to NFA",
            "b) NFA to DFA",
            "c) DFA to Regular Expression",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: We use this algorithm to simplify a finite automaton to regular expression or vice versa. We eliminate states while converting given finite automata to its corresponding regular expression."
    },
    {
        "id": 154,
        "Question": "If we have more than one accepting states or an accepting state with an outdegree, which of the following actions will be taken?",
        "Options": [
            "a) addition of new state",
            "b) removal of a state",
            "c) make the newly added state as final",
            "d) more than one option is correct"
        ],
        "Answer": "Answer: d\nExplanation: If there is more than one accepting state or if the single accepting state as an out degree, add a new accepting state, make all other states non accepting, and hold an e-transitions from each former accepting state to the new accepting state."
    },
    {
        "id": 155,
        "Question": "Which of the following is not a step in elimination of states procedure?",
        "Options": [
            "a) Unifying all the final states into one using e-transitions",
            "b) Unify single transitions to multi transitions that contains union of input",
            "c) Remove states until there is only starting and accepting states",
            "d) Get the resulting regular expression by direct calculation"
        ],
        "Answer": "Answer: b\nExplanation: While eliminating the states, we unify multiple transitions to one transition that contains union of input and not the vice versa."
    },
    {
        "id": 156,
        "Options": [
            "4. Can the given state diagram be reduced?",
            "<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-mcqs-q4.png\" alt=\"Find the state q2 from the given diagram\" width=\"353\" height=\"144\" class=\"alignnone size-full wp-image-160562\" />",
            "a) Yes",
            "b) No"
        ],
        "Answer": "Answer: a\nExplanation: The state q2 can be eliminated with ease and the reduced state diagram can be represented as:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-mcqs-q4a.png\" alt=\"Find the reduced state diagram from the given diagram\" width=\"382\" height=\"171\" class=\"alignnone size-full wp-image-160565\" />\n"
    },
    {
        "id": 157,
        "Question": "Which of the following methods is suitable for conversion of DFA to RE?",
        "Options": [
            "a) Brzozowski method",
            "b) Arden’s method",
            "c) Walter’s method",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Brzozowski method takes a unique approach to generating regular expressions. We create a system of regular expressions with one regular expression unknown for each state in M, and then we solve the system for Rλ where Rλ is the regular expression associated with starting state qλ."
    },
    {
        "id": 158,
        "Question": "",
        "Options": [
            "6. State true or false:",
            "Statement: The state removal approach identifies patterns within the graph and removes state, building up regular expressions along each transition.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: This method has the advantage over the transitive closure technique as it can easily be visualized."
    },
    {
        "id": 159,
        "Question": "The behaviour of NFA can be simulated using DFA.",
        "Options": [
            "a) always",
            "b) never",
            "c) sometimes",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: For every NFA, there exists an equivalent DFA and vice versa."
    },
    {
        "id": 160,
        "Question": "It is suitable to use ____________ method/methods to convert a DFA to regular expression.",
        "Options": [
            "a) Transitive Closure properties",
            "b) Brzozowski method",
            "c) State elimination method",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: For converting RE to DFA , first we convert RE to NFA (Thompson Construction), and then NFA is converted into DFA(Subset Construction)."
    },
    {
        "id": 161,
        "Question": "",
        "Options": [
            "9. State true or false:",
            "Statement: For every removed state, there is a regular expression produced.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: For every state which is eliminated, a new regular expression is produced. The newly generated regular expression act as an input for a state which is next to removed state."
    },
    {
        "id": 162,
        "Question": "A regular language over an alphabet a is one that can be obtained from",
        "Options": [
            "a) union",
            "b) concatenation",
            "c) kleene",
            "d) All of the mentioned"
        ],
        "Answer": " Answer: d\nExplanation: None.\n"
    },
    {
        "id": 163,
        "Question": "Regular expression {0,1} is equivalent to",
        "Options": [
            "a) 0 U 1",
            "b) 0 / 1",
            "c) 0 + 1",
            "d) All of the mentioned"
        ],
        "Answer": " Answer: d\nExplanation: All are equivalent to union operation.\n"
    },
    {
        "id": 164,
        "Question": "Precedence of regular expression in decreasing order is",
        "Options": [
            "a) * , . , +",
            "b) . , * , +",
            "c) . , + , *",
            "d) + , a , *"
        ],
        "Answer": " Answer: a\nExplanation: None.\n"
    },
    {
        "id": 165,
        "Question": "Regular expression Φ* is equivalent to",
        "Options": [
            "a) ϵ",
            "b) Φ",
            "c) 0",
            "d) 1"
        ],
        "Answer": " Answer: a\nExplanation: None.\n"
    },
    {
        "id": 166,
        "Question": "a? is equivalent to",
        "Options": [
            "a) a",
            "b) a+Φ",
            "c) a+ϵ",
            "d) wrong expression"
        ],
        "Answer": " Answer: c\nExplanation: Zero or one time repetition of previous character .\n"
    },
    {
        "id": 167,
        "Question": "ϵL is equivalent to",
        "Options": [
            "a) ϵ",
            "b) Φ",
            "c) L",
            "d) Φϵ"
        ],
        "Answer": " Answer: c\nExplanation: None.\n"
    },
    {
        "id": 168,
        "Question": "(a+b)* is equivalent to",
        "Options": [
            "a) b*a*",
            "b) (a*b*)*",
            "c) a*b*",
            "d) none of the mentioned"
        ],
        "Answer": " Answer: b\nExplanation: None.\n"
    },
    {
        "id": 169,
        "Question": "ΦL is equivalent to",
        "Options": [
            "a) LΦ & Φ",
            "b) Φ & L",
            "c) L & L",
            "d) ϵ & L"
        ],
        "Answer": " Answer: a\nExplanation: None.\n"
    },
    {
        "id": 170,
        "Question": "Which of the following pair of regular expression are not equivalent?",
        "Options": [
            "a) 1(01)* and (10)*1",
            "b) x(xx)* and (xx)*x",
            "c) (ab)* and a*b*",
            "d) x+ and x*x+"
        ],
        "Answer": " Answer: c\nExplanation: (ab)*=(a*b*)*.\n"
    },
    {
        "id": 171,
        "Question": "How many strings of length less than 4 contains the language described by the regular expression (x+y)*y(a+ab)*?",
        "Options": [
            "a) 7",
            "b) 10",
            "c) 12",
            "d) 11"
        ],
        "Answer": " Answer: c\nExplanation: string of length 0 = Not possible (because y is always present).\nstring of length 1 = 1 (y)\nstring of length 2 = 3 (xy,yy,ya)\nstring of length 3 = 8 (xxy,xyy,yxy,yyy,yaa,yab,xya,yya)\n"
    },
    {
        "id": 172,
        "Question": "Which of the following is true?",
        "Options": [
            "a) (01)*0 = 0(10)*",
            "b) (0+1)*0(0+1)*1(0+1) = (0+1)*01(0+1)*",
            "c) (0+1)*01(0+1)*+1*0* = (0+1)*",
            "d) All of the mentioned"
        ],
        "Answer": " Answer: d\nExplanation: None.\n"
    },
    {
        "id": 173,
        "Question": "A language is regular if and only if",
        "Options": [
            "a) accepted by DFA",
            "b) accepted by PDA",
            "c) accepted by LBA",
            "d) accepted by Turing machine"
        ],
        "Answer": " Answer: a\nExplanation: All of above machine can accept regular language but all string accepted by machine is regular only for DFA.\n"
    },
    {
        "id": 174,
        "Question": "Regular grammar is",
        "Options": [
            "a) context free grammar",
            "b) non context free grammar",
            "c) english grammar",
            "d) none of the mentioned"
        ],
        "Answer": " Answer: a\nExplanation: Regular grammar is subset of context free grammar.\n"
    },
    {
        "id": 175,
        "Question": "Let the class of language accepted by finite state machine be L1 and the class of languages represented by regular expressions be L2 then",
        "Options": [
            "a) L1<L2",
            "b) L1>=L2",
            "c) L1 U L2 = .*",
            "d) L1=L2"
        ],
        "Answer": " Answer: d\nExplanation: Finite state machine and regular expression have same power to express a language.\n"
    },
    {
        "id": 176,
        "Question": "Which of the following is not a regular expression?",
        "Options": [
            "a) [(a+b)*-(aa+bb)]*",
            "b) [(0+1)-(0b+a1)*(a+b)]*",
            "c) (01+11+10)*",
            "d) (1+2+0)*(1+2)*"
        ],
        "Answer": " Answer: b\nExplanation: Except b all are regular expression*.\n"
    },
    {
        "id": 177,
        "Question": "Regular expression are",
        "Options": [
            "a) Type 0 language",
            "b) Type 1 language",
            "c) Type 2 language",
            "d) Type 3 language"
        ],
        "Answer": " Answer: d\nExplanation: According to Chomsky hierarchy,\nType 0 – Unrestricted Grammar.\nType 1 – Context Sensitive Grammar.\nType 2 – Context Free Grammar.\nType 3 – Regular Grammar.\n"
    },
    {
        "id": 178,
        "Question": "Which of the following is true?",
        "Options": [
            "a) Every subset of a regular set is regular",
            "b) Every finite subset of non-regular set is regular",
            "c) The union of two non regular set is not regular",
            "d) Infinite union of finite set is regular"
        ],
        "Answer": " Answer: b\nExplanation: None.\n"
    },
    {
        "id": 179,
        "Question": "L and ~L are recursive enumerable then L is",
        "Options": [
            "a) Regular",
            "b) Context free",
            "c) Context sensitive",
            "d) Recursive"
        ],
        "Answer": " Answer: d\nExplanation:If L is recursive enumerable and its complement too if and only if L is recursive.\n"
    },
    {
        "id": 180,
        "Question": "Regular expressions are closed under",
        "Options": [
            "a) Union",
            "b) Intersection",
            "c) Kleen star",
            "d) All of the mentioned"
        ],
        "Answer": " Answer: d\nExplanation: According to definition of regular expression.\n"
    },
    {
        "id": 181,
        "Question": "What kind of expressions do we used for pattern matching?",
        "Options": [
            "a) Regular Expression",
            "b) Rational Expression",
            "c) Regular & Rational Expression",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: In automata theory, Regular Expression(sometimes also called the Rational Expression  ) is a sequence or set of characters that define a search pattern, mainly for the use in pattern matching with strings or string matching."
    },
    {
        "id": 182,
        "Question": "Which of the following do Regexps do not find their use in?",
        "Options": [
            "a) search engines",
            "b) word processors",
            "c) sed",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Regexp processors are found in several search engines, seach and replace mechanisms, and text processing utilities."
    },
    {
        "id": 183,
        "Question": "Which of the following languages have built in regexps support?",
        "Options": [
            "a) Perl",
            "b) Java",
            "c) Python",
            "d) C++"
        ],
        "Answer": "Answer: a\nExplanation: Many languages come with built in support of regexps like Perl, Javascript, Ruby etc. While some provide support using standard libraries like .NET, Java, Python, C++, C and POSIX."
    },
    {
        "id": 184,
        "Question": "The following is/are an approach to process a regexp:",
        "Options": [
            "a) Construction of NFA and subsequently, a DFA",
            "b) Thompson’s Contruction Algorithm",
            "c) Thompson’s Contruction Algorithm & Construction of NFA and subsequently, a DFA",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: A regexp processor translates the syntax into internal representation which can be executed and matched with a string and that internal representation can have several approaches like the ones mentioned."
    },
    {
        "id": 185,
        "Question": "Are the given two patterns equivalent?",
        "Options": [
            "(1) gray|grey",
            "(2) gr(a|e)y",
            "a) yes",
            "b) no"
        ],
        "Answer": "Answer: a\nExplanation: Paranthesis can be used to define the scope and precedence of operators. Thus, both the expression represents the same pattern."
    },
    {
        "id": 186,
        "Question": "Which of the following are not quantifiers?",
        "Options": [
            "a) Kleene plus +",
            "b) Kleene star *",
            "c) Question mark ?",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: A quantifier after a  token specifies how often the preceding element is allowed to occur. ?, *, +, {n}, {min, }, {min, max} are few quantifiers we use in regexps implementations.\n"
    },
    {
        "id": 187,
        "Question": "Which of the following cannot be used to decide whether and how a given regexp matches a string:",
        "Options": [
            "a) NFA to DFA",
            "b) Lazy DFA algorithm",
            "c) Backtracking",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: There are at least three algorithms which decides for us, whether and how a regexp matches a string which included the transformation of Non deterministic automaton to deterministic finite automaton, The lazy DFA algorithm where one simulates the NFA directly, building each DFA on demand and then discarding it at the next step and the process of backtracking whose running time is exponential."
    },
    {
        "id": 188,
        "Question": "8. What does the following segment of code output?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"c\"><pre class=\"de1\">$string1 <span class=\"sy0\">=</span> <span class=\"st0\">\"Hello World<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">;</span>\n<span class=\"kw1\">if</span> <span class=\"br0\">(</span>$string1 <span class=\"sy0\">=</span>~ m<span class=\"sy0\">/</span><span class=\"br0\">(</span>H..<span class=\"br0\">)</span>.<span class=\"br0\">(</span>l..<span class=\"br0\">)</span><span class=\"sy0\">/</span><span class=\"br0\">)</span> <span class=\"br0\">{</span>\n  print <span class=\"st0\">\"We matched '$1' and '$2'.<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">;</span>\n<span class=\"br0\">}</span></pre></div></div></div></div></div></div>",
        "Options": [
            "a) We matched ‘Hel’ and ‘ld’",
            "b) We matched ‘Hel’ and ‘lld’",
            "c) We matched ‘Hel’ and ‘lo ‘",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: () groups a series of pattern element to a single element.\nWhen we use pattern in parenthesis, we can use any of ‘$1’, ‘$2’ later to refer to the previously matched pattern."
    },
    {
        "id": 189,
        "Question": "What does the symbol /z does?",
        "Options": [
            "a) changes line",
            "b) matches the beginning of a string",
            "c) matches the end of a string",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: It matches the end of a string and not an internal line.The given segment of code outputs:\nHello\nWorld\n is a string that ends with ‘d\\n’"
    },
    {
        "id": 190,
        "Question": "Conversion of a regular expression into its corresponding NFA :",
        "Options": [
            "a) Thompson’s Construction Algorithm",
            "b) Powerset Construction",
            "c) Kleene’s algorithm",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Thompson construction algorithm is an algorithm in automata theory used to convert a given regular expression into NFA. Similarly, Kleene algorithm is used to convert a finite automaton to a regular expression."
    },
    {
        "id": 191,
        "Question": "Which among the following is not a UNIX command for regular expressions?",
        "Options": [
            "a) ed",
            "b) sed",
            "c) vi",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Regular expressions are used by different commands in Unix like ed, sed, grep, awk, vi, etc. Sed stands for stream editor which is exclusively used for executing scripts."
    },
    {
        "id": 192,
        "Question": "What is the significance of $ used in regular expression in UNIX?",
        "Options": [
            "a) Matches the beginning of the line",
            "b) Matches the end of lines",
            "c) Matches any single character",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Regular expression provides more flexibility while matching string patterns. Special characters like ^, $, *, . are very useful."
    },
    {
        "id": 193,
        "Question": "Generate the regular expression to match blank lines",
        "Options": [
            "a) / */",
            "b) /bl",
            "c) /^?/",
            "d) /^$/"
        ],
        "Answer": "Answer: d\nExplanation: There are few expressions which provide the utility of matching metacharacters including /^$/ for blank lines,  / */ for matching one or more spaces, /^.*$/ for matching an entire line whatever it is."
    },
    {
        "id": 194,
        "Question": "What does grep do in UNIX?",
        "Options": [
            "a) It is an editor in UNIX",
            "b) It searches for text patterns",
            "c) It is an editor in UNIX and it searches for text patterns",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: In the general syntax of sed, pattern is the regular expression and action refers to the command given (p: prints the line, d: deletes the line, etc)."
    },
    {
        "id": 195,
        "Options": [
            "6. State true or false:",
            "Statement: A regular expression is a sequence of characters that represent a pattern.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: The grep is a standard UNIX utility program that searches through a set of files in search of a text pattern,specified through a regular expression."
    },
    {
        "id": 196,
        "Question": "What does “X?” do regular expression operator?",
        "Options": [
            "a) Matches zero or more capital X’s",
            "b) Matches no or one occurence of the capital letter X",
            "c) Matches one or more capital X’s",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Such a generated pattern could be a fixed word or describe something like more general. "
    },
    {
        "id": 197,
        "Question": "Which of the following does not support regular expressions?",
        "Options": [
            "a) sed",
            "b) awk",
            "c) emacs",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Regular expressions are very much invaluable tools; they can be used to find a particular segment of line in a file and instruct to take certain actions."
    },
    {
        "id": 198,
        "Question": "Lexemes can be referred to as:",
        "Options": [
            "a) elements of lexicography",
            "b) sequence of alphanumeric characters in a token",
            "c) lexical errors",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation:  A lexeme is a string of characters that form a syntactic unit. It is reasonable to say that is the sequence of alphanumeric characters in a token."
    },
    {
        "id": 199,
        "Question": "If the lexical analyser finds a lexeme with the same name as that of a reserved word,it _________",
        "Options": [
            "a) overwrites the word",
            "b) overwrites the functionality",
            "c) generates an error",
            "d) something else"
        ],
        "Answer": "Answer: c\nExplanation: Reserved words are known as keywords and they are specific and reserved with its functionality to a language. Thus, getting an input with the same name by the analyzer will generate an error."
    },
    {
        "id": 200,
        "Question": "The methodology to show an error when the analyzer faces a keyword over an user’s input is based on:",
        "Options": [
            "a) rule priority",
            "b) longest match rule",
            "c) keyword-out rule",
            "d) none of mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The lexical analyzer follows the rule priority where its prioritizes keywords over an input it gets with the same name as that of the keyword and thus generates an error."
    },
    {
        "id": 201,
        "Options": [
            "4. State true or false:",
            "Statement:  A lexical analyzer reads the source code line by line.",
            "a) True",
            "b) False"
        ],
        "Answer": "Answer: b\nExplanation: A lexical analyzer reads the source code letter by letter and when it encounters a space or an operator or any special character, it decides that the word is completed."
    },
    {
        "id": 202,
        "Question": "The output of the lexical and syntax analyzer can stated as:",
        "Options": [
            "a) parse stream, parse tree",
            "b) token tree, parse tree",
            "c) token stream, parse tree",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The Longest Match rule states that the lexeme scanned should be determined on the basis of longest match among all the token available."
    },
    {
        "id": 203,
        "Question": "Which among the following is not a tool to construct lexical analyzer from a regular expression?",
        "Options": [
            "a) lex",
            "b) flex",
            "c) jflex",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The lexical analyzer outputs the stream of token which is taken up by syntax analyzer one by one against the production rule and parse tree is generated."
    },
    {
        "id": 204,
        "Question": "A program that performs lexical analysis is termed as:",
        "Options": [
            "a) scanner",
            "b) lexer",
            "c) tokenizer",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Lexical analysis is done using few tools such as lex, flex and jflex. Jflex is a computer program that generates lexical analyzers (also known as lexers or scanners) and works apparently like lex and flex. Lex is commonly used with yacc parser generator."
    },
    {
        "id": 205,
        "Question": "Lexers and parsers are not found in which of the following?",
        "Options": [
            "a) compiler front end processing",
            "b) prettyprinters",
            "c) linters",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: A program which performs lexical analysis is called lexer, scanner or lexer. Nowadays, lexer is combined with a parser which allows syntactic analysis."
    },
    {
        "id": 206,
        "Question": "Which phase of compiler includes Lexical Analysis?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) Its primary function, not in any phase"
        ],
        "Answer": "Answer: d\nExplanation: Lexers and parsers are most commonly used in compilers, but it has more application elsewhere like in prettyprinters or linters(application of stylistic formatting conventions to textfiles, source code, etc.)."
    },
    {
        "id": 207,
        "Question": "Which of the following characters are ignored while lexical analysis?",
        "Options": [
            "a) .",
            "b) =",
            "c) #",
            "d) WhiteSpace"
        ],
        "Answer": "Answer: a\nExplanation: The first phase of compilation process is called lexical analysis. It fragments the source code into token which is the smallest programming unit of a program."
    },
    {
        "id": 208,
        "Question": "____________ is used for grouping up of characters into token.",
        "Options": [
            "a) Lexical Analyzer",
            "b) oolex",
            "c) jflex",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The lexical analyzer ignores all the whitespaces and fragments the program into tokens."
    },
    {
        "id": 209,
        "Question": "The action of parsing the source code into proper syntactic classes is known as:",
        "Options": [
            "a) Parsing",
            "b) Interpretation analysis",
            "c) Lexicography",
            "d) Lexical Analysis"
        ],
        "Answer": "Answer: d\nExplanation: oolex, flex, lex, jflex, all are lexical analyzer tools which perform the following function."
    },
    {
        "id": 210,
        "Question": "Which of the following is the task of lexical analysis?",
        "Options": [
            "a) To build the uniform symbol table",
            "b) To initialize the variables",
            "c) To organize the variables in a lexical order",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Lexical analysis or scanning is the process of parsing the source code into proper syntactic classes. It gets things ready for the parser with lexemes to built the parse tree."
    },
    {
        "id": 211,
        "Question": "The scanner outputs:",
        "Options": [
            "a) Stream of tokens",
            "b) Image file",
            "c) Intermediate code",
            "d) Machine code"
        ],
        "Answer": "Answer: a\nExplanation: Lexical analysis involves the following task:\na) Building a uniform symbol table\nb) Parsing the source code into tokens\nc) Building a literal and identifier table"
    },
    {
        "id": 212,
        "Question": "The phase of compilation which involves type checking is:",
        "Options": [
            "a) Parsing",
            "b) Scanning",
            "c) Syntax directed translation",
            "d) Semantic Analyzer"
        ],
        "Answer": "Answer: a\nExplanation: A scanner or a lexical analyzer takes a source code as input and outputs a stream of token after fragmenting the code."
    },
    {
        "id": 213,
        "Question": "Which among the following can be an annihilator for multiplication operation?",
        "Options": [
            "a) 0",
            "b) 1",
            "c) 100",
            "d) 22/7"
        ],
        "Answer": "Answer: b\nExplanation: 0101 or 1010 the strings with minimum length on {0,1}* which does not belong to the language of the given regular expression.Other strings like 111, 000, 1101, etc are accepted by the language ."
    },
    {
        "id": 214,
        "Options": [
            "7. Statement: A digit, when used in the CFG notation, will always be used as a terminal.",
            "State true or false?",
            "a) True",
            "b) False"
        ],
        "Answer": "Answer: a\nExplanation: What we observe from the question is that, it includes e and 11 and any number of 1’s then. Therefore, its simplifies when we write the same reg. Expression as (11+111)*."
    },
    {
        "id": 215,
        "Question": "Choose the incorrect process to check whether the string belongs to the language of certain variable or not?",
        "Options": [
            "a) recursive inference",
            "b) derivations",
            "c) head to body method",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: It is not required to automate the question if asked theoretically.The number of zeroes fixed is 2. Therefore, we can represent the regular expression as 1*01*01*."
    },
    {
        "id": 216,
        "Question": "Which of the technique can be used to prove that a language is non regular?",
        "Options": [
            "a) Ardens theorem",
            "b) Pumping Lemma",
            "c) Ogden’s Lemma",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The class of languages known as the regular language has atleast four different descriptions: i) DFA ii) NFA iii) e-NFA iv) Regular Expressions"
    },
    {
        "id": 217,
        "Question": "Which of the following language regular?",
        "Options": [
            "a) {aibi|i>=0}",
            "b) {aibi|0<i<5}",
            "c) {aibi|i>=1}",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: We use the powerful technique called Pumping Lemma, for showing certain languages not to be regular. We use Ardens theorem to find out a regular expression out of a finite automaton."
    },
    {
        "id": 218,
        "Question": "Which of the following are non regular?",
        "Options": [
            "a) The set of strings in {a,b}* with an even number of b’s",
            "b) The set of strings in {a, b, c}* where there is no c anywhere to the left of a",
            "c) The set of strings in {0, 1}* that encode, in binary, an integer w that is a multiple of 3. Interpret the empty strings e as the number 0",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Here, i has limits i.e. the language is finite, contains few elements and can be graphed using a deterministic finite automata. Thus, it is regular. Others can be proved non regular using Pumping lemma."
    },
    {
        "id": 219,
        "Question": "If L is DFA-regular, L’ is",
        "Options": [
            "a) Non regular",
            "b) DFA-regular",
            "c) Non-finite",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All of the given languages are regular and finite and thus, can be represented using respective deterministic finite automata. We can also use mealy or moore machine to represent remainders for option c."
    },
    {
        "id": 220,
        "Question": "Which of the following options is incorrect?",
        "Options": [
            "a) A language L is regular if and only if ~L has finite number of equivalent classes",
            "b) Let L be a regular language. If ~L has k equivalent classes, then any DFA that recognizes L must have atmost k states",
            "c) A language L is NFA-regular if and only if it is DFA-regular",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: This is a simple example of a closure property: a property saying that the set of DFA-regular languages is closed under certain operations."
    },
    {
        "id": 221,
        "Question": "Myphill Nerode  does the following:",
        "Options": [
            "a) Minimization of DFA",
            "b) Tells us exactly when a language is regular",
            "c) Minimization of DFA and tells us exactly when a language is regular",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Let L be a regular language. If ~L has k equivalent classes, then any DFA that recognizes L must have atleast k states. "
    },
    {
        "id": 222,
        "Question": "Which of the following are related to tree automaton?",
        "Options": [
            "a) Myphill Nerode Theorem",
            "b) State machine",
            "c) Courcelle’s Theorem",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: In automata theory, the Myphill Nerode theorem provides a necessary and sufficient condition for a language to be regular. The Myphill Nerode theorem can be used to show a language L is regular by proving that the number of equivalence classes of RL(relation) is finite."
    },
    {
        "id": 223,
        "Question": "Finite state machine are not able to recognize Palindromes because:",
        "Options": [
            "a) Finite automata cannot deterministically find the midpoint",
            "b) Finite automata cannot remember arbitarily large amount of data",
            "c) Even if the mid point is known, it cannot find whether the second half matches the first",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The myphill nerode theorem can be generalized to trees and an application of tree automata prove an algorithmic meta theorem about graphs."
    },
    {
        "id": 224,
        "Question": "While applying Pumping lemma over a language, we consider a string w that belong to L and fragment it into _________ parts.",
        "Options": [
            "a) 2",
            "b) 5",
            "c) 3",
            "d) 6"
        ],
        "Answer": "Answer: b\nExplanation: Pumping lemma defines an essential property for every regular language in automata theory. It has certain rules which decide whether a language is regular or not."
    },
    {
        "id": 225,
        "Question": "If we select a string w such that w∈L, and w=xyz. Which of the following portions cannot be an empty string?",
        "Options": [
            "a) x",
            "b) y",
            "c) z",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: We select a string w such that w=xyz and |y|>0 and other conditions. However, there exists an integer n such that |w|>=n for any wÎL."
    },
    {
        "id": 226,
        "Question": "Let w= xyz and y refers to the middle portion and |y|>0.What do we call the process of repeating y 0 or more times before checking that they still belong to the language L or not?",
        "Options": [
            "a) Generating",
            "b) Pumping",
            "c) Producing",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The lemma says, the portion y in xyz cannot be zero or empty i.e. |y|>0, this condition needs to be fulfilled to check the conclusion condition."
    },
    {
        "id": 227,
        "Question": "There exists a language L. We define a string w such that w∈L and w=xyz and |w| >=n for some constant integer n.What can be the maximum length of the substring xy i.e. |xy|<=?",
        "Options": [
            "a) n",
            "b) |y|",
            "c) |x|",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The process of repeatation is called pumping and so, pumping is the process we perform before we check whether the pumped string belongs to L or not."
    },
    {
        "id": 228,
        "Question": "Let w be a string and fragmented by three variable x, y, and z as per pumping lemma. What does these variables represent?",
        "Options": [
            "a) string count",
            "b) string",
            "c) string count and string",
            "d) none of  the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: It is the first conditional statement of the lemma that states that |xy|<=n, i.e. the maximum length of the substring xy in w can be n only."
    },
    {
        "id": 229,
        "Question": "Which kind of proof is used to prove the regularity of a language?",
        "Options": [
            "a) Proof by contradiction",
            "b) Direct proof",
            "c) Proof by induction",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: We use the method of proof by contradiction in pumping lemma to prove that a language is regular or not."
    },
    {
        "id": 230,
        "Question": "The language of balanced paranthesis is",
        "Options": [
            "a) regular",
            "b) non regular",
            "c) may be regular",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Given n, there is a string of balanced parentheses that begins with more than p left parentheses, so that y will contain entirely of left parentheses. By repeating y, we can produce a string that does not contain the same number of left and right parentheses, and so they cannot be balanced."
    },
    {
        "id": 231,
        "Options": [
            "3. State true or false:",
            "Statement: Pumping lemma gives a necessary but not sufficient condition for a language to be regular.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: The converse of the lemma is not true. There may exists some language which satisfy all the conditions of the lemma and still be non-regular."
    },
    {
        "id": 232,
        "Question": "Which of the following is/are an example of pigeon hole principle?",
        "Options": [
            "a) Softball team",
            "b) Sock picking",
            "c) Hair counting",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: There are several applications of pigeonhole principle:\nExample: The softball team: Suppose 7 people who want to play softball(n=7 items), with a limitation of only 4 softball teams to choose from. The pigeonhole principle tells us that they cannot all play for different teams; there must be atleast one team featuring atleast two of the seven players."
    },
    {
        "id": 233,
        "Question": "Pigeonhole principle can be applied in the following computer science algorithms:",
        "Options": [
            "a) hashing algorithm",
            "b) lossless compression algorithm",
            "c) hashing algorithm and lossless compression algorithm",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Collisions are inevitable in a hash table because the number of possible keys exceeds the number of indices in the array."
    },
    {
        "id": 234,
        "Question": "If n objects are distributed over m places, and n < m, then some of the places receive:",
        "Options": [
            "a) at least 2 objects",
            "b) at most 2 objects",
            "c) no object",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: This is one of the alternative formulations of the pigeon hole principle. As n < m, there will exist some place which will not receive any of the object."
    },
    {
        "id": 235,
        "Question": "Which of the following fields may have pigeonhole principle violated?",
        "Options": [
            "a) Discrete mathematics",
            "b) Computer Science",
            "c) Quantum Mechanics",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Y Aharonov proved mathematically the violation of pigeon hole principle in Quantum mechanics and proposed inferometric experiments to test it."
    },
    {
        "id": 236,
        "Question": "Which of the following is not an application of Pumping Lemma?",
        "Options": [
            "a) {0i1i|i>=0}",
            "b) {0ix|i>=0, x∈{0, 1}* and |x|<=i}",
            "c) {0n| n is prime}",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: None of the mentioned are regular language and are an application to the technique Pumping Lemma. Each one of the mentioned can be proved non regular using the steps in Pumping lemma."
    },
    {
        "id": 237,
        "Question": "Which of the following can refer a language to be non regular?",
        "Options": [
            "a) Pumping Lemma",
            "b) Myphill Nerode",
            "c) Pumping Lemma and Myphill Nerode",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: On the contrary, the typical way to prove that a language is to construct either a finite state machine or a regular expression for the language."
    },
    {
        "id": 238,
        "Question": "Which of the following is not an example of counting argument?",
        "Options": [
            "a) Pigeonhole principle",
            "b) Dirichlet’s drawer principle",
            "c) Dirichlet’s box principle",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Pigeon hole principle or Dirichlet’s drawer principle or Dirichlet’s box principle is an example of counting argument whose field is called Combinatorics."
    },
    {
        "id": 239,
        "Question": "If L1, L2 are regular and op(L1, L2) is also regular, then L1 and L2 are said to be ____________ under an operation op.",
        "Options": [
            "a) open",
            "b) closed",
            "c) decidable",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: If two regular languages are closed under an operation op, then the resultant of the languages over an operation op will also be regular."
    },
    {
        "id": 240,
        "Question": "Suppose a regular language L is closed under the operation halving, then the result would be:",
        "Options": [
            "a) 1/4 L will be regular",
            "b) 1/2 L will be regular",
            "c) 1/8 L will be regular",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: At first stage 1/2 L will be regular and subsequently, all the options will be regular."
    },
    {
        "id": 241,
        "Question": "If L1′ and L2′ are regular languages, then L1.L2 will be",
        "Options": [
            "a) regular",
            "b) non regular",
            "c) may be regular",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Regular language is closed under complement operation. Thus, if L1′ and L2′ are regular so are L1 and L2. And if L1 and L2 are regular so is L1.L2."
    },
    {
        "id": 242,
        "Question": "If L1 and L2′ are regular languages, L1 ∩ (L2′ U L1′)’ will be",
        "Options": [
            "a) regular",
            "b) non regular",
            "c) may be regular",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: If L1 is regular, so is L1′ and if L1′ and L2′ are regular so is L1′ U L2′. Further, regular  languages are also closed under intersection operation."
    },
    {
        "id": 243,
        "Question": "If A and B are regular languages, !(A’ U B’) is:",
        "Options": [
            "a) regular",
            "b) non regular",
            "c) may be regular",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: If A and B are regular languages, then A Ç B is a regular language and  A ∩ B is equivalent to  !(A’ U B’)."
    },
    {
        "id": 244,
        "Question": "Which among the following are the boolean operations that under which regular languages are closed?",
        "Options": [
            "a) Union",
            "b) Intersection",
            "c) Complement",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Regular languages are closed under the following operations:\na) Regular expression operations\nb) Boolean operations\nc) Homomorphism\nd) Inverse Homomorphism"
    },
    {
        "id": 245,
        "Question": "Suppose a language L1 has 2 states and L2 has 2 states. After using the cross product construction method,\twe have a machine M that accepts L1 ∩ L2. The total number of states in M:",
        "Options": [
            "a) 6",
            "b) 4",
            "c) 2",
            "d) 8"
        ],
        "Answer": "Answer: b\nExplanation: M is defined as: (Q, S, d, q0, F)\nwhere Q=Q1*Q2 and F=F1*F2."
    },
    {
        "id": 246,
        "Question": "If L is a regular language, then (L’)’ U L will be :",
        "Options": [
            "a) L",
            "b) L’",
            "c) f",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: (L’)’ is equivalent to L and L U L is subsequently equivalent to L."
    },
    {
        "id": 247,
        "Question": "If L is a regular language, then (((L’)r)’)* is:",
        "Options": [
            "a) regular",
            "b) non regular",
            "c) may be regular",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: If L is regular so is its complement, if L’ is regular so is its reverse, if (L’)r is regular so is its Kleene."
    },
    {
        "id": 248,
        "Question": "Which among the following is the closure property of a regular language?",
        "Options": [
            "a) Emptiness",
            "b) Universality",
            "c) Membership",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All the following mentioned are decidability properties of a regular language. The closure properties of a regular language include union, concatenation, intersection, Kleene, complement , reverse and many more operations.\n"
    },
    {
        "id": 249,
        "Question": "If L is a language, the reversal of the language can be represented as:",
        "Options": [
            "a) L’",
            "b) Lc",
            "c) Lr",
            "d) more than one option is correct"
        ],
        "Answer": "Answer: c\nExplanation: Lr is defined as the reversal of a language. Lr  is a set of strings whose reversal is in L.\nExample: L={0, 01, 100}\nLr={0, 10, 001}\n"
    },
    {
        "id": 250,
        "Question": "If L is a regular language, ____ is also regular.",
        "Options": [
            "a) Lr",
            "b) L’",
            "c) L*",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Lr, L’, L* i.e. reversal, complementation and kleene all are the closure properties of regular language.\n"
    },
    {
        "id": 251,
        "Question": "If E= FG, Er=?",
        "Options": [
            "a) FrGr",
            "b) GrFr",
            "c) FrGr and GrFr",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: If E is a symbol a, e, or f, then Er=E. Other inductive properties include union of reversals, concatenation and Kleene.\n"
    },
    {
        "id": 252,
        "Question": "Which of the following obey the closure properties of Regular language?",
        "Options": [
            "a) Homomorphism",
            "b) Inverse Homomorphism",
            "c) Reversal",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: If E= FG, Er=GrFr . Example: (01*)R=(1*)R(0)R\n"
    },
    {
        "id": 253,
        "Question": "Let h(L) be a language of regular expression abe*+e(ab)*. Simplify the h(L)",
        "Options": [
            "a) (ab)*+eab*",
            "b) abe*+ea*b*",
            "c) (ab)*",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: 01*+10*\nER=(01*)R+(10*)R=>(1*)R0R+(0*)R1R=>1*0+0*1\n"
    },
    {
        "id": 254,
        "Question": "While proving Inverse Homomorphism, which of the following steps are needed?",
        "Options": [
            "a) Start with a DFA Ain L",
            "b) Construct a DFA B for h-1(L)",
            "c) The set of states, initial and final states should be same.",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Homomorphism on an aphabet is a function that gives a string for each symbol in that alphabet. Example: h(0)=ab, etc.\n"
    },
    {
        "id": 255,
        "Question": "Which of the following conversion is not feasible?",
        "Options": [
            "a) Regular expression to automaton conversion",
            "b) Automaton to Regular Expression Conversion",
            "c) NFA to DFA",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Each of the four formats of representation of the regular language be it, DFA, NFA, Regular Expression or e-NFA can be converted to the rest three forms."
    },
    {
        "id": 256,
        "Question": "The computation of e-closure of n-states takes ______ time.",
        "Options": [
            "a) O(n2)",
            "b) O(n3)",
            "c) O(2n)",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: We must search from each of the n states along all arcs labelled e. If there are n states, there can be no more than n2 states."
    },
    {
        "id": 257,
        "Question": "For a _________ state DFA, the time taken for DFA-NFA conversion is O(n).",
        "Options": [
            "a) n",
            "b) n1/2",
            "c) n2",
            "d) 2n"
        ],
        "Answer": "Answer: a\nExplanation: The conversion DFA to NFA is simple, and takes O(n) time on an n-state DFA."
    },
    {
        "id": 258,
        "Question": "With reference to Automaton to Regular Expression Conversion, for each of the n rounds, where n is the number of states of DFA, we can _________ the size of the regular expression constructed.",
        "Options": [
            "a) double",
            "b) triple",
            "c) quadruple",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: We can quadruple the size of the regular expression per round. Thus, we can simply write n3 expressions can take time O(n34n), where n =number of states of the DFA."
    },
    {
        "id": 259,
        "Question": "Conversion of regular expression to e-NFA takes ___________ time.",
        "Options": [
            "a) linear",
            "b) exponential",
            "c) logarithmic",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: It is possible to parse the expression efficiently, using a technique that takes only O(n) time on a expression of length n3."
    },
    {
        "id": 260,
        "Question": "The conversion of NFA to DFA can be done in:",
        "Options": [
            "a) exponential time",
            "b) linear time",
            "c) logarithmic time",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: We can eliminate e-transitions from an n state epsilon-NFA to build an ordinary NFA in O(n3) time, without changing the number of states.Next, producing to DFA can take exponential time."
    },
    {
        "id": 261,
        "Question": "Which of the following cannot be converted in an ordinary NFA?",
        "Options": [
            "a) DFA",
            "b) Regular Expression",
            "c) e-NFA",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Each of the following can expressed in terms of ordinary NFA with different time complexities."
    },
    {
        "id": 262,
        "Question": "NFA to DFA conversion is done via",
        "Options": [
            "a) Subset Construction method",
            "b) Warshalls Algorithm",
            "c) Ardens theorem",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Powerset or subset construction method is a standard method for converting a non deterministic finite automata into DFA which recognizes the same formal language."
    },
    {
        "id": 263,
        "Options": [
            "9. State true or false:",
            "Statement: Regular expression can directly be converted to DFA without intermediate steps.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: There exists subsequent steps like formation of epsilon-NFA and NFA before the formation of corresponding DFA."
    },
    {
        "id": 264,
        "Question": "",
        "Options": [
            "10. Is the following statement correct?",
            "Statement: Thompson construction is used to convert Regular expression to finite automata.",
            "a) Yes",
            "b) No"
        ],
        "Answer": "Answer: a\nExplanation: Thompson’s Construction is used to find out a Finite Automaton from a Regular Expression. We will reduce the regular expression into smallest regular expressions and convert them to NFA and finally to DFA. "
    },
    {
        "id": 265,
        "Question": "Language classes have the following property:",
        "Options": [
            "a) Closure property",
            "b) Decision property",
            "c) Closure & Decision property",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: A decision property of a language class is an algorithm that takes a formal description of a language(e.g., a DFA) and tells whether or not some property holds."
    },
    {
        "id": 266,
        "Question": "Which of the following are decision properties?",
        "Options": [
            "a) Emptiness",
            "b) Infiniteness",
            "c) Membership",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Emptiness, Infiniteness and Membership are the decision properties of any language class. Example: Is the language L empty? Or Is w, a string belongs to the regular language L?"
    },
    {
        "id": 267,
        "Question": "Pick the odd one out of the given properties of a regular language:",
        "Options": [
            "a) Kleene",
            "b) Reversal",
            "c) Homomorphism",
            "d) Membership"
        ],
        "Answer": "Answer: d\nExplanation: Membership is a decision property of language class while others mentioned like Kleene, Reversal and Homomorphism are Closure properties of language class."
    },
    {
        "id": 268,
        "Question": "Which of the following are not meant to specify a regular language?",
        "Options": [
            "a) Regular Expression",
            "b) DFA",
            "c) NDFA and epsilon-NFA",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: For a given automata, all the formats of representation be it deterministic finite automata or non deterministic finite automata or non deterministic finite automata with epsilon transitions, all are equivalent variants."
    },
    {
        "id": 269,
        "Question": "Which of the following problems do not belong to decision properties?",
        "Options": [
            "a) Given two languages, are there strings that are in both",
            "b) Is the language a subset of another regular language",
            "c) Is the language same as another regular language",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: It is possible to convert from one specification to another. We can express a regular language in all the given four variants."
    },
    {
        "id": 270,
        "Question": "Which of the following is a function of Closure properties?",
        "Options": [
            "a) Helps construct representations",
            "b) Helps show informally described languages not to be in class",
            "c) Helps construct representations and shows informally described languages not to be in class",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: To give a solution to the mentioned problems, we require decision properties and for some, we need additional tools like minimized automaton and Pumping lemma."
    },
    {
        "id": 271,
        "Question": "Suppose there is a string w=abbab, and there exists a DFA which accepts w. How many stepts will be required to test its membership?",
        "Options": [
            "a) 2",
            "b) 1",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: c\nExplanation: Using closure properties we can give a solution to many problems like :\nIs the regular languages L1 and L2 closed on concatenation operation, etc."
    },
    {
        "id": 272,
        "Question": "If a DFA has n states and the language contains any string of length n or more, the language is termed as:",
        "Options": [
            "a) Infinite",
            "b) Empty",
            "c) Non regular",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: If a string belongs to a language, the number of steps required to test that membership is equal to the length of string i.e. 5."
    },
    {
        "id": 273,
        "Options": [
            "10. State true or false:",
            "Statement: If an n-state DFA accepts a string w of length n or more, then there must be a state that appears twice on the path labeled w from the start state to the final state.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: The language is surely finite if it is limited to string of length n or less. This is because there are atleast n+1 states along the path while traversing w(string)."
    },
    {
        "id": 274,
        "Question": "The entity which generate Language is termed as:",
        "Options": [
            "a) Automata",
            "b) Tokens",
            "c) Grammar",
            "d) Data"
        ],
        "Answer": "Answer: c\nExplanation: The entity which accepts a language is termed as Automata while the one which generates it is called Grammar. Tokens are the smallest individual unit of a program."
    },
    {
        "id": 275,
        "Question": " Production Rule: aAb->agb belongs to which of the following category?",
        "Options": [
            "a)  Regular Language",
            "b) Context free Language",
            "c) Context Sensitive Language",
            "d) Recursively Ennumerable Language"
        ],
        "Answer": "Answer: c\nExplanation: Context Sensitive Language or Type 1 or Linearly Bounded Non deterministic Language has the production rule where the production is context dependent i.e.  aAb->agb."
    },
    {
        "id": 276,
        "Question": "Which of the following statement is false?",
        "Options": [
            "a) Context free language is the subset of context sensitive language",
            "b) Regular language is the subset of context sensitive language",
            "c) Recursively ennumerable language is the super set of regular language",
            "d) Context sensitive language is a subset of context free language"
        ],
        "Answer": "Answer: d\nExplanation: Every regular language can be produced by context free grammar and context free language can be produced by context sensitive grammar and so on.\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-context-free-grammar-derivations-definitions-q3.png\" alt=\"Find the context sensitive language from the given diagram\" width=\"223\" height=\"123\" class=\"alignnone size-full wp-image-160610\" />\n"
    },
    {
        "id": 277,
        "Question": "Which among the following cannot be accepted by  a regular grammar?",
        "Options": [
            "a) L is a set of numbers divisible by 2",
            "b) L is a set of binary complement",
            "c) L is a set of string with odd number of 0",
            "d) L is a set of 0n1n"
        ],
        "Answer": "Answer: b\nExplanation: G=(V, ∑, p, S), here V=Finite set of variables,  ∑= set of terminals, p= finite productions, S= Starting Variable."
    },
    {
        "id": 278,
        "Question": "For S->0S1|e for ∑={0,1}*, which of the following is wrong for the language produced?",
        "Options": [
            "a) Non regular language",
            "b) 0n1n | n>=0",
            "c) 0n1n | n>=1",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: There exists no finite automata to accept the given language i.e. 0n1n. For other options, it is possible to make a dfa or nfa representing the language set."
    },
    {
        "id": 279,
        "Question": "The minimum number of productions required to produce a language consisting of palindrome strings over   ∑={a,b} is",
        "Options": [
            "a) 3",
            "b) 7",
            "c) 5",
            "d) 6"
        ],
        "Answer": "Answer: c\nExplanation: According to the definition, the starting variable can produce another variable or any terminal or a variable which leads to terminal."
    },
    {
        "id": 280,
        "Question": "Which of the following statement is correct?",
        "Options": [
            "a) All Regular grammar are context free but not vice versa",
            "b) All context free grammar are regular grammar but not vice versa",
            "c) Regular grammar and context free grammar are the same entity",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: L={e, 01, 0011, 000111, ……0n1n }. As epsilon is a part of the set, thus all the options are correct implying none of them to be wrong."
    },
    {
        "id": 281,
        "Question": "Which of the following is not a notion of Context free grammars?",
        "Options": [
            "a) Recursive Inference",
            "b) Derivations",
            "c) Sentential forms",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The following are the notions to express Context free grammars:\na) Recursive Inferences\nb) Derivations\nc) Sentential form\nd) Parse trees\n"
    },
    {
        "id": 282,
        "Options": [
            "2. State true or false:",
            "Statement: The recursive inference procedure determines that string w is in the language of the variable A, A being the starting variable.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: We apply the productions of CFG to infer that certain strings are in the language of a certain variable."
    },
    {
        "id": 283,
        "Question": "Which of the following is/are the suitable approaches for inferencing?",
        "Options": [
            "a) Recursive Inference",
            "b) Derivations",
            "c) Recursive Inference and Derivations",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Two inference approaches:\n1. Recursive inference, using productions from body to head\n2. Derivations, using productions from head to body\n"
    },
    {
        "id": 284,
        "Question": "If w belongs to L(G), for some CFG, then w has a parse tree, which defines the syntactic structure of w. w could be:",
        "Options": [
            "a) program",
            "b) SQL-query",
            "c) XML document",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Parse trees are an alternative representation to derivations and recursive inferences. There can be several parse trees for the same string."
    },
    {
        "id": 285,
        "Question": "",
        "Options": [
            "5. Is the following statement correct?",
            "Statement: Recursive inference and derivation are equivalent.",
            "a) Yes",
            "b) No"
        ],
        "Answer": "Answer: a\nExplanation: Yes, they are equivalent. Both the terminologies represent the two approaches of recursive inferencing."
    },
    {
        "id": 286,
        "Question": "The language accepted by Push down Automaton:",
        "Options": [
            "a) Recursive Language",
            "b) Context free language",
            "c) Linearly Bounded language",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A->aA=>aaA=>aab"
    },
    {
        "id": 287,
        "Question": "Which of the following statements are correct for a concept called inherent ambiguity in CFL?",
        "Options": [
            "a) Every CFG for L is ambiguous",
            "b) Every CFG for L is unambiguous",
            "c) Every CFG is also regular",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: For the given expression, L(G)={w in T*|S→*w}, If G(V, T, P, S) is a CFG, the language of G, denoted by L(G), is the set of terminal strings that have derivations from the start symbol."
    },
    {
        "id": 288,
        "Question": "Which of the theorem defines the existence of Parikhs theorem?",
        "Options": [
            "a) Parikh’s theorem",
            "b) Jacobi theorem",
            "c) AF+BG theorem",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Push down automata accepts context free language."
    },
    {
        "id": 289,
        "Options": [
            "1. State true or false:",
            "Statement: Every right-linear grammar generates a regular language.",
            "a) True",
            "b) False"
        ],
        "Answer": "Answer: a\nExplanation: A CFG is said to right linear if each production body has at most one variable, and that variable is at the right end. That is, all productions of a right linear grammar are of the form A->wB or A->w, where A and B are variables while w is some terminal."
    },
    {
        "id": 290,
        "Question": "If L1 and L2 are context free languages, which of the following is context free?",
        "Options": [
            "a) L1*",
            "b) L2UL1",
            "c) L1.L2",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Using the derivation approach, we can conclude that the given grammar produces a language with a set of string which have equal number of a’s and b’s."
    },
    {
        "id": 291,
        "Question": "Which of the following languages are most suitable for implement context free languages ?",
        "Options": [
            "a) C",
            "b) Perl",
            "c) Assembly Language",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The following is a theorem which states the closure property of context free languages which includes Kleene operation, Union operation and Dot operation."
    },
    {
        "id": 292,
        "Question": "The most suitable data structure used to represent the derivations in compiler:",
        "Options": [
            "a) Queue",
            "b) Linked List",
            "c) Tree",
            "d) Hash Tables"
        ],
        "Answer": "Answer: c\nExplanation: The tree, known as “Parse tree” when used in a compiler, is the data structure of choice to represent the source program."
    },
    {
        "id": 293,
        "Question": "Which of the following statement is false in context of tree terminology?",
        "Options": [
            "a) Root with no children is called a leaf",
            "b) A node can have three children",
            "c) Root has no parent",
            "d) Trees are collection of nodes, with a parent child relationship"
        ],
        "Answer": "Answer: a\nExplanation: A node has atmost one parent, drawn above the node, and zero or more children drawn below. Lines connect parents to children. There is one node, one root, that has no parent; this node appears to be at the top of the tree. Nodes with no children are called leaves. Nodes that are not leaves are called interior nodes."
    },
    {
        "id": 294,
        "Question": "In which order are the children of any node ordered?",
        "Options": [
            "a) From the left",
            "b) From the right",
            "c) Arbitrarily",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The children of a node are ordered from the left and drawn so. If N is to the left of node M, then all the descendents of N are considered  to be to the left of all the descendents of M."
    },
    {
        "id": 295,
        "Question": "Which among the following is the root of the parse tree?",
        "Options": [
            "a) Production P",
            "b) Terminal T",
            "c) Variable V",
            "d) Starting Variable S"
        ],
        "Answer": "Answer: d\nExplanation: The root is labelled by the start symbol. All the leaves are either labelled by a a terminal or with e."
    },
    {
        "id": 296,
        "Question": " For the expression E*(E) where * and brackets are the operation, number of nodes in the respective parse tree are:",
        "Options": [
            "a) 6",
            "b) 7",
            "c) 5",
            "d) 2"
        ],
        "Answer": "Answer: b\nExplanation:<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-construction-yield-parse-tree-q5.png\" alt=\"Find the number of nodes in parse tree from the given diagram\" width=\"220\" height=\"152\" class=\"alignnone size-full wp-image-160618\" />\n"
    },
    {
        "id": 297,
        "Question": "The number of leaves in a parse tree with expression E*(E) where * and () are operators",
        "Options": [
            "a) 5",
            "b) 2",
            "c) 4",
            "d) 3"
        ],
        "Answer": "Answer: a\nExplanation: <img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-construction-yield-parse-tree-q5.png\" alt=\"Find the number of nodes in parse tree from the given diagram\" width=\"220\" height=\"152\" class=\"alignnone size-full wp-image-160618\" />\n"
    },
    {
        "id": 298,
        "Question": "A grammar with more than one parse tree is called:",
        "Options": [
            "a) Unambiguous",
            "b) Ambiguous",
            "c) Regular",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The following is a parse tree for the production 0110 over {0,1}*."
    },
    {
        "id": 299,
        "Question": "__________ is the acyclic graphical representation of a grammar.",
        "Options": [
            "a) Binary tree",
            "b) Oct tree",
            "c) Parse tree",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A context free grammar G is ambiguous if there is at least one string in L(G) having two or more distinct derivation trees or equivalently, two or more distinct leftmost derivations."
    },
    {
        "id": 300,
        "Question": "Grammar is checked by which component of compiler?",
        "Options": [
            "a) Scanner",
            "b) Parser",
            "c) Semantic Analyzer",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: In order to graphically represent a derivation of a grammar we need to use parse trees."
    },
    {
        "id": 301,
        "Question": "A symbol X is ________ if there exists : S->* aXb",
        "Options": [
            "a) reachable",
            "b) generating",
            "c) context free",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A symbol X is generating if there exists : X->*w for some w that belongs to T*.\nAlso, a symbol can never be context free."
    },
    {
        "id": 302,
        "Question": "A symbol X is called to be useful if and only if its is:",
        "Options": [
            "a) generating",
            "b) reachable",
            "c) both generating and reachable",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: For a symbol X to be useful, it has to be both reachable and generating i.e.\nS->* aXb -> * w where w belongs to T*.\n"
    },
    {
        "id": 303,
        "Question": "Which of the following is false for a grammar G in Chomsky Normal Form:",
        "Options": [
            "a) G has no useless symbols",
            "b) G has no unit productions",
            "c) G has no epsilon productions",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: G, a CFG is said to be in Chomsky normal form if all its productions are in one of the following form:\nA->BC or A->a\n"
    },
    {
        "id": 304,
        "Options": [
            "5. State true or false:",
            "Statement: A CNF parse tree’s string yield (w) can no longer be 2h-1.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: The grammar is not in CNF if it violates the normal form of the productions which is strictly restricted."
    },
    {
        "id": 305,
        "Question": "If |w|>=2h, then its parse tree’s height is at least _____",
        "Options": [
            "a) h",
            "b) h+1",
            "c) h-1",
            "d) 2h"
        ],
        "Answer": "Answer: a\nExplanation: It is the parse tree theorem which states:\nGiven: Suppose we have a parse tree for a string w, according to a CNF grammar, G=(V, T, P, S). Let h be the height of the parse tree. Now, Implication: |w|<=2h-1."
    },
    {
        "id": 306,
        "Question": "If w belongs to L(G), for some CFG, then w has a parse tree, which tell us the ________ structure of w.",
        "Options": [
            "a) semantic",
            "b) syntactic",
            "c) lexical",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: It is the basic implication of Parse tree theorem (assuming CNF). If the height of the parse tree is h, then |w| <=2h-1."
    },
    {
        "id": 307,
        "Question": "Which of the following are distinct to parse trees?",
        "Options": [
            "a) abstract parse trees",
            "b) sentence diagrams",
            "c) both abstract parse trees and sentence diagrams",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A parse tree or concrete syntactic tree is an ordered, rooted tree that represents the syntactic structure of a string according to some context free grammar. "
    },
    {
        "id": 308,
        "Question": "",
        "Options": [
            "10. Is the given statement correct?",
            "Statement: The mere existence of several derivations is not an issue, its is the existence of several parse trees that ruins a grammar.",
            "a) Yes",
            "b) No"
        ],
        "Answer": "Answer: c\nExplanation: Both of the mentioned are different from parse trees. Sentence diagrams are pictorial representations of grammatical structure of a sentence."
    },
    {
        "id": 309,
        "Question": "To derive a string using the production rules of a given grammar, we use:",
        "Options": [
            "a) Scanning",
            "b) Parsing",
            "c) Derivation",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Parsing is required to check the acceptability of a string. Further, comes the syntactical phase which is taken care by other phases of compiler."
    },
    {
        "id": 310,
        "Question": "Which of the following parser reaches the root symbol of the tree at last?",
        "Options": [
            "a) Top down parser",
            "b) Bottom up parser",
            "c) TOP down and Bottom up parser",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Bottom up parser starts from the bottom with the string and comes up to the start symbolusing a parse tree or a derivation tree."
    },
    {
        "id": 311,
        "Question": "Left corner parsing methof uses which of the following?",
        "Options": [
            "a) Top down parser",
            "b) Bottom up parser",
            "c) TOP down and Bottom up parser",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: It is a hybrid method which works bottom up along the left edges of each subtree, and top down on the rest of the parse tree."
    },
    {
        "id": 312,
        "Question": "Which of the following parser performs top down parsing?",
        "Options": [
            "a) LALR parser",
            "b) LL parser",
            "c) Recursive Accent parser",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Bottom up parsing is done by shift reduce parsers like LALR parsers, Operator precedence parsers, simple precedence parsers, etc."
    },
    {
        "id": 313,
        "Question": "Which of the following is true for shift reduce parsers?",
        "Options": [
            "a) Scans and parses the input in one forward pass over the text, without any backup",
            "b) A shift command advances in the input stream by one symbol",
            "c) LALR parser",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The mentioned are the correct and proper functions of a shift reduce parsers. The parsing methods are most commonly used for parsing programming languages, etc."
    },
    {
        "id": 314,
        "Options": [
            "6. State true or false:",
            "Statement: LALR parsers uses tables rather than mutually recursive functions.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: It is exactly the opposite case where LALR parsers uses mutually recursive functions instead of tables. It is a simplified version of canonical left to right parser."
    },
    {
        "id": 315,
        "Question": "LALR in LALR parser stands for:",
        "Options": [
            "a) Left aligned left right parser",
            "b) Look ahead left to right parser",
            "c) Language Argument left to right parser",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: LALR stands for Look ahead left to right parsers. It has more language recognition power than LR(0) parser."
    },
    {
        "id": 316,
        "Question": "Which of the following can be a LALR parser generator?",
        "Options": [
            "a) YACC",
            "b) GNU Bison",
            "c) YACC and GNU Bison",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: YACC is a computer code for UNIX operating system which generates a LALR parser. On the other hand GNU Bison or Bison can generate LALR and GLR parsers."
    },
    {
        "id": 317,
        "Question": "Which of the following parsers do not relate to Bottom up parsing?",
        "Options": [
            "a) LL parser",
            "b) Recursive descent parser",
            "c) Earley parsers",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All the following mentioned are top down parsers and begin their operation from the starting symbol."
    },
    {
        "id": 318,
        "Question": "Which of the following is true for a predictive parser?",
        "Options": [
            "a) Recursive Descent parser",
            "b) no backtracking",
            "c) Recursive Descent parser and no backtracking",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Predictive parsing is possible only for the class of LL-grammars, which are the CFG for which there exists some positive integer k that allows a recursive descent parser to decide which production to use by examining only the next k tokens of input."
    },
    {
        "id": 319,
        "Question": "YACC is a computer program for ______ operation system.",
        "Options": [
            "a) Windows",
            "b) DOS",
            "c) Unix",
            "d) openSUSE"
        ],
        "Answer": "Answer: c\nExplanation: YACC technique is a computer code for the Unix operating system. It is a LALR parser generator, generating a parser, the part of a compiler that tries to make syntactic sense of the source code."
    },
    {
        "id": 320,
        "Question": "YACC is an acronym for:",
        "Options": [
            "a) Yes Another Compile Compiler",
            "b) Yet Another Compile Compiler",
            "c) Yet Another Compiler Compiler",
            "d) Yes Another Compiler Compiler"
        ],
        "Answer": "Answer: c\nExplanation: YACC stands for ‘Yet another compiler compiler’ and it was developed by Stephen Johnson in B programming language later translated to C."
    },
    {
        "id": 321,
        "Question": "The YACC takes C code as input and outputs_________",
        "Options": [
            "a) Top down parsers",
            "b) Bottom up parsers",
            "c) Machine code",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The YACC takes C code as input and produces shift reduce parsers in C,also known as Bottom up parsers which execute C snippets with the associated rule."
    },
    {
        "id": 322,
        "Question": "The _______ table is created by YACC.",
        "Options": [
            "a) LALR parsing",
            "b) LL parsing",
            "c) GLR parsing",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation:  LALR parser generator is software tool that reads a BNF grammar and creates a LALR parser which is capable of parsing files written in programming language identified by BNF grammar."
    },
    {
        "id": 323,
        "Question": "The original YACC as written in __________ language",
        "Options": [
            "a) R programming language",
            "b) C programming language",
            "c) B programming language",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Stephen Johnson wrote this parser generator in B programming language which was further modified and written in C, JAVA, Python, etc. "
    },
    {
        "id": 324,
        "Question": "Which of the following is false for B programming language?",
        "Options": [
            "a) Typeless",
            "b) Influenced by PL/I",
            "c) Designed by Dennis Ritchie",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: B was programming language designed by Dennis Ritchie and Ken Thompson for recursive, non numeric, system and language softwares. It was a typeless language, everything is a word."
    },
    {
        "id": 325,
        "Question": "Which of the following is false for BNF?",
        "Options": [
            "a) BNF means Backus Naur Form",
            "b) It is a normal form used in Data base normalization",
            "c) It is a notation technique for context free grammar",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The normal form used in Data base normalization is BCNF i.e. Boyce Codd normal form and NOT Backus Naur Form."
    },
    {
        "id": 326,
        "Options": [
            "8. State true or false:",
            "Statement: BNF is a metasyntax used to express CFG",
            "a) True",
            "b) False"
        ],
        "Answer": "Answer: a\nExplanation: BNF is a metasyntax used to express context free grammar, moreover a formal way to express the language.\n"
    },
    {
        "id": 327,
        "Question": "Which of the following are not used to express CFG?",
        "Options": [
            "a) BNF",
            "b) EBNF, ABNF",
            "c) Van Wijngaarden form",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: W grammar or van Wijngaarden form is used to define potentially infinite context free grammars in a finite number of rules. It is an example of larger class of affix grammars. This technique was used to define the P/L Algol 68."
    },
    {
        "id": 328,
        "Question": "Which of the following version of Unix came up with YACC first?",
        "Options": [
            "a) V3",
            "b) V5",
            "c) CB UNIX",
            "d) Unix-RT"
        ],
        "Answer": "Answer: a\nExplanation: Yacc appeared in version 3 of unix, though full description was published by 1975."
    },
    {
        "id": 329,
        "Question": "XML is a _________ markup language.",
        "Options": [
            "a) meta",
            "b) beta",
            "c) octa",
            "d) peta"
        ],
        "Answer": "Answer: a\nExplanation: Generally speaking, a meta language is a language used to describe a language. XML is a metalanguage that is used to describe a markup language."
    },
    {
        "id": 330,
        "Question": "XML uses _________ principle to formally describe the data.",
        "Options": [
            "a) DDL",
            "b) DTD",
            "c) DML",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A document type definition (DTD) is a set of markup declarations that define a document type for an SGML-family markup language (SGML, XML, HTML). A Document Type Definition (DTD) defines the legal building blocks of an XML document. It defines the document structure with a list of legal elements and attributes."
    },
    {
        "id": 331,
        "Question": "Which among the following are true for an Extensible markup language?",
        "Options": [
            "a) Human Readable/ Machine Readable",
            "b) Extended from SGML",
            "c) Developed by www consortium",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: XML is an open format markup language with a filename extension of .xml."
    },
    {
        "id": 332,
        "Question": "Which of them have XML as their default format?",
        "Options": [
            "a) IWork",
            "b) LibreOffice",
            "c) OpenOffice",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: More that hundred of document formats using XML syntax have been developed, including RSS, Atom, SOAP and XHTML."
    },
    {
        "id": 333,
        "Question": "A DTD is associated with a XML file by means of ___________",
        "Options": [
            "a) Function",
            "b) <!DOCTYPE>",
            "c) Macros",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A document type definition defines the legal building blocks of an XML document ."
    },
    {
        "id": 334,
        "Question": "Which of the following is not an example of electronic mark up?",
        "Options": [
            "a) HTML",
            "b) LaTeX",
            "c) PostScript",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: There are three categories of  electronic markup: presentational, procedural, and descriptive markup. Examples are XML, HTML, LaTeX, etc."
    },
    {
        "id": 335,
        "Question": "troff and nroff are _________ in Unix.",
        "Options": [
            "a) functions",
            "b) typesetting tools",
            "c) System sofwares",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Early examples of computer markup languages can be found in typesetting tools like troff and nroff in Unix."
    },
    {
        "id": 336,
        "Question": "SGML stands for:",
        "Options": [
            "a) Standard Generalized Markup Language",
            "b) Standardized General Markup Language",
            "c) Standard General Markup Language",
            "d) Standard Generalized Markdown Language"
        ],
        "Answer": "Answer: a\nExplanation: SGML is an acronym for Standard Generalized Markup Language."
    },
    {
        "id": 337,
        "Question": "Markup Languages are not used for which of the following?",
        "Options": [
            "a) playlists",
            "b) content syndication",
            "c) user interfaces",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Markup languages originated with text documents, but there is an increasing use of mark up language in presentation of other types of information, including playlists, vector graphics, user interfaces and web services."
    },
    {
        "id": 338,
        "Question": "Which of the following is incorrect for HTML5 markup construct?",
        "Options": [
            "a) Start tags: <section>",
            "b) End tags: </section>",
            "c) <img src= “abc.jpeg” >ABC</img>",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All the mentioned options are valid HTML5 arguments and executes properly."
    },
    {
        "id": 339,
        "Question": "A CFG is ambiguous if",
        "Options": [
            "a) It has more than one rightmost derivations",
            "b) It has more than one leftmost derivations",
            "c) No parse tree can be generated for the CFG",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A context free grammar is ambiguous if it has more than one parse tree generated or more than one leftmost derivations. An unambiguous grammar is a context free grammar for which every valid string has a unique leftmost derivation."
    },
    {
        "id": 340,
        "Question": "Which of the following are always unambiguous?",
        "Options": [
            "a) Deterministic Context free grammars",
            "b) Non-Deterministic Regular grammars",
            "c) Context sensitive grammar",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Deterministic CFGs are always unambiguous , and are an important subclass of unambiguous CFGs; there are non-deterministic unambiguous CFGs, however."
    },
    {
        "id": 341,
        "Question": "A CFG is not closed under",
        "Options": [
            "a) Dot operation",
            "b) Union Operation",
            "c) Concatenation",
            "d) Iteration"
        ],
        "Answer": "Answer: d\nExplanation: The closure property of a context free grammar does not include iteration or kleene or star operation."
    },
    {
        "id": 342,
        "Question": "Which of the following is an real-world programming language ambiguity?",
        "Options": [
            "a) dangling else problem",
            "b) halting problem",
            "c) maze problem",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Dangling else problem: In many languages,the else in an if-then-else statement is optional, which results into nested conditionals being ambiguous, at least in terms of the CFG."
    },
    {
        "id": 343,
        "Question": "Which of the following is a parser for an ambiguous grammar?",
        "Options": [
            "a) GLR parser",
            "b) Chart parser",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: GLR parser: a type of parser for non deterministic and ambiguous grammar\nChart parser: aa type of parser for ambiguous grammar."
    },
    {
        "id": 344,
        "Question": "A language that admits only ambiguous grammar:",
        "Options": [
            "a) Inherent Ambiguous language",
            "b) Inherent Unambiguous language",
            "c) Context free language",
            "d) Context Sensitive language"
        ],
        "Answer": "Answer: a\nExplanation: A context free language for which no unambiguous grammar exists, is called Inherent ambiguous language."
    },
    {
        "id": 345,
        "Question": "Which of the following is an example of inherent ambiguous language?",
        "Options": [
            "a) {an|n>1}",
            "b) {anbncmdm| n,m > 0}",
            "c) {0n1n|n>0}",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: This set is context-free, since the union of two context-free languages is always context free."
    },
    {
        "id": 346,
        "Options": [
            "8. State true or false:",
            "Statement: R->R|T   T->ε is an ambiguous grammar",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: The production can be either itself or an empty string. Thus the empty string has more than one leftmost derivations, depending on how many times R->R is being used."
    },
    {
        "id": 347,
        "Question": "CFGs can be parsed in polynomial time using__________",
        "Options": [
            "a) LR parser",
            "b) CYK algorithm",
            "c) SLR parser",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation:  Dangling else problem\nif R then (if T then P else V) and if R then (if T then P) else V are the two ways in which the given if else statement can be parsed."
    },
    {
        "id": 348,
        "Question": "A push down automaton employs ________ data structure.",
        "Options": [
            "a) Queue",
            "b) Linked List",
            "c) Hash Table",
            "d) Stack"
        ],
        "Answer": "Answer: d\nExplanation: A push down automata uses a stack to carry out its operations. They are more capable than the finite automatons but less than the turing model."
    },
    {
        "id": 349,
        "Options": [
            "2. State true or false:",
            "Statement: The operations of PDA never work on elements, other than the top.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: The term pushdown refers to the fact that the elements are pushed down in the stack and as per the LIFO principle, the operation is always performed on the top element of the stack."
    },
    {
        "id": 350,
        "Question": "Which of the following allows stacked values to be sub-stacks rather than just finite symbols?",
        "Options": [
            "a) Push Down Automaton",
            "b) Turing Machine",
            "c) Nested Stack Automaton",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: In computational theory, a nested stack automaton is a finite automaton which makes use of stack containing data which can be additional stacks."
    },
    {
        "id": 351,
        "Question": "A non deterministic two way, nested stack automaton has n-tuple definition. State the value of n.",
        "Options": [
            "a) 5",
            "b) 8",
            "c) 4",
            "d) 10"
        ],
        "Answer": "Answer: d\nExplanation: The 10-tuple can be stated as: NSA=  <Q,Σ,Γ,δ,q0,Z0,F,[,],]>."
    },
    {
        "id": 352,
        "Question": "Push down automata accepts _________ languages.",
        "Options": [
            "a) Type 3",
            "b) Type 2",
            "c) Type 1",
            "d) Type 0"
        ],
        "Answer": "Answer: b\nExplanation: Push down automata is for Context free languages and they are termed as Type 2 languages according to Chomsky hierarchy."
    },
    {
        "id": 353,
        "Question": "The class of languages  not accepted by non deterministic, nonerasing stack automata is _______",
        "Options": [
            "a) NSPACE(n2)",
            "b) NL",
            "c) CSL",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: NSPACE or non deterministic space is the computational resource describing the memory space for a non deterministic turing machine."
    },
    {
        "id": 354,
        "Question": "A push down automaton with only symbol allowed on the stack along with fixed symbol.",
        "Options": [
            "a) Embedded PDA",
            "b) Nested Stack automata",
            "c) DPDA",
            "d) Counter Automaton"
        ],
        "Answer": "Answer: d\nExplanation: This class of automata can recognize a set of context free languages like {anbn|n belongs to N}\n"
    },
    {
        "id": 355,
        "Question": "Which of the operations are eligible in PDA?",
        "Options": [
            "a) Push",
            "b) Delete",
            "c) Insert",
            "d) Add"
        ],
        "Answer": "Answer: a\nExplanation: Push and pop are the operations we perform to operate a stack. A stack follows the LIFO principle, which states its rule as: Last In First Out."
    },
    {
        "id": 356,
        "Question": "A string is accepted by a PDA when",
        "Options": [
            "a) Stack is not empty",
            "b) Acceptance state",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: When we reach the acceptance state and find the stack to be empty, we say, the string has been accepted by the push down automata."
    },
    {
        "id": 357,
        "Question": "The following move of a PDA is on the basis of:",
        "Options": [
            "a) Present state",
            "b) Input Symbol",
            "c) Present state and Input Symbol",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The next operation is performed by PDA considering three factors: present state,symbol on the top of the stack and the input symbol."
    },
    {
        "id": 358,
        "Question": "If two sets, R and T has no elements in common i.e. RÇT=Æ, then the sets are called",
        "Options": [
            "a) Complement",
            "b) Union",
            "c) Disjoint",
            "d) Connected"
        ],
        "Answer": "Answer: c\nExplanation: Two sets are called disjoint if they have no elements in common i.e.  RÇT=Æ."
    },
    {
        "id": 359,
        "Question": "Which among the following is not a part of the Context free grammar tuple?",
        "Options": [
            "a) End symbol",
            "b) Start symbol",
            "c) Variable",
            "d) Production"
        ],
        "Answer": "Answer: a\nExplanation: The tuple definition of context free grammar is: (V, T, P, S) where V=set of variables, T=set of terminals, P=production, S= Starting Variable."
    },
    {
        "id": 360,
        "Question": "A context free grammar is a ___________",
        "Options": [
            "a) English grammar",
            "b) Regular grammar",
            "c) Context sensitive grammar",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Context free grammar is the set which belongs to the set of context free grammar. Similarly, Regular grammar is a set which belongs to the the set of Context free grammar."
    },
    {
        "id": 361,
        "Question": "The closure property of context free grammar includes :",
        "Options": [
            "a) Kleene",
            "b) Concatenation",
            "c) Union",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Context free grammars are closed under kleene operation, union and concatenation too."
    },
    {
        "id": 362,
        "Question": "Which of the following automata takes stack as auxiliary storage?",
        "Options": [
            "a) Finite automata",
            "b) Push down automata",
            "c) Turing machine",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Pushdown Automaton uses stack as an auxiliary storage for its operations. Turing machines use Queue for the same."
    },
    {
        "id": 363,
        "Question": "Which of the following automata takes queue as an auxiliary storage?",
        "Options": [
            "a) Finite automata",
            "b) Push down automata",
            "c) Turing machine",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Pushdown Automaton uses stack as an auxiliary storage for its operations. Turing machines use Queue for the same."
    },
    {
        "id": 364,
        "Question": "A context free grammar can be recognized by",
        "Options": [
            "a) Push down automata",
            "b) 2 way linearly bounded automata",
            "c) Push down automata & 2 way linearly bounded automata",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: A linearly bounded automata is a restricted non deterministic turing machine which is capable of accepting ant context free grammar."
    },
    {
        "id": 365,
        "Question": "A null production can be referred to as:",
        "Options": [
            "a) String",
            "b) Symbol",
            "c) Word",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Null production is always taken as a string in computational theory."
    },
    {
        "id": 366,
        "Question": "The context free grammar which generates a Regular Language is termed as:",
        "Options": [
            "a) Context Regular Grammar",
            "b) Regular Grammar",
            "c) Context Sensitive Grammar",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Regular grammar is a subset of Context free grammar. The CFGs which produces a language for which a finite automaton can be created is called Regular grammar."
    },
    {
        "id": 367,
        "Question": "NPDA stands for",
        "Options": [
            "a) Non-Deterministic Push Down Automata",
            "b) Null-Push Down Automata",
            "c) Nested Push Down Automata",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: NPDA stands for non-deterministic push down automata whereas DPDA stands for deterministic push down automata."
    },
    {
        "id": 368,
        "Question": "The production of the form A->B , where A and B are non terminals is called",
        "Options": [
            "a) Null production",
            "b) Unit production",
            "c) Greibach Normal Form",
            "d) Chomsky Normal Form"
        ],
        "Answer": "Answer: b\nExplanation: A->ε is termed as Null production while A->B is termed as Unit production."
    },
    {
        "id": 369,
        "Question": "Halting states are of two types. They are:",
        "Options": [
            "a) Accept and Reject",
            "b) Reject and Allow",
            "c) Start and Reject",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Halting states are the new tuple members introduced in turing machine and is of two types: Accept Halting State and Reject Halting State."
    },
    {
        "id": 370,
        "Options": [
            "3. A push down automata can be represented as:",
            "PDA= ε-NFA +[stack]",
            "State true or false:",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation:\n <img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-basic-questions-answers-q3.png\" alt=\"Find push down automata from the given diagram\" width=\"300\" height=\"105\" class=\"alignnone size-full wp-image-160641\" />\n"
    },
    {
        "id": 371,
        "Question": "Which of the following correctly recognize the symbol ‘|-‘ in context to PDA?",
        "Options": [
            "a) Moves",
            "b) transition function",
            "c) or/not symbol",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: z0 is the initial stack symbol, is an element of G. Other symbols like d represents the transition function of the machine."
    },
    {
        "id": 372,
        "Question": "Which of the following can be accepted by a DPDA?",
        "Options": [
            "a) The set of even length palindrome over {a,b}",
            "b) The set of odd length palindrome over {a,b}",
            "c) {xxc| where c stands for the complement,{0,1}}",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Using this notation, we can define moves and further acceptance of a string by the machine."
    },
    {
        "id": 373,
        "Question": "For a counter automaton, with the symbols A and Z0, the string on the stack is always in the form of __________",
        "Options": [
            "a) A",
            "b) AnZ0, n>=0",
            "c) Z0An, n>=0",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: If M is a DPDA accepting L by an empty stsck, R and T are distinct strings in L, and R is a prefix of T, then the sequence of moves M must make in order to accept R leaves the stack empty, since R∈L. But then T cannot be accepted, since M cant move with an empty stack."
    },
    {
        "id": 374,
        "Question": "",
        "Options": [
            "9. State true or false:",
            "Statement: Counter Automaton can exist for the language L={0i1i|i>=0}",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: Theorem: The language pal of palindromes over the alphabet {0,1} cannot be accepted by any finite automaton , and it is therefore not regular."
    },
    {
        "id": 375,
        "Question": "The instantaneous PDA is has the following elements",
        "Options": [
            "a) State",
            "b) Unconsumed input",
            "c) Stack content",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The instantaneous description of a PDA is represented by 3 tuple:\n(q,w,s)\nwhere q is the state, w is the unconsumed input and s is the stack content."
    },
    {
        "id": 376,
        "Question": "The moves in the PDA is technically termed as:",
        "Options": [
            "a) Turnstile",
            "b) Shifter",
            "c) Router",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A turnstile notation is used for connecting pairs od ID’s taht represents one or many moves of a PDA.\n"
    },
    {
        "id": 377,
        "Question": "Which of the following assertion is false?",
        "Options": [
            "a) If L is a language accepted by PDA1 by final state, there exist a PDA2 that accepts L by empty stack i.e. L=L(PDA1)=L(PDA2)",
            "b) If L is a CFL then there exists a push down automata P accepting CF; by empty stack i.e. L=M(P)",
            "c) Let L is a language accepted by PDA1 then there exist a CFG X such that L(X)=M(P)",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: None.\n"
    },
    {
        "id": 378,
        "Question": "A push down automata  can represented using:",
        "Options": [
            "a) Transition graph",
            "b) Transition table",
            "c) ID",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Initially we put a special symbol ‘#’ into the empty stack. At state q1, the w is being read. In state q2, each 0 or 1 is popped when it matches the input. If any other input is given, the PDA will go to a dead state. When we reach that special symbol ‘#’, we go to the accepting state q3."
    },
    {
        "id": 379,
        "Options": [
            "7. State true or false:",
            "Statement: Every context free grammar can be transformed into an equvalent non deterministic push down automata.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: All the assertions mentioned are theorems or corollary."
    },
    {
        "id": 380,
        "Question": "Which of the following statement is false?",
        "Options": [
            "a) For non deterministic PDA, equivalence is undecidable",
            "b) For deterministic PDA, equivalence is decidable",
            "c) For deterministic PDA, equivalence is undecidable",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Yes, a PDA can be represented using a transition diagram, transition table and an instantaneous description."
    },
    {
        "id": 381,
        "Question": "Which of the following are the actions that operates on stack top?",
        "Options": [
            "a) Pushing",
            "b) Popping",
            "c) Replacing",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Push down automata is the automaton machine for all the context free grammar or Type 2 languages."
    },
    {
        "id": 382,
        "Question": "A push down automata is said to be _________ if it has atmost one transition around all configurations.",
        "Options": [
            "a) Finite",
            "b) Non regular",
            "c) Non-deterministic",
            "d) Deterministic"
        ],
        "Answer": "Answer: c\nExplanation: Geraud proved the equivalence problem decidable for Deterministic PDA ."
    },
    {
        "id": 383,
        "Question": "The transition a Push down automaton makes is additionally dependent upon the:",
        "Options": [
            "a) stack",
            "b) input tape",
            "c) terminals",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A PDA is a finite machine which has an additional stack storage. Its transitions are based not only on input and the correct state but also on the stack."
    },
    {
        "id": 384,
        "Question": "A PDA machine configuration (p, w, y) can be correctly represented as:",
        "Options": [
            "a) (current state, unprocessed input, stack content)",
            "b) (unprocessed input, stack content, current state)",
            "c) (current state, stack content, unprocessed input)",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A machine configuration is an element of K×Σ*×Γ*.\n(p,w,γ) = (current state, unprocessed input, stack content)."
    },
    {
        "id": 385,
        "Question": "|-* is the __________ closure of |-",
        "Options": [
            "a) symmetric and reflexive",
            "b) transitive and reflexive",
            "c) symmetric and transitive",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A string w is accepted by a PDA if and only if (s,w, e) |-* (f, e, e)"
    },
    {
        "id": 386,
        "Question": "With reference of a DPDA, which among the following do we perform from the start state with an empty stack?",
        "Options": [
            "a) process the whole string",
            "b) end in final state",
            "c) end with an empty stack",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The empty stack in the end is our requirement relative to finite state automatons."
    },
    {
        "id": 387,
        "Question": "A DPDA is a PDA in which:",
        "Options": [
            "a) No state p has two outgoing transitions",
            "b) More than one state can have two or more outgoing transitions",
            "c) Atleast one state has more than one transitions",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A Deterministic Push Down Automata is a Push Down Automata in which no state p has two or more transitions."
    },
    {
        "id": 388,
        "Options": [
            "6. State true or false:",
            "Statement: For every CFL, G, there exists a PDA M such that L(G) = L(M) and vice versa.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: There exists two lemma’s such that:\na) Given a grammar G, construct the PDA and show the equivalence\nb) Given a PDA, construct a grammar and show the equivalence"
    },
    {
        "id": 389,
        "Question": "If the PDA does not stop on an accepting state and the stack is not empty, the string is:",
        "Options": [
            "a) rejected",
            "b) goes into loop forever",
            "c) all of the mentioned",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: To accept a string, PDA needs to halt at an accepting state and with a stack empty, else it is called rejected. Given a PDA M, we can construct a PDA M’ that accepts the same language as M, by both acceptance criteria."
    },
    {
        "id": 390,
        "Question": "A language accepted by Deterministic Push down automata is closed under which of the following?",
        "Options": [
            "a) Complement",
            "b) Union",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Deterministic Context free languages(one accepted by PDA by final state), are drastically different from the context free languages. For example they are closed under complementation and not union."
    },
    {
        "id": 391,
        "Question": "Which of the following is a simulator for non deterministic automata?",
        "Options": [
            "a) JFLAP",
            "b) Gedit",
            "c) FAUTO",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: JFLAP is a software for experimenting with formal topics including NFA, NPDA, multi-tape turing machines and L-systems."
    },
    {
        "id": 392,
        "Question": "Finite-state acceptors for the nested words can be:",
        "Options": [
            "a) nested word automata",
            "b) push down automata",
            "c) ndfa",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The linear encodings of languages accepted by finite nested word automata gives the class of ‘visibly pushdown automata’."
    },
    {
        "id": 393,
        "Question": "Let T={p, q, r, s, t}. The number of strings in S* of length 4 such that no symbols can be repeated.",
        "Options": [
            "a) 120",
            "b) 625",
            "c) 360",
            "d) 36"
        ],
        "Answer": "Answer: a\nExplanation: All regular languages can be accepted by a non deterministic finite automata and all context free languages can be accepted by a non deterministic push down automata."
    },
    {
        "id": 394,
        "Question": "Which of the following relates to Chomsky hierarchy?",
        "Options": [
            "a) Regular<CFL<CSL<Unrestricted",
            "b) CFL<CSL<Unrestricted<Regular",
            "c) CSL<Unrestricted<CF<Regular",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Using the permutation rule, we can calculate that there will be total of 625 permutations on 5 elements taking 4 as the length."
    },
    {
        "id": 395,
        "Question": "A language is accepted by a push down automata if it is:",
        "Options": [
            "a) regular",
            "b) context free",
            "c) regular and context free",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The chomsky hierarchy lays down the following order: Regular<CFL<CSL<Unrestricted"
    },
    {
        "id": 396,
        "Question": "Which of the following is an incorrect regular expression identity?",
        "Options": [
            "a) R+f=R",
            "b) eR=e",
            "c) Rf=f",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: All the regular languages are the subset to context free languages and thus can be accepted using push down automata."
    },
    {
        "id": 397,
        "Question": "Which of the following regular expression allows strings on {a,b}* with length n where n is a multiple of 4.",
        "Options": [
            "a) (a+b+ab+ba+aa+bb+aba+bab+abab+baba)*",
            "b) (bbbb+aaaa)*",
            "c) ((a+b)(a+b)(a+b)(a+b))*",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: e is the identity for concatenation. Thus, eR=R."
    },
    {
        "id": 398,
        "Question": "abb*c denotes which of the following?",
        "Options": [
            "a) {abnc|n=0}",
            "b) {abnc|n=1}",
            "c) {anbc|n=0}",
            "d) {abcn|n>0}"
        ],
        "Answer": "Answer: d\nExplanation: The string acbacba is unacceptable by the regular expression (a)*(a+cba)."
    },
    {
        "id": 399,
        "Question": "Context free grammar is called Type 2 grammar because of ______________ hierarchy.",
        "Options": [
            "a) Greibach",
            "b) Backus",
            "c) Chomsky",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Chomsky hierarchy decide four type of language :Type 3- Regular Language, Type 2-Context free language, Type 1-Context Sensitive Language, Type 0- Unrestricted or Recursively Ennumerable language."
    },
    {
        "id": 400,
        "Options": [
            "4. If P is the production, for the given statement, state true or false.",
            "P: V->(V∑T)* represents that the left hand side production rule has no right or left context.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: A context-sensitive grammar (CSG) is a formal grammar in which the left-hand sides and right-hand sides of any production rules may be surrounded by a context of terminal and non terminal symbols. Context-sensitive grammars are more general than context-free grammars, in the sense that there are some languages that cannot be described by context-free grammars, but can be described by CSG."
    },
    {
        "id": 401,
        "Question": "If the partial derivation tree contains the root as the starting variable, the form is known as:",
        "Options": [
            "a) Chomsky hierarchy",
            "b) Sentential form",
            "c) Root form",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: V is the set of non terminal symbols while T is the st of terminal symbols, their intersection would always be null."
    },
    {
        "id": 402,
        "Question": "A CFG consist of the following elements:",
        "Options": [
            "a) a set of terminal symbols",
            "b) a set of non terminal symbols",
            "c) a set of productions",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Here the production P is from the definition of Context free grammar and thus, has no right or left context."
    },
    {
        "id": 403,
        "Question": "CFGs are more powerful than:",
        "Options": [
            "a) DFA",
            "b) NDFA",
            "c) Mealy Machine",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation:\nContext-free grammars are strictly more powerful than regular expressions:\n1) Any language that can be generated using regular expressions can be generated by a context-free grammar.\n2) There are languages that can be generated by a context-free grammar that cannot be generated by any regular expression.\nAs a corollary, CFGs are strictly more powerful than DFAs and NDFAs."
    },
    {
        "id": 404,
        "Question": "State true or false:",
        "Options": [
            "S-> 0S1|01",
            "Statement: No regular expression exists for the given grammar.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: The grammar generates a language L such that L={0n1n|n>=1} which is not regular. Thus, no regular expression exists for the same."
    },
    {
        "id": 405,
        "Question": "Which among the following is incorrect with reference to a derivation tree?",
        "Options": [
            "a) Every vertex has a label which is a terminal or a variable.",
            "b) The root has a label which can be a terminal.",
            "c) The label of the internal vertex is a variable.",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation:\n   –>    \n   –>   | epsilon\n   –> ‘.’   | epsilon\n   –> ‘E’    | epsilon\n   –> + | – | epsilon\n   –> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n"
    },
    {
        "id": 406,
        "Question": "Which of the following are non essential while simplifying a grammar?",
        "Options": [
            "a) Removal of useless symbols",
            "b) Removal of unit productions",
            "c) Removal of null production",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The root or interms of the grammar, starting variable can not be a terminal."
    },
    {
        "id": 407,
        "Question": "Which of the following are context free language?",
        "Options": [
            "a) L={aibi|i>=0}",
            "b) L={wwr| w is a string and r represents reverse}",
            "c) All of the mentioned",
            "d) one of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The step wise grammar translation can be written as:\n aAS->aSbaA->aabAS->aabbaa\n"
    },
    {
        "id": 408,
        "Question": "The language L ={ai2bi|i>=0} is:",
        "Options": [
            "a) recursive",
            "b) deterministic CFL",
            "c) regular",
            "d) Two of the mentioned is correct"
        ],
        "Answer": "Answer: c\nExplanation: One language can more than one grammar. Some can be ambiguous and some cannot."
    },
    {
        "id": 409,
        "Question": "Suppose A->xBz and B->y, then the simplified grammar would be:",
        "Options": [
            "a) A->xyz",
            "b) A->xBz|xyz",
            "c) A->xBz|B|y",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: For the first step, substitute B in first production as it only produces terminal and remove B production as it has already been utilized.\nWe get A->xBz|xyz and now, as B has no production, we eliminate the terms which hold the variable B, thus the answer remain A->xyz.\n"
    },
    {
        "id": 410,
        "Question": "Inorder to simplify a context free grammar, we can skip the following operation:",
        "Options": [
            "a) Removal of null production",
            "b) Removal of useless symbols",
            "c) Removal of unit productions",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Some derivations are not reachable from the starting variable. As B is not reachable from the starting variable, it is a useless symbol and thus, can be eliminated.\n"
    },
    {
        "id": 411,
        "Options": [
            "a) A-> a| aaA| ababbAc| abbc",
            "b) A-> a| aaA| ababbAc| abbc, B-> abba|b",
            "c) A-> a| aaA| abbc, B->abba",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Whatever operation we perform in intermediate stages, if the string produced belongs to the language, A is termed as useful and if not, not a useful variable.\n"
    },
    {
        "id": 412,
        "Question": "In context to the process of removing useless symbols, which of the following is correct?",
        "Options": [
            "a) We remove the Nullable variables",
            "b) We eliminate the unit productions",
            "c) We eliminate products which yield no terminals",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A, B, C, D are the useless symbols in the given grammar as they never tend to lead to a terminal. The productions S-> A, A->aA, B->C, C->D are also termed as useless production as they will never produce a string to the grammar."
    },
    {
        "id": 413,
        "Question": "The use of variable dependency graph is in:",
        "Options": [
            "a) Removal of useless variables",
            "b) Removal of null productions",
            "c) Removal of unit productions",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: We use the concept of dependency graph inorder to check, whether any of the variable is reachable from the starting variable or not."
    },
    {
        "id": 414,
        "Question": "The variable which produces an epsilon is called:",
        "Options": [
            "a) empty variable",
            "b) nullable",
            "c) terminal",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Any variable A for which the derivation: A->*e is possible is called Nullable.\n"
    },
    {
        "id": 415,
        "Question": "Statement:",
        "Options": [
            "For A-> e ,A can be erased. So whenever it appears on the left side of a production, replace with another production without the A.",
            "State true or false:",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation:  A can be erased. So whenever it appears on the right side of the production, replace with another production without the A."
    },
    {
        "id": 416,
        "Question": "Let G=(V, T, P, S) be a CFG such that _____________. Then there exists an equivalent grammar G’ having no e productions.",
        "Options": [
            "a) e ∈ L(G)",
            "b) w ∉ L(G)",
            "c) e ∉ L(G)",
            "d) w ∈ L(G)"
        ],
        "Answer": "Answer: a\nExplanation: As X is nullable, we replace every right hand side presence of X with e and produce the simplified result.\n"
    },
    {
        "id": 417,
        "Question": "Which of the following is the format of unit production?",
        "Options": [
            "a) A->B",
            "b) A->b",
            "c) B->Aa",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Any production of the format A-> B where A and B belongs to the V set, is called Unit production."
    },
    {
        "id": 418,
        "Question": "If grammar G is unambiguous, G’ produced after the removal of Unit production will be:",
        "Options": [
            "a) ambiguous",
            "b) unambiguous",
            "c) finite",
            "d) cannot be said"
        ],
        "Answer": "Answer: c\nExplanation: The productions in the format A-> A are removed immediately as they produce self and that is not a terminal or will not lead to a string. Hence, it is removed immediately."
    },
    {
        "id": 419,
        "Question": "If C is A-derivable, C->B is a production, and B ¹ A, then B is",
        "Options": [
            "a) nullable",
            "b) Non-derivable",
            "c) A-derivable",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The simplified grammar can be presented as follows:\nS->aA| aB\nA->a\nB-> bb\n"
    },
    {
        "id": 420,
        "Question": "A can be A-> derivable if and only if __________",
        "Options": [
            "a) A-> A is actually a production",
            "b) A->B, B-> A exists",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: With the simplification of Context free grammars, undesirable properties are introduced. It says, if grammar G, before simplification is unambiguous, after simplification will also be unambiguous."
    },
    {
        "id": 421,
        "Question": "The format: A->aB refers to which of the following?",
        "Options": [
            "a) Chomsky Normal Form",
            "b) Greibach Normal Form",
            "c) Backus Naur Form",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A context free grammar is in Greibach Normal Form if the right hand sides of all the production rules start with a terminal, optionally followed by some variables."
    },
    {
        "id": 422,
        "Question": "Which of the following does not have left recursions?",
        "Options": [
            "a) Chomsky Normal Form",
            "b) Greibach Normal Form",
            "c) Backus Naur Form",
            "d) All  of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The normal form is of the format:\nA->aB where the right hand side production tends to begin with a terminal symbo, thus having no left recursions."
    },
    {
        "id": 423,
        "Question": "Every grammar in Chomsky Normal Form is:",
        "Options": [
            "a) regular",
            "b) context sensitive",
            "c) context free",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Conversely, every context frr grammar can be converted into Chomsky Normal form and to other forms."
    },
    {
        "id": 424,
        "Question": "Which of the production rule can be accepted by Chomsky grammar?",
        "Options": [
            "a) A->BC",
            "b) A->a",
            "c) S->e",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: in CNF, the production rules are of the form:\nA->BC\nA-> a\nS->e\n"
    },
    {
        "id": 425,
        "Question": "Which of the following grammars are in Chomsky Normal Form:",
        "Options": [
            "a) S->AB|BC|CD, A->0, B->1, C->2, D->3",
            "b) S->AB, S->BCA|0|1|2|3",
            "c) S->ABa, A->aab, B->Ac",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The correct format: A->BC, A->a, X->e."
    },
    {
        "id": 426,
        "Question": "In which of the following, does the CNF conversion find its use?",
        "Options": [
            "a) CYK Algorithm",
            "b) Bottom up parsing",
            "c) Preprocessing step in some algorithms",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: We can eliminate the options on the basis of the format we are aware of: A->BC, B->b and so on."
    },
    {
        "id": 427,
        "Question": "Let G be a grammar. When the production in G satisfy certain restrictions, then G is said to be in ___________",
        "Options": [
            "a) restricted form",
            "b) parsed form",
            "c) normal form",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: According to the number of terminals present in the grammar, we need the corresponding that number of terminal variables while conversion."
    },
    {
        "id": 428,
        "Options": [
            "10. Let G be a grammar: S->AB|e, A->a, B->b",
            "Is the given grammar in CNF?",
            "a) Yes",
            "b) No"
        ],
        "Answer": "Answer: d\nExplanation: Besides the theoretical significance of CNF, it conversion scheme is helpful in algorithms as a preprocessing step, CYK algorithms and the bottom up parsing of context free grammars."
    },
    {
        "id": 429,
        "Question": "Which of the following is called Bar-Hillel lemma?",
        "Options": [
            "a) Pumping lemma for regular language",
            "b) Pumping lemma for context free languages",
            "c) Pumping lemma for context sensitive languages",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: In automata theory, the pumping lemma for context free languages, also kmown as the  Bar-Hillel lemma, represents a property of all context free languages.\n"
    },
    {
        "id": 430,
        "Question": "Which of the expressions correctly is an requirement of the pumping lemma for the context free languages?",
        "Options": [
            "a) uvnwxny",
            "b) uvnwnxny",
            "c) uv2nwx2ny",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Let L be a CFL. Then there is an integer n so that for any u that belong to language L satisfying |t| >=n, there are strings u, v, w, x, y and z satisfying\nt=uvwxy\n|vx|>0\n|vwx|<=n\nFor any m>=0, uvnwxny ∈ L\n"
    },
    {
        "id": 431,
        "Question": "Which of the following gives a positive result to the pumping lemma restrictions and requirements?",
        "Options": [
            "a) {aibici|i>=0}",
            "b) {0i1i|i>=0}",
            "c) {ss|s∈{a,b}*}",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: This inequation has been derived from derivation tree for t which must have height at least p+2(It has more than 2p leaf nodes, and therefore its height is >p+1)."
    },
    {
        "id": 432,
        "Question": "Using pumping lemma, which of the following cannot be proved as ‘not a CFL’?",
        "Options": [
            "a) {aibici|i>=0}",
            "b) {ss|s∈{a,b}*}",
            "c) The set legal C programs",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A positive result to the pumping lemma shows that the language is a CFL and ist contradiction or negative result shows that the given language is not a Context Free language."
    },
    {
        "id": 433,
        "Options": [
            "6. State true or false:",
            "Statement: We cannot use Ogden’s lemma when pumping lemma fails.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: There are few rules in C that are context dependent. For example, declaration of a variable before it can be used."
    },
    {
        "id": 434,
        "Question": "The pumping lemma is often used to prove that a language is:",
        "Options": [
            "a) Context free",
            "b) Not context free",
            "c) Regular",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Although the pumping lemma provides some information about v and x that are pumped, it says little about the location of these substrings in the string t. It can be used whenever the pumping lemma fails. Example: {apbqcrds|p=0 or q=r=s}, etc."
    },
    {
        "id": 435,
        "Question": "What is the pumping length of string of length x?",
        "Options": [
            "a) x+1",
            "b) x",
            "c) x-1",
            "d) x2"
        ],
        "Answer": "Answer: c\nExplanation: A set of context free language is closed under the following operations:\na) Union\nb) Concatenation\nc) Kleene "
    },
    {
        "id": 436,
        "Question": "Which of the following does not obey pumping lemma for context free languages ?",
        "Options": [
            "a) Finite languages",
            "b) Context free languages",
            "c) Unrestricted languages",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The pumping lemma is often used to prove that a given language L is non-context-free, by showing that arbitrarily long strings s are in L that cannot be “pumped” without producing strings outside L."
    },
    {
        "id": 437,
        "Question": "The context free languages are closed under:",
        "Options": [
            "a) Intersection",
            "b) Complement",
            "c) Kleene",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Context free languages are closed under the following operation: union, kleene and concatenation. For regular languages, we can add intersection and complement to the list."
    },
    {
        "id": 438,
        "Question": "Context free languages are not closed under:",
        "Options": [
            "a) Intersection",
            "b) Intersection with Regular Language",
            "c) Complement",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation:\nT->S|R\nS->aSb\nS->e\nR->cRd\nR->e\n"
    },
    {
        "id": 439,
        "Question": "If the start symbol is one of those symbols which produce no terminal through any sequence, the CFL is said to be",
        "Options": [
            "a) nullable",
            "b) empty",
            "c) eliminated",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: It is a theorem which states that, Context free languages are not closed under operations like intersection and complement."
    },
    {
        "id": 440,
        "Question": "Using the pumping constant n, If there is a string in the language of length between _____ and ____ then the language is infite else not.",
        "Options": [
            "a) n, 2n-1",
            "b) 2n, n",
            "c) n+1, 3n+6",
            "d) 0, n+1"
        ],
        "Answer": "Answer: d\nExplanation: These properties are termed as decision properties of a CFL and include a set of problems like infiniteness problem, emptiness problem and membership problem."
    },
    {
        "id": 441,
        "Question": "Which of the following is/are CFL not closed under?",
        "Options": [
            "a) Reverse",
            "b) Homomorphism",
            "c) Inverse Homomorphism",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: In the process of removing useless symbols, if the starting symbol is also a part, the CFL can be then termed as empty; otherwise not."
    },
    {
        "id": 442,
        "Question": "If L1 and L2 are context free languages, L1-L2 are context free:",
        "Options": [
            "a) always",
            "b) sometimes",
            "c) never",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: If there is a string in the language of length between n and 2n-1 then the language is infite else not. The idea is essentially the same for regular languages."
    },
    {
        "id": 443,
        "Question": "A___________ is context free grammar with atmost one non terminal in the right handside of the production.",
        "Options": [
            "a) linear grammar",
            "b) linear bounded grammar",
            "c) regular grammar",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: CFL is closed under union, kleene and concatenation along with the properties reversal,homomorphism and inverse homomorphism but not difference and intersection."
    },
    {
        "id": 444,
        "Question": "There is a linear grammar that generates a context free grammar",
        "Options": [
            "a) always",
            "b) never",
            "c) sometimes",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Context free languages are not closed under difference, intersection and complement operations.\n"
    },
    {
        "id": 445,
        "Question": "Every Kuroda Normal form grammar generates ___________",
        "Options": [
            "a) Context free grammar",
            "b) Context sensitive grammar",
            "c) Unrestricted grammar",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Linearly Bounded grammar or Kuroda Normal Form allows the following format of grammatical analysis:\nAB->CD\nA->BC or\nA->B or\nA->a\n"
    },
    {
        "id": 446,
        "Question": "Which of the following can generate Unrestricted grammars?",
        "Options": [
            "a) Pentonnen Normal form",
            "b) Floyd Normal form",
            "c) Greibach Normal form",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Every context sensitive grammar which does not produce an empty string can be generated by a grammar in Kuroda Normal form."
    },
    {
        "id": 447,
        "Question": "Given a grammar in GNF and a derivable string in the grammar with the length n, any ___________will halt at depth n.",
        "Options": [
            "a) top-down parser",
            "b) bottom-up parser",
            "c) multitape turing machine",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Pentonnen Normal form(for Unrestricted grammars) is a special case where there is a slight modification in the format of Kuroda Normal form.\nAB->AD\nA->BC\nA->a\n"
    },
    {
        "id": 448,
        "Question": "Which of the following grammars is similar to Floyd Normal form?",
        "Options": [
            "a) Backus Naur Form",
            "b) Kuroda Normal Form",
            "c) Greibach Normal Form",
            "d) Chomsky Normal Form"
        ],
        "Answer": "Answer: a\nExplanation: Given a grammar in GNF and a derivable string in the grammar with the length n, any top-down parser will halt at depth n. As the parameter ‘depth’ is mentioned, we will use a top-down parser. Example-LL parser."
    },
    {
        "id": 449,
        "Question": "Which among the following can parse a context free grammar?",
        "Options": [
            "a) top down parser",
            "b) bottom up parser",
            "c) CYK algorithm",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Donald Knuth implied a BNF” syntax in which all definitions have such a form may be said to be in ”Floyd Normal Form”.\nA->B|C\nA->BC\nA->a\n"
    },
    {
        "id": 450,
        "Question": "The standard version of CYK algorithm operates only on context free grammars in the following form:",
        "Options": [
            "a) Greibach Normal form",
            "b) Chomsky Normal form",
            "c) Backus Naur form",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: We use certain algorithms to parse a context free grammar which include the most popular CYK algorithm which employs the concept of bottom up parsing and dynamic parsing."
    },
    {
        "id": 451,
        "Question": "Which of the following is true for Valiants algorithm?",
        "Options": [
            "a) an extension of CYK",
            "b) deals with efficient multiplication algorithms",
            "c) matrices with 0-1 entries",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: It requires the presence of a context free grammar into Chomsky Normal form to operate. However, every context free grammar can be converted into CNF for keeping the sense of grammar equivalent."
    },
    {
        "id": 452,
        "Question": "Which among the following is a correct option in format for representing symbol and expression in Backus normal form?",
        "Options": [
            "a) <symbol> ->expression",
            "b) <symbol>::=_expression_",
            "c) <symbol>=<expression>",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: This is the worst case running time of CYK and and this makes it one of the most efficient algorithms for recognizing general context free languages in practice."
    },
    {
        "id": 453,
        "Question": "Which of the following is not a negative property of Context free languages?",
        "Options": [
            "a) Intersection",
            "b) Complement",
            "c) Intersection and Complement",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Context free languages are not closed under complement and intersection. Thus, are called Negative properties."
    },
    {
        "id": 454,
        "Question": "The intersection of context free language and regular language is _________",
        "Options": [
            "a) regular language",
            "b) context free language",
            "c) context sensitive language",
            "d) non of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: If a language L1 is regular and L2 is a context free language, then L1 intersection L2 will result into a context free language."
    },
    {
        "id": 455,
        "Question": "Which of the following is regular?",
        "Options": [
            "a) a100b100",
            "b) (a+b)*-{a100b100}",
            "c) a100b100 and (a+b)*-{a100b100}",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: As the language seems to be finite, a dfa can be constructed for the same, thus is regular."
    },
    {
        "id": 456,
        "Question": "Which of the following is not context free?",
        "Options": [
            "a) {w: nA=nB=nC}",
            "b) {a*b*c*}",
            "c) {a100b100}",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: {a*b*c*} and (c) are regular languages while option (a) is not context free language."
    },
    {
        "id": 457,
        "Question": "Which of the following can be used to prove a language is not context free?",
        "Options": [
            "a) Ardens theorem",
            "b) Power Construction method",
            "c) Regular Closure",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: We can use the properties of regular closure to prove that a language is not a context free language. Example: Intersection of context free language and regular language is a context free language. Proof by contradiction helps here."
    },
    {
        "id": 458,
        "Question": "Which of the following are valid membership algorithms?",
        "Options": [
            "a) CYK algorithm",
            "b) Exhaustive search parser",
            "c) CYK algorithm and Exhaustive search parser",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: CYK algorithm is a parsing algorithm for context free grammars, which employs bottom up parsing and dynamic programming."
    },
    {
        "id": 459,
        "Question": "Which of the following belong to the steps to prove emptiness?",
        "Options": [
            "a) Remove useless variable",
            "b) Check if a start variable S is useless",
            "c) Remove useless variable and Check if a start variable S is useless",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The empty-language question can be stated as: For context free grammar G find if L(G) =f?"
    },
    {
        "id": 460,
        "Question": "Which of the following is true for CYK Algorithm?",
        "Options": [
            "a) Triangular Table",
            "b) Circular Chart",
            "c) Linked List",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A triangular table is constructed to facilitate the solution of membership problem using bottom up parsing and dynamic programming."
    },
    {
        "id": 461,
        "Question": "Which of the following steps are wrong with respect to infiniteness problem?",
        "Options": [
            "a) Remove useless variables",
            "b) Remove unit and epsilon production",
            "c) Create dependency graph for variables",
            "d) If there is a loop in the dependency graph the language is finite else infinite"
        ],
        "Answer": "Answer: d\nExplanation: If we are able to detect a loop in the formed dependency graph, then the language in infinite."
    },
    {
        "id": 462,
        "Options": [
            "10. State true or false:",
            "Statement: Every context free language can be generated by a grammar which contains no useless non terminals.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: At first, we detect useless symbols and discard them. Inorder to find whether a symbol is useless, just make it the starting symbol and check for emptiness."
    },
    {
        "id": 463,
        "Question": "A turing machine is a",
        "Options": [
            "a) real machine",
            "b) abstract machine",
            "c) hypothetical machine",
            "d) more than one option is correct"
        ],
        "Answer": "Answer: d\nExplanation: A turing machine is abstract or hypothetical machine thought by mathematician Alan Turing in 1936 capable of simulating any algorithm, however complicated it is."
    },
    {
        "id": 464,
        "Question": "A turing machine operates over:",
        "Options": [
            "a) finite memory tape",
            "b) infinite memory tape",
            "c) depends on the algorithm",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The turing machine operates on an infinite memory tape divided into cells. The machine positions its head over the cell and reads the symbol."
    },
    {
        "id": 465,
        "Question": "Which of the functions are not performed by the turing machine after reading a symbol?",
        "Options": [
            "a) writes the symbol",
            "b) moves the tape one cell left/right",
            "c) proceeds with next instruction or halts",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: After the read head  reads the symbol from the input tape, it performs the following functions:\na) writes a symbol(some model allow symbol erasure/no writing)\nb) moves the tape left or right (some models allows no motion)\nc) proceeds with subsequent instruction or goes either into accepting halting state or rejecting halting state."
    },
    {
        "id": 466,
        "Question": "‘a’ in a-machine is :",
        "Options": [
            "a) Alan",
            "b) arbitrary",
            "c) automatic",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The turing machine was invented by Alan turing in 1936. He named it as a-machine(automatic machine)."
    },
    {
        "id": 467,
        "Question": "Which of the problems were not answered when the turing machine was invented?",
        "Options": [
            "a) Does a machine exists that can determine whether any arbitrary machine on its tape is circular.",
            "b) Does a machine exists that can determine whether any arbitrary machine on its tape is ever prints a symbol",
            "c) Hilbert Entscheidungs problem",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Invention of turing machine answered a lot of questions which included problems like decision problem, etc.) . Alan was able to prove the properties of computation using such model."
    },
    {
        "id": 468,
        "Question": "The ability for a system of instructions to simulate a Turing Machine is called _________",
        "Options": [
            "a) Turing Completeness",
            "b) Simulation",
            "c) Turing Halting",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Turing Completeness the ability for a system of instructions to simulate a Turing machine. A programming language that is Turing complete is theoretically capable of expressing all tasks accomplishable by computers; nearly all programming languages are Turing complete."
    },
    {
        "id": 469,
        "Question": "Turing machine can be represented using the following tools:",
        "Options": [
            "a) Transition graph",
            "b) Transition table",
            "c) Queue and Input tape",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: We can represent a turing machine, graphically, tabularly and diagramatically."
    },
    {
        "id": 470,
        "Question": "Which of the following is false for an abstract machine?",
        "Options": [
            "a) Turing machine",
            "b) theoretical model of computer",
            "c) assumes a discrete time paradigm",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: A n abstract machine also known as abstract computer, is a theoretical model of computer or hardware system in automata theory. Abstraction in computing process usually assumes a discrete time paradigm."
    },
    {
        "id": 471,
        "Options": [
            "10. State true or false:",
            "Statement: RAM model allows random access to indexed memory locations.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: A thought experiment considers some hypothesis, theory or principle for the purpose of thinking through its consequences."
    },
    {
        "id": 472,
        "Question": "A turing machine that is able to simulate other turing machines:",
        "Options": [
            "a) Nested Turing machines",
            "b) Universal Turing machine",
            "c) Counter machine",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A more mathematically oriented  definition with the same universal nature was introduced by church and turing together called the Church-Turing thesis(formal theory of computation)."
    },
    {
        "id": 473,
        "Question": "Which of the problems are unsolvable?",
        "Options": [
            "a) Halting problem",
            "b) Boolean Satisfiability problem",
            "c) Halting problem & Boolean Satisfiability problem",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Alan turing proved in 1936 that a general algorithm to solve the halting problem for all possible program-input pairs cannot exist."
    },
    {
        "id": 474,
        "Question": "Which of the following a turing machine does not consist of?",
        "Options": [
            "a) input tape",
            "b) head",
            "c) state register",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: A state register is one which stores the state of the turing machine, one of the finitely many. Among these is the special start state with which the state register is initialized."
    },
    {
        "id": 475,
        "Question": "The value of n if turing machine is defined using n-tuples:",
        "Options": [
            "a) 6",
            "b) 7",
            "c) 8",
            "d) 5"
        ],
        "Answer": "Answer: b\nExplanation:\nThe 7-tuple definition of turing machine: (Q, S, G, d, q0, B, F)\nwhere Q= The finite set of states of finite control\nS= The finite set of input symbols\nG= The complete set of tape symbols\nd= The transition function\nq0= The start state, a member of Q, in which the finite control is found initially.\nB= The blank symbol\nF= The set of final or accepting states, a subset of Q.\n"
    },
    {
        "id": 476,
        "Question": "If  d is not defined on the current state and the current tape symbol, then the machine ______",
        "Options": [
            "a) does not halts",
            "b) halts",
            "c) goes into loop forever",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: If we reach hA or hR, we say TM halts. Once it has halted, it cannot move further, since  d is not defined at any pair (hA,X) or (hR,X) where hA = accept halting state and hR = reject halting state."
    },
    {
        "id": 477,
        "Options": [
            "6. Statement: Instantaneous descriptions can be designed for a Turing machine.",
            "State true or false:",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: Inorder to describe formally what a Turing machine does, we need to develop a notation for configurations or Instantaneous descriptions(ID)."
    },
    {
        "id": 478,
        "Question": "Which of the following are the models equivalent to Turing machine?",
        "Options": [
            "a) Multi tape turing machine",
            "b) Multi track turing machine",
            "c) Register machine",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Many machines that might be thought to have more computational capability than a simple UTM can be shown to have  no more power. They might compute faster or use less memory but cannot compute more powerfully i.e. more mathematical questions."
    },
    {
        "id": 479,
        "Question": "Which among the following is incorrect for o-machines?",
        "Options": [
            "a) Oracle Turing machines",
            "b) Can be used to study decision problems",
            "c) Visualizes Turing machine with a black box which is able to decide cerain decion problems in one operation",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: In automata theory, an o- machine or oracle machine is a abstract machine used to study decision problems. The problem the oracle solves can be of any complexity class. Even undecidable problems like halting problems can be used."
    },
    {
        "id": 480,
        "Question": "RASP stands for:",
        "Options": [
            "a) Random access storage program",
            "b) Random access stored program",
            "c) Randomly accessed stored program",
            "d) Random access storage programming"
        ],
        "Answer": "Answer: b\nExplanation: RASP or Random access stored program is an abstract machine that has instances like modern stored computers."
    },
    {
        "id": 481,
        "Question": "",
        "Options": [
            "11. State true or false:",
            "Statement: RASP is to RAM like UTM is to turing machine.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: In theoretical computer science, the random access stored program( RASP ) machine model is an abstract machine used for the purpose of algorithm development and algorithm complexity theory."
    },
    {
        "id": 482,
        "Question": "The class of recursively enumerable language is known as:",
        "Options": [
            "a) Turing Class",
            "b) Recursive Languages",
            "c) Universal Languages",
            "d) RE"
        ],
        "Answer": "Answer: d\nExplanation: RE or recursively enumerable is only called the class of recursively enumerable language."
    },
    {
        "id": 483,
        "Question": "A language L is said to be Turing decidable if:",
        "Options": [
            "a) recursive",
            "b) TM recognizes L",
            "c) TM accepts L",
            "d) recursive & TM recognizes L"
        ],
        "Answer": "Answer: d\nExplanation: A language L is recursively enumerable if there is a turing machine that accepts L, and recursive if there is a TM that recognizes L.(Sometimes these languages are alse called Turing-acceptable and Turing-decidable respectively)."
    },
    {
        "id": 484,
        "Question": "Which of the following statements are false?",
        "Options": [
            "a) Every recursive language is recursively enumerable",
            "b) Recursively enumerable language may not be recursive",
            "c) Recursive languages may not be recursively enumerable",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Every recursive language is recursively enumerable but there exists recursively enumerable languages that are not recursive. If L is accepted by a Non deterministic TM  T, and every possible sequence of moves of T causes it to halt, then L is recursive."
    },
    {
        "id": 485,
        "Question": "If L is a recursive language, L’ is:",
        "Options": [
            "a) Recursive",
            "b) Recursively Enumerable",
            "c) Recursive and Recursively Enumerable",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Both the union and intersection operations preserve the property of recursive enumerablity(Theorem)."
    },
    {
        "id": 486,
        "Question": "A recursively enumerable language L can be recursive if:",
        "Options": [
            "a) L’ is recursively enumerable",
            "b) Every possible sequence of moves of T, the TM which accept L, causes it to halt",
            "c) L’ is recursively enumerable and every possible sequence of moves of T, the TM which accept L, causes it to halt",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: If T is a turing machine recognizing L, we can make it recognize L’ by interchanging the two outputs. And every recursive language is recursively enumerable."
    },
    {
        "id": 487,
        "Options": [
            "9. State true or false:",
            "Statement: An enumerator is a turing machine with extra output tape T, where symbols, once written, are never changed.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: The closure property of recursive languages include union, intersection and complement operations."
    },
    {
        "id": 488,
        "Question": "A Language L may not be accepted by a Turing Machine if:",
        "Options": [
            "a) It is recursively enumerable",
            "b) It is recursive",
            "c) L can be enumerated by some turing machine",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Theorem- If L is a recursively enumerable language whose complement is recursively enumerable, then L is recursive."
    },
    {
        "id": 489,
        "Question": "Construct a turing machine which accepts a string with ‘aba’ as its substring.",
        "Options": [
            "a)<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2a.png\" alt=\"Find the string with ‘aba’ from the given diagram\" width=\"520\" height=\"260\" class=\"alignnone size-full wp-image-160699\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2a.png 520w, https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2a-300x150.png 300w\" sizes=\"(max-width: 520px) 100vw, 520px\" />",
            "b)<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2b.png\" alt=\"Find the epsilon from the given diagram\" width=\"520\" height=\"260\" class=\"alignnone size-full wp-image-160700\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2b.png 520w, https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2b-300x150.png 300w\" sizes=\"(max-width: 520px) 100vw, 520px\" />",
            "c)<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2c.png\" alt=\"Find the five states to express the language from the given diagram\" width=\"530\" height=\"260\" class=\"alignnone size-full wp-image-160701\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2c.png 530w, https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2c-300x147.png 300w\" sizes=\"(max-width: 530px) 100vw, 530px\" />",
            "d)<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2d.png\" alt=\"Find the rejection halting state from the given diagram\" width=\"530\" height=\"260\" class=\"alignnone size-full wp-image-160702\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2d.png 530w, https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2d-300x147.png 300w\" sizes=\"(max-width: 530px) 100vw, 530px\" />"
        ],
        "Answer": "Answer: b\nExplanation: The given diagram is a transition graph for a turing machine which accepts the language with the regular expression {a,b}*{aba}.\n"
    },
    {
        "id": 490,
        "Question": "The number of states required to automate the last question i.e. {a,b}*{aba}{a,b}* using finite automata:",
        "Options": [
            "a) 4",
            "b) 3",
            "c) 5",
            "d) 6"
        ],
        "Answer": "Answer: c\nExplanation: The language consist of strings with a substring ‘aba’ as fixed at its end and the left part can be anything including epsilon. Thus the turing machine uses five states to express the language excluding the rejection halting state which if allowed can modify the graph as:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2e.png\" alt=\"Find the strings with a substring from the given diagram\" width=\"530\" height=\"373\" class=\"alignnone size-full wp-image-160703\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2e.png 530w, https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q2e-300x211.png 300w\" sizes=\"(max-width: 530px) 100vw, 530px\" />\n"
    },
    {
        "id": 491,
        "Question": "The machine accept the string by entering into hA or it can:",
        "Options": [
            "a) explicitly reject x by entering into hR",
            "b) enter into an infinte loop",
            "c) explicitly reject x by entering into hR and enter into an infinte loop",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The finite automata can be represented as:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q3.png\" alt=\"Find the strings with a substring from the given diagram\" width=\"480\" height=\"176\" class=\"alignnone size-full wp-image-160704\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q3.png 480w, https://www.sanfoundry.com/wp-content/uploads/2017/05/automata-theory-questions-answers-turing-machine-halting-q3-300x110.png 300w\" sizes=\"(max-width: 480px) 100vw, 480px\" />\n"
    },
    {
        "id": 492,
        "Question": "Which of the following can accept even palindrome over {a,b}",
        "Options": [
            "a) Push down Automata",
            "b) Turing machine",
            "c) NDFA",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Three things can occur when a string is tested over a turing machine:\na) enter into accept halting state\nb) enter into reject halting state\nc) goes into loop forever"
    },
    {
        "id": 493,
        "Question": "Which of the functions can a turing machine not perform?",
        "Options": [
            "a) Copying a string",
            "b) Deleting a symbol",
            "c) Accepting a pal",
            "d) Inserting a symbol"
        ],
        "Answer": "Answer: c\nExplanation: D represents the direction in which automata moves forward as per the queue which surely cannot be a starting variable."
    },
    {
        "id": 494,
        "Question": "If T1 and T2 are two turing machines. The composite can be represented using the expression:",
        "Options": [
            "a) T1T2",
            "b) T1 U T2",
            "c) T1 X T2",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: A language generating strings which are palindrome is not regular, thus cannot b represented using a finite automaton."
    },
    {
        "id": 495,
        "Question": "A turing machine has ____________ number of states in a CPU.",
        "Options": [
            "a) finite",
            "b) infinte",
            "c) May be finite",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A turing machine has finite number of states in its CPU. However, the states are not small in number. Real computer consist of registers which can store values (fixed number of bits)."
    },
    {
        "id": 496,
        "Question": "Suppose we have a simple computer with control unit holding a PC with a 32 bit address + Arithmetic unit holding one double length 64 bit Arithmetic Register. The number of states the finite machine will hold:",
        "Options": [
            "a) 2(32*64)",
            "b) 296",
            "c) 96",
            "d) 32"
        ],
        "Answer": "Answer: b\nExplanation: According to the statistics of the question, we will have a finite machine with 2^96 states."
    },
    {
        "id": 497,
        "Options": [
            "4. State true or false:",
            "Statement: We can use the finite control of turing machine to hold a finite amount of data.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: A move of a turing machine is the function of the state of finite control and the tape symbol just scanned."
    },
    {
        "id": 498,
        "Question": "A multi track turing machine can described as a 6-tuple (Q, X, S, d, q0, F) where X represents:",
        "Options": [
            "a) input alphabet",
            "b) tape alphabet",
            "c) shift symbols",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation:\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2017/06/automata-theory-questions-answers-programming-techniques-storage-subroutines-q3.png\" alt=\"Find the move of turing machine will from the given diagram\" width=\"492\" height=\"163\" class=\"aligncenter size-full wp-image-145247\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2017/06/automata-theory-questions-answers-programming-techniques-storage-subroutines-q3.png 492w, https://www.sanfoundry.com/wp-content/uploads/2017/06/automata-theory-questions-answers-programming-techniques-storage-subroutines-q3-300x99.png 300w\" sizes=\"(max-width: 492px) 100vw, 492px\" />\nThe finite control not only contains state q but also three data, A, B, C. The following technique requires no extension to the Turing Machine model. Shaping states this way allows to describe transitions in more systematic way and often to simplify the strategy of the program."
    },
    {
        "id": 499,
        "Question": "Which of the following statements are false?",
        "Options": [
            "a) A multi track turing machine is a special kind of multi tape turing machine",
            "b) 4-heads move independently along 4-tracks in standard 4-tape turing machine",
            "c) In a n-track turing machine, n head reads and writes on all the tracks simultaneously.",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Cartesian product works like a struct in C/C++. For Example: Computer tape storage is something like 8 or 9 bits in each cell. One can recognize a multi track tape machine by looking at the transitions because each will have tuples as the read and write symbols."
    },
    {
        "id": 500,
        "Question": "",
        "Options": [
            "8. State true or false:",
            "Statement: Two track turing machine is equivalent to a standard turing machine.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: The 6-tuple (Q, X, S, d, q0, F)  can be explained as:\nQ represents finite set of states,\nX represents the tape alphabet,\nS represents the input alphabet\nd represents the relation on states and the symbols\nq0 represents the initial state\nF represents the set of final states."
    },
    {
        "id": 501,
        "Question": "Which of the following is/are not true for recursively enumerable language?",
        "Options": [
            "a) partially decidable",
            "b) Turing acceptable",
            "c) Turing Recognizable",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: In a n-track turing machine, one head reads and writes on all the tracks simultaneously."
    },
    {
        "id": 502,
        "Question": "According to Chomsky hierarchy, which of the following is adopted by Recursively Ennumerable language?",
        "Options": [
            "a) Type 0",
            "b) Type 1",
            "c) Type 2",
            "d) Type 3"
        ],
        "Answer": "Answer: a\nExplanation: This can be generalized for n- tracks and can be proved equivalent using ennumerable languages."
    },
    {
        "id": 503,
        "Question": "A turing machine with several tapes in known as:",
        "Options": [
            "a) Multi-tape turing machine",
            "b) Poly-tape turing maching",
            "c) Universal turing machine",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A multitape turing machine is an ordinary turing machine with multiple tapes. Each tape has its own head to control the read and write."
    },
    {
        "id": 504,
        "Question": " A multitape turing machine is ________ powerful than a single tape turing machine.",
        "Options": [
            "a) more",
            "b) less",
            "c) equal",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The multitape turing machine model seems much powerful than the single tape model, but any multi tape machine, no matter how many tapes, can be simulated by single taped TM."
    },
    {
        "id": 505,
        "Question": "In what ratio, more computation time is needed to simulate multitape turing machines using single tape turing machines?",
        "Options": [
            "a) doubly",
            "b) triple",
            "c) quadratically",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Thus, multitape turing machines cannot calculate any more functions than single tape machines."
    },
    {
        "id": 506,
        "Question": "Which of the following is true for two stack turing machines?",
        "Options": [
            "a) one read only input",
            "b) two storage tapes",
            "c) one read only input & two storage tapes",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Two-stack Turing machines have a read-only input and two storage tapes. If a head moves left on either tape a blank is printed on that tape, but one symbol from a “library” can be printed."
    },
    {
        "id": 507,
        "Question": "Which of the following is not a Non deterministic turing machine?",
        "Options": [
            "a) Alternating Turing machine",
            "b) Probabalistic Turing machine",
            "c) Read-only turing machine",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: A read only turing machine or 2 way deterministic finite automaton is a class of model of computability that behaves like a turing machine, and can move in both directions across input, except cannot write to its input tape."
    },
    {
        "id": 508,
        "Question": "Which of the turing machines have existential and universal states?",
        "Options": [
            "a) Alternating Turing machine",
            "b) Probalistic Turing machine",
            "c) Read-only turing machine",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: ATM is divide into two sets: an existential state is accepting if some transitions leads to an accepting state; an universal state is accepting if every transition leads to an accepting state."
    },
    {
        "id": 509,
        "Question": "Which of the following is false for Quantum Turing machine?",
        "Options": [
            "a) Abstract machine",
            "b) Any quantum algorithm can be expressed formally as a particular quantum turing machine",
            "c) Gives a solution to ‘Is a universal quantum computer sufficient’",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: ‘Is a universal quantum computer sufficient’ is one of the unsolved problem from physics."
    },
    {
        "id": 510,
        "Question": "A deterministic turing machine is:",
        "Options": [
            "a) ambiguous turing machine",
            "b) unambiguous turing machine",
            "c) non-deterministic",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: A deterministic turing machine is unambiguous and for every input, there is exactly one operation possible. It is a subset of non-deterministic Turing machines."
    },
    {
        "id": 511,
        "Question": "Which of the following is true about Turing’s a-machine?",
        "Options": [
            "a) a stands for automatic",
            "b) left ended, right end-infinite",
            "c) finite number of tape symbols were allowed",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Turings a- machine or automatic machine was left ended,right end infinite.Any of finite number of tape symbols were allowed and the 5 tuples were not in order."
    },
    {
        "id": 512,
        "Question": "Which of the following is a multi tape turing machine?",
        "Options": [
            "a) Post turing Machine",
            "b) Wang-B Machine",
            "c) Oblivious turing Machine",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: An oblivious turing machine where movements of various heads are fixed functions of time, independent of the input. Pippenger and Fischer showed that any computation that can be performed by a multi-tape Turing machine in n steps can be performed by an oblivious two-tape Turing machine in O(n log n) steps."
    },
    {
        "id": 513,
        "Question": "Which of the following are related to construction of One Tape turing machines?",
        "Options": [
            "a) JFLAP",
            "b) NFLAP",
            "c) All of the mm",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: JFLAP is educational software written in java to experiment with the topics in automata theory and area of formal languages."
    },
    {
        "id": 514,
        "Question": "Which of the following topics cannot be covered using JFLAPS?",
        "Options": [
            "a) L-System",
            "b) Unrestricted Grammar",
            "c) Regular Expression",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Topics like regular expressions, context free languages and unrestricted grammar including parsers like LL,SLR parsers can be covered using JFLAPS."
    },
    {
        "id": 515,
        "Options": [
            "3. State true or false:",
            "Statement: Multitape turing machine have multi tapes where each tape is accessed with one head.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: Multitape turing machines do have multiple tapes but they they are accessed by separate heads."
    },
    {
        "id": 516,
        "Question": "Which of the following statements is/are true?",
        "Options": [
            "a) Every multitape turing machine has its equivalent single tape turing machine",
            "b) Every multitape turing machine is not an abstract machine",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A multitape turing machine is an ordinary turing machine which is always abstract.And they do have their equivalent single tape turing machines."
    },
    {
        "id": 517,
        "Question": "Are Multitape and Multitrack turing machines same?",
        "Options": [
            "a) Yes",
            "b) No",
            "c) Somewhat yes",
            "d) Cannot tell"
        ],
        "Answer": "Answer: a\nExplanation: Multitrack turing machines are special types of Multitape turing machines. In a standard n-tape Turing machine, n heads move independently along n-tracks."
    },
    {
        "id": 518,
        "Question": "In a n-track turing machine, _________ head/heads read and write on all tracks simultaneously.",
        "Options": [
            "a) one",
            "b) two",
            "c) n",
            "d) infinite"
        ],
        "Answer": "Answer: a\nExplanation: In a n-track Turing machine, one head reads and writes on all tracks simultaneously. A tape position in a n-track Turing Machine contains n symbols from the tape alphabet."
    },
    {
        "id": 519,
        "Question": "Which of the following does not exists?",
        "Options": [
            "a) Turing Machine with Multiple heads",
            "b) Turing Machine with infinite tapes",
            "c) Turing machine with two dimensional tapes",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All of the mentioned are one or the other kind of Turing machines in existence."
    },
    {
        "id": 520,
        "Question": "Every language accepted by a k-tape TM is _____ by a single-tape TM.",
        "Options": [
            "a) accepted",
            "b) not accepted",
            "c) generated",
            "d) not generated"
        ],
        "Answer": "Answer: b\nExplanation: One needs a finite number of tapes. The proofs that show the equivalence between multi-tape TM and one-band TM rely on the fact that the number of tapes is bounded."
    },
    {
        "id": 521,
        "Question": "Which of the following is/are a basic TM equivalent to?",
        "Options": [
            "a) Multitrack TM",
            "b) Multitape TM",
            "c) Non-deterministic TM",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Its the theorem that states Every multitape turing machine can be simulated by a single tape turing machine and the corresponding language can be accepted."
    },
    {
        "id": 522,
        "Question": "Which of the following is/are not an application of turing machine?",
        "Options": [
            "a) Language Recognization",
            "b) Computers of functions on non negative numbers",
            "c) Generating devices",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Turing machine is known as universal computer. It is denoted by M=(Q,Σ,Ґ ,δ ,q0, B,F)"
    },
    {
        "id": 523,
        "Options": [
            "3. State true or false:",
            "Statement: Turing Machine can change symbols on its tape, whereas the FA cannot change symbols on tape.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: A turing machine can have many applications like : Enumerator (A turing machine with an output printer), function computer, etc."
    },
    {
        "id": 524,
        "Question": "Which of the following cannot be a possibility of a TM while it processes an input?",
        "Options": [
            "a) Enters accepting state",
            "b) Enters non-accepting state",
            "c) Enters infinite loop and never halts",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The following mentioned is the difference between 2-way FA and TM. Another instance is that TM has a read/write tape head while FA doesn’t."
    },
    {
        "id": 525,
        "Question": "Pick the odd one out.",
        "Options": [
            "a) Subroutines",
            "b) Multiple tracks",
            "c) Shifting over",
            "d) Recursion"
        ],
        "Answer": "Answer: d\nExplanation: The following mentioned are the only possibilities of operating a string through a turing machine."
    },
    {
        "id": 526,
        "Question": "Which among the following is not true for 2-way infinte TM?",
        "Options": [
            "a) tape in both directions",
            "b) Leftmost square not distinguished",
            "c) Any computation that can be performed by 2-way infinite tape can also be performed by standard TM.",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Except Recursion, all the other options are techniques of Turing Machine construction which further includes, Checking off symbols and Storage in finite control."
    },
    {
        "id": 527,
        "Question": "Which of the following does not exists?",
        "Options": [
            "a) Mutitape TM",
            "b) Multihead TM",
            "c) Multidimentional TM",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All of the mentioned are correct statements for a two way infinite tape turing machine. Theorems say the power of such a machine is in no way superior than a standard turing machine."
    },
    {
        "id": 528,
        "Question": "Enumerator is a turing machine with __________",
        "Options": [
            "a) an output printer",
            "b) 5 input tapes",
            "c) a stack",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A turing machine can be used as a transducer. The most obvious way to do this is to treat the entire non blank portion of the initial tape as input, and to treat the entire blank portion of the tape when the machine halts as output. "
    },
    {
        "id": 529,
        "Question": "Can a single tape turing machine be simulated using deterministic 2-stack turing machine?",
        "Options": [
            "a) Yes",
            "b) No",
            "c) Cannot be said",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The symbols to left of the head of turing macine being simulated can be stored on the stack while the symbols on the right of the head can be placed on another stack. On each stack, symbols closer to the TM’s head are placed closer to the top of the stack than symbols farther from the TM’s head."
    },
    {
        "id": 530,
        "Question": "A ___________ is a multi tape turing machine whose input tape is read only.",
        "Options": [
            "a) Counter Machine",
            "b) Multi-stack",
            "c) Alternating Turing machine",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Counter machines are offline(a multitape turing machine whose input is read only) whose storage tapes are semi-infinite and whose tape symbols contains only two symbols Z and a blank symbol B."
    },
    {
        "id": 531,
        "Question": "Instantaneous description of a counter machine can be described using:",
        "Options": [
            "a) the input tape contents",
            "b) position of the input head",
            "c) distance of storage heads from symbol Z",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Instantaneous description of a counter machine can be described by the state, the input tape contents, the position of input head, and the distance of storage heads from the symbol Z. The counter machine can really store a count on each tape and tell if the count is zero."
    },
    {
        "id": 532,
        "Question": "Which of the following parameters cannot be used to restrict a turing machine?",
        "Options": [
            "a) tape alphabets",
            "b) number of tapes",
            "c) number of states",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Another procedure to restrict a turing machine is to limit the size of tape alphabet or reduce the number of states. If the tape alphabets, number of tapes or number of states are limited, then there is only a finite number of different turing machine, so the restricted model is more powerful than the original one."
    },
    {
        "id": 533,
        "Question": "Linear Bounded Automaton is a:",
        "Options": [
            "a) Finite Automaton",
            "b) Turing Machine",
            "c) Push down Automaton",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Linear Bounded Automaton is a type of Turing Machine where tape is not allowed to move off the portion of the tape containing the input. It is a Turing machine with limited amount of memory."
    },
    {
        "id": 534,
        "Options": [
            "6. State true or false:",
            "Statement: Using a two track tape, we can use a semi infinite tape to simulate an infinte tape.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: A TM with a semi-infinite tape means that there are no cells to the left of the initial head position. A TM with a semi infinite tape simulates a TM with an infinite tape by using a two-track tape."
    },
    {
        "id": 535,
        "Question": "Which of the following is true with reference to semi-infinite tape using a two track tape?",
        "Options": [
            "a) Can simulate a two way tape",
            "b) Upper track represents the head-right cells",
            "c) Lower track represents the head-left cells",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The upper track represents the cells of the original TM that are at the right of the initial head position. The lower track represents the cells to the left of the initial head position, but in reverse order."
    },
    {
        "id": 536,
        "Question": "A two-way infinite tape turing machine is ________ superior than the basic model of the turing machine in terms of power.",
        "Options": [
            "a) more",
            "b) less",
            "c) no way",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Both the statements are true. Both the statements are properties of Multistack machines."
    },
    {
        "id": 537,
        "Question": "For a basic turing machine, there exists an equivalent :",
        "Options": [
            "a) 2-counter machine",
            "b) 3-counter machine",
            "c) 4-counter machine",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: A two way infinite tape turing machine is a turing machine with its input tape infinte in both directions, the other component being the same  as the basic model."
    },
    {
        "id": 538,
        "Question": "Give a classic example of the concept of turing complete.",
        "Options": [
            "a) lambda calculus",
            "b) C++",
            "c) Lisp",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Computationally Universal or Turing Complete is a set of data manipulation rules if it can be used to simulate a single-taped turing machine."
    },
    {
        "id": 539,
        "Question": "Let two machines be P and Q. The state in which P can simulate Q and Q can simulate P is called:",
        "Options": [
            "a) Turing Equivalence",
            "b) State Equivalence",
            "c) Universal Turing Machine",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Most of the programming languages, conventional or unconventional are turing complete. Functional languages like Lisp and Haskell are also turing complete."
    },
    {
        "id": 540,
        "Question": "Which of the following can be used to simulate any turing machine?",
        "Options": [
            "a) Finite State Automaton",
            "b) Universal Turing Machine",
            "c) Counter machines",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: It is a closely related concept with Turing complete. It says, two computers P and Q are called equivalent if P can simulate Q and Q can simulate P."
    },
    {
        "id": 541,
        "Options": [
            "6. State true or false:",
            "Statement: Inorder to show something is Turing complete, it is enough to demonstrate that it can be used to simulate some Turing complete system.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: c\nExplanation: The following conclusion is laid down from the Church-Turing thesis:\nAny function whose values can be computed by an algorithm, can be computed by a Turing machine. If any real world computer can be simulated by a turing machine, it is Turing equivalent to a Turing Machine."
    },
    {
        "id": 542,
        "Question": "Which of the following can lack in a Universal computer?",
        "Options": [
            "a) Turing Complete Instruction set",
            "b) Infinite memory",
            "c) Infinite time",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The computational aspect of any possible real world computer can be simulated using an Universal Turing Machine so can be any turing machine."
    },
    {
        "id": 543,
        "Question": "Which among are not the results of computational theory?",
        "Options": [
            "a) In general, it is impossible to predict that what a Turing-complete program will do over an arbitrarily long time",
            "b) It is impossible to determine for every input, whether the program will eventually stop or continue forever",
            "c) It is not possible to determine whether a program will return true or false",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Yes it is. For instance, an imperative language is called Turing complete if it tends to have conditional branching and an ability to maintain an arbitrary number of symbols."
    },
    {
        "id": 544,
        "Question": "Which of the games fill under the category of Turing-complete?",
        "Options": [
            "a) Minecraft",
            "b) Minesweeper",
            "c) Dwarf Fortress",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Real computers which are manufactured till date, all are similar to single taped turing machine. However, they have limited physical resources so they are linearly bounded complete on the contrary."
    },
    {
        "id": 545,
        "Question": "Which of the following a Non-turing Complete language?",
        "Options": [
            "a) Regular Language",
            "b) Context free grammars",
            "c) Epigram",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All of the following mentioned are the conclusions of automata theory or computability theory."
    },
    {
        "id": 546,
        "Question": "Which of the following technique is used to find whether a natural language isn’t recursive enumerable?",
        "Options": [
            "a) Diagonalization",
            "b) Recursive Induction",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: To find a non recursively enumerable language, we use the technique of diagonalization."
    },
    {
        "id": 547,
        "Question": "Diagonalization can be useful in:",
        "Options": [
            "a) To find a non recursively enumerable language",
            "b) To prove undecidability of  haltig problem",
            "c) To find a non recursively enumerable language & also proves undecidability of haltig problem",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Diagonalization is a technique we use for the following operations:\na) To find a non recursively enumerable language.\nb) To prove undecidability of  halting problem."
    },
    {
        "id": 548,
        "Question": "Which of the following are undecidable problems?",
        "Options": [
            "a) Determining whether two grammars generate the same language",
            "b) Determining whether a grammar is ambiguous",
            "c) Determining whether a grammar is ambiguous and two grammars generate the same language",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: In contrast we can put up an algorithm for checking whether two FA’s are equivalent and this program can be implemented as a program."
    },
    {
        "id": 549,
        "Question": "Which of the following are incorrect options?",
        "Options": [
            "a) Informally, problem is a yes/no question about an infinite set of possible instances",
            "b) Formally, a problem is a language",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Example: Does a graph G has a Hamilton cycle?\n=>Each undirected graph is an instance of Hamilton cycle problem."
    },
    {
        "id": 550,
        "Question": "If a problem has an algorithm to answer it, we call it _________",
        "Options": [
            "a) decidable",
            "b) solved",
            "c) recognizable",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: An algorithm is a TM that halts on all inputs,accepted or not. Putting other way, decidable problems are recursive languages."
    },
    {
        "id": 551,
        "Question": "Which of the following are decidable problems?",
        "Options": [
            "a) Can a particular line of code in a program ever be executed?",
            "b) Do two given CFG’s generate the same language",
            "c) Is a given CFG ambiguous?",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All of the mentioned problems are undecidable."
    },
    {
        "id": 552,
        "Question": "Which of the following are correct statements?",
        "Options": [
            "a) TMs that always halt are known as Decidable problems",
            "b) TMs are not guaranteed to halt only on acceptance are recursive enumerable",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: We can proof A to be undecidable using the contradiction method."
    },
    {
        "id": 553,
        "Question": "Statement: If L id R.E., Lc needs to be R.E. Is it correct?",
        "Options": [
            "a) Yes",
            "b) No",
            "c) Maybe",
            "d) Cannot predict"
        ],
        "Answer": "Answer: a\nExplanation: There are two types of TMs on the basis of halting: Recursive and Recursively Enumerable(TM may or may not halt, could loop forever)."
    },
    {
        "id": 554,
        "Question": "Which of the following is true for The Halting problem?",
        "Options": [
            "a) It is recursively enumerable",
            "b) It is undecidable",
            "c) It is recursively enumerable and undecidable",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Any recursive enumerable language is not closed under complementation."
    },
    {
        "id": 555,
        "Options": [
            "11. With reference to binary strings, state true or false:",
            "Statement: For any turing machine, the input alphabet is restricted to {0,1}.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: c\nExplanation: Halting problem: Does a given Turing machine M halt on a given input w?"
    },
    {
        "id": 556,
        "Question": "With reference to enumeration of binary strings, the conversion of binary strings to integer is possible by treating the resulting string as a base ____ integer.",
        "Options": [
            "a) 2",
            "b) 8",
            "c) 16",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: When turing machines are coded as Binary strings, we are restricted to take any input alphabet except {0,1}."
    },
    {
        "id": 557,
        "Question": "The decision problem is the function from string to ______________",
        "Options": [
            "a) char",
            "b) int",
            "c) boolean",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The decision problem requires checking of input (string) has some property or not. That is a string to boolean transaction."
    },
    {
        "id": 558,
        "Question": "A language L is said to be ____________ if there is a turing machine M such that L(M)=L and M halts at every point.",
        "Options": [
            "a) Turing acceptable",
            "b) decidable",
            "c) undecidable",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Decidability refers to the decision problem and existence of a effective method for determining membership, and return true and false accordingly rather that going into a loop forever."
    },
    {
        "id": 559,
        "Question": " Which among the following are undecidable theories?",
        "Options": [
            "a) The first order theory of boolean algebra",
            "b) The first order theory of Euclidean geomentry",
            "c) The first order theory of hyperbolic geometry",
            "d) The first order theory of the natural number with addition, multiplication, and equality"
        ],
        "Answer": "Answer: d\nExplanation: Tarski and Mostowski in 1949, established that the first order theory of natural numbers with addition, multiplication, and equality is an undecidable theory. Others mentioned are decidable theories."
    },
    {
        "id": 560,
        "Question": "Which among the following are semi decidable?",
        "Options": [
            "a) Empty-DFA",
            "b) Rec-NFA",
            "c) Infinite-DFA",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Under decidablity of regular language properties we have the following lemma which states that A DFA which recognizes an input w is decidable."
    },
    {
        "id": 561,
        "Question": "The language accepted by a turing machine is called ____________",
        "Options": [
            "a) Recursive Ennumerable",
            "b) Recursive",
            "c) Recursive Ennumerable and Recursive",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All are the properties of regular languages and all are decidable languages."
    },
    {
        "id": 562,
        "Question": "Decidable can be taken as a synonym to:",
        "Options": [
            "a) recursive",
            "b) non recursive",
            "c) recognizable",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The language accepted by Turing machines are called recursively ennumerable (RE), and the subset of RE languages that are accepted by a turing machine that always halts are called recursive."
    },
    {
        "id": 563,
        "Question": "The problems which have no algorithm, regardless of whether or not they are accepted by a turing machine that fails to halts on some input are referred as:",
        "Options": [
            "a) Decidable",
            "b) Undecidable",
            "c) Computable",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: We can refer to languages as ‘recursive’ and problems as ‘decidable’. If a language is not recursive, then we call the problem expressed by that language undecidable."
    },
    {
        "id": 564,
        "Question": "An algorithm is called efficient if it runs in ____________ time on a serial computer.",
        "Options": [
            "a) polynomial",
            "b) non polynomial",
            "c) logarithmic",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: The problems that can be solved by a turing machine can divided into two classes:\na) Those that have an algorithm\nb) Intractable problems: Those that are only solved by a turing machine that may run forever on inputs they do not accept.\n"
    },
    {
        "id": 565,
        "Question": " A problem is called __________ if its has an efficient algorithm for itself.",
        "Options": [
            "a) tractable",
            "b) intractable",
            "c) computational",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Example: Runtimes of efficient algorithms\nO(n), O(nlogn), O(n3log2n)\nRuntimes of inefficient algorithms\nO(2n), O(n!)\n"
    },
    {
        "id": 566,
        "Question": "A formal language is recursive if :",
        "Options": [
            "a) a total turing machine exists",
            "b) a turing machine that halts for every input",
            "c) turing machine rejects if the input does not belong to the language",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A problem is called intractable if there is an efficient (i.e. polynomial time) algorithm that solves it. A problem is called intractable if there exists no efficient algorithm that solves it."
    },
    {
        "id": 567,
        "Question": "Recursive languages are also known as:",
        "Options": [
            "a) decidable",
            "b) undecidable",
            "c) sometimes decidable",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: A formal language is called recursive if it is a recursive subset of the set of all possible finite sequences over the alphabet of the language."
    },
    {
        "id": 568,
        "Question": "The class of recursive language is known as:",
        "Options": [
            "a) R",
            "b) RC",
            "c) RL",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A language is recursive if there exists a turing machine such that it halts i.e. accepts if the input belongs to the language else rejects. It is better called Turing decidable language."
    },
    {
        "id": 569,
        "Question": "Which of the following was not a part of Chomsky hierarchy?",
        "Options": [
            "a) Context sensitive grammar",
            "b) Unrestricted grammar",
            "c) Recursive grammar",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: R is the set of all recursive languages, a class of decision problems solvable by turing machines. Although, R is also used for the class RP."
    },
    {
        "id": 570,
        "Question": "According to the rice’s theorem, If P is a non trivial property, Lp is :",
        "Options": [
            "a) infinite",
            "b) decidable",
            "c) undecidable",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Rice’s theorem states that ‘Any non trivial property about the language recognized by a turing machine is undecidable’."
    },
    {
        "id": 571,
        "Question": "Which of the following set of computable functions are decidable?",
        "Options": [
            "a) The class of computable functions that are constant, and its complement",
            "b) The class of indices for computable functions that are total",
            "c) The class of indices for recursively enumerable sets that are cofinite",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A property of partial functions is called trivial if it holds for all partial computable functions or for none, and an effective decision method is called general if it decides correctly for every algorithm."
    },
    {
        "id": 572,
        "Question": "Post Correspondence problem is",
        "Options": [
            "a) decidable decision problem",
            "b) undecidable decision problem",
            "c) not a decision problem",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: According to rice theorem, it is undecidable to determine whether the language recognized by an arbitrary turing machine lies in S."
    },
    {
        "id": 573,
        "Options": [
            "7. State true or false:",
            "Statement: The difference between PCP and MPCP is that in MPCP, a solution is required to start with the first string on each list.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: d\nExplanation: According to Rice’s theorem, if there exists atleast one computable function in a particular class C of computable functions and another computable function not in C then the problem deciding whether a particular program computes a function in C is undecidable."
    },
    {
        "id": 574,
        "Question": "PCP stands for?",
        "Options": [
            "a) Post Correspondence Problem",
            "b) Post Corresponding Problem",
            "c) Pre Correspondence problem",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: All of the following mentioned are immediate results of Rice’s theorem and thus, undecidable."
    },
    {
        "id": 575,
        "Question": "Consider three decision problem A, B, C. A is decidable and B is not. Which of the following is a correct option?",
        "Options": [
            "a) C is undecidable if C is reducible to B",
            "b) C is undecidable if B is reducible to C",
            "c) C is decidable if A is reducible to C",
            "d) C is decidable if C is reducible to B’s complement."
        ],
        "Answer": "Answer: b\nExplanation: Post Correspondence problem is an undecidable decision problem that was introduced by Emil Post in 1946. Being simpler than halting problem, it can be used in proofs of undecidability.\n"
    },
    {
        "id": 576,
        "Question": "If the number of steps required to solve a problem is O(nk), then the problem is said to be solved in:",
        "Options": [
            "a) non-polynomial time",
            "b) polynomial time",
            "c) infinite time",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Most of the operations like addition, subtraction, etc as well as computing functions including powers, square roots and logarithms can be performed in polynomial time. In the given question, n is the complexity of the input and k is some non negative integer."
    },
    {
        "id": 577,
        "Question": "The value of constants like p and e can be calculated in:",
        "Options": [
            "a) polynomial time",
            "b) non-polynomial time",
            "c) cannot be calculated",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The value of such constants can be calculated using algorithms which have time complexity in terms if O(nk) i.e polynomial time."
    },
    {
        "id": 578,
        "Question": "Which of the following cannot be solved using polynomial time?",
        "Options": [
            "a) Linear Programming",
            "b) Greatest common divisor",
            "c) Maximum matching",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: In graph theory, a matching or independent edge set in a graph G is a set of edges without common vertices. Given a graph (V, E), a matching  M in G is a set of pairwise non adjacent edges i.e. no two edges share a common vertex."
    },
    {
        "id": 579,
        "Question": "The complexity class P consist of all the decision problems that can be solved by ___________using polynomial amount of computation time.",
        "Options": [
            "a) Push Down automata",
            "b) DFA",
            "c) NDFA",
            "d) Deterministic Turing machine"
        ],
        "Answer": "Answer: d\nExplanation: All the decision problems that can be solved using a Deterministic turing machine using polynomial time to compute, all belong to the complexity class P."
    },
    {
        "id": 580,
        "Question": "A generalization of P class can be:",
        "Options": [
            "a) PTIME",
            "b) DTIME",
            "c) NP",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: P is a specific case of NP class, which is the class of decidable problems decidable by a non deterministic turing machine that runs in polynomial time."
    },
    {
        "id": 581,
        "Question": "Which of the following options are correct with reference to P-complete problems?",
        "Options": [
            "a) used for the problems which are difficult to solve in limited space",
            "b) every problem in P can be reduced to it using proper reductions",
            "c) complete problem for complexity class P",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation:\nThe notion of P-complete decision problems is useful in the analysis of:\ni) which problems are tough to parallelize effectively\nii) which problems are difficult to solve in limited space"
    },
    {
        "id": 582,
        "Question": "A problem X belongs to P complexity class if there exist ________ algorithm to solve that problem, such that the number of steps of the algorithms bounded by a polynomial in n, where n is the length of the input.",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) all of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: A problem X belongs to P complexity class if there exist atleast 1 algorithm to solve that problem, such that the number of steps of the algorithms bounded by a polynomial in n, where n is the length of the input. Thus, all the options are correct."
    },
    {
        "id": 583,
        "Question": "Which of the following is a P-complete type of problem?",
        "Options": [
            "a) Circuit Value problem",
            "b) Linear programming",
            "c) Context free grammar membership",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Given a context free grammar and a string, can the string be generated by the grammar? Such problems fall in the category of P-complete."
    },
    {
        "id": 584,
        "Question": "State true or false?",
        "Options": [
            "Statement: Given a turing machine, an input for the machine, and a number T(unary), does that machine halt on that input within the first T-steps?",
            "The given problem is P-complete.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: If we can parallelize a general simulation of a sequential computer, then we will be able to parallelize any program that runs on that computer. If this problem is in NC, then so every other problem in P."
    },
    {
        "id": 585,
        "Question": "In the above problem, if the input is binary, the class the problem belongs?",
        "Options": [
            "a) EXPSPACE",
            "b) DLOGTIME",
            "c) EXPTIME-complete",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: It is the set of all decision problems that have exponential run time i.e. solvable by deterministic turing machine in O(2p(n)) time, where p(n) is a polynomial function of n."
    },
    {
        "id": 586,
        "Question": "What does NP stands for in complexity classes theory?",
        "Options": [
            "a) Non polynomial",
            "b) Non-deterministic polynomial",
            "c) All of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: NP is said to be one of the most fundamental complexity classes. NP is an acronym for   Non deterministic polynomial time."
    },
    {
        "id": 587,
        "Question": "The hardest of NP problems can be:",
        "Options": [
            "a) NP-complete",
            "b) NP-hard",
            "c) P",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: NP class contains many important problems, the hardest of which is NP-complete, whose solution is sufficient to deal with any other NP problem in polynomial time."
    },
    {
        "id": 588,
        "Question": "Which of the following contains NP?",
        "Options": [
            "a) PSPACE",
            "b) EXPSPACE",
            "c) Both PSPACE and EXPSPACE",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: It is sufficient to construct a PSPACE machine that loops over all proof strings and feeds each one to a polynomial time verifier. It is also contained in EXPTIME, since the same algorithm operates in exponential time."
    },
    {
        "id": 589,
        "Question": "Travelling sales man problem belongs to which of the class?",
        "Options": [
            "a) P",
            "b) NP",
            "c) Linear",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Travelling Salesman Problem: Given an input matrix of distances between n cities, this problem is to determine if there is a route visiting all cities with total distance less than k."
    },
    {
        "id": 590,
        "Options": [
            "5. State true or false?",
            "Statement: If a problem X is in NP and a polynomial time algorithm for X could also be used to solve problem Y in polynomial time, then Y is also in NP.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: This is just a commutative property of NP complexity class where a problem is said to be in NP if it can be solved using an algorithm which was used to solve another NP problem in polynomial amount of time."
    },
    {
        "id": 591,
        "Question": "A problem which is both _______ and _________ is said to be NP complete.",
        "Options": [
            "a) NP, P",
            "b) NP, NP hard",
            "c) P, P complete",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: A problem is said to be NP Hard if an algorithm for solving the problem can be translated from for solving any other problem. It is easier to show a problem NP than showing it Np Hard."
    },
    {
        "id": 592,
        "Question": "In terms of NTIME, NP problems are the set of decision problems which can be solved using a non deterministic machine in _______ time.",
        "Options": [
            "a) O(n)",
            "b) O(n1/2)",
            "c) O(nk), k∈N",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation:  Primality testing is a simple example. To decide whether a number is prime or not, one simply selects non deterministically a number checks whether factors exist for the number or not."
    },
    {
        "id": 593,
        "Question": "Which of the following can be used to define NP complexity class?",
        "Options": [
            "a) Verifier",
            "b) Polynomial time",
            "c) Both Verifier and Polynomial time",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The complexity class NP can be defined in terms of NTIME as:\nNP=O(nk) for k ∈N."
    },
    {
        "id": 594,
        "Question": "Which of the following are not in NP?",
        "Options": [
            "a) All problems in P",
            "b) Boolean Satisfiability problems",
            "c) Integer factorization problem",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: NP can be defined using deterministic turing machines as verifiers."
    },
    {
        "id": 595,
        "Question": "Which of the following does not belong to the closure properties of NP class?",
        "Options": [
            "a) Union",
            "b) Concatenation",
            "c) Reversal",
            "d) Complement"
        ],
        "Answer": "Answer: d\nExplanation: This is a list of some problems which are in NP:\na) All problems in P\nb) Decision version of Integer factorization method\nc) Graph Isomorphism Problem\nd) All NP complete problems, etc."
    },
    {
        "id": 596,
        "Question": "Which of the given problems are NP-complete?",
        "Options": [
            "a) Node cover problems",
            "b) Directed Hamilton Circuit Problem",
            "c) Node cover problems & Directed Hamilton Circuit Problem",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Vertex cover or Node cover problem, and Hamilton Circuit problem, both are NP complete type of problems."
    },
    {
        "id": 597,
        "Question": "Which of the following problems do not belong to Karp’s 21 NP-complete problems?",
        "Options": [
            "a) Vertex Cover problems",
            "b) Knapsack",
            "c) 0-1 integer programming",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: There exists a set of 21 problems that are NP-complete and the set is called Karp’s 21 NP-complete problems."
    },
    {
        "id": 598,
        "Question": "Which of the following problems were reduced to Knapsack?",
        "Options": [
            "a) Exact Cover",
            "b) Max Cut",
            "c) 0-1 integer programming",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Exact cover is a decision problem in computer science to determine if an exact cover exists."
    },
    {
        "id": 599,
        "Question": "An exact cover problem can be represented using:",
        "Options": [
            "a) incidence matrix",
            "b) bipartite graph",
            "c) both incidence matrix and bipartite graph",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The relation ‘contains’ can be represented using a bipartite graph. The vertices of the graph can be divided into two disjoint sets, one representing the subset S and the other representing the elements of P and one edge for each subset in S;each node is included in exactly one of the edges forming the cover."
    },
    {
        "id": 600,
        "Question": "For which of the following, greedy algorithm finds a minimal vertex cover in polynomial time?",
        "Options": [
            "a) tree graphs",
            "b) bipartite graphs",
            "c) all of the mentioned",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: For bipartite graphs, Konigs theorem allows the bipartite vertex problem to be solved in polynomial time."
    },
    {
        "id": 601,
        "Question": "Hamilton circuit problem can have the following version/s as per the input graph:",
        "Options": [
            "a) directed",
            "b) undirected",
            "c) both directed and undirected",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Hamilton circuit problem is a problem determining whether a Hamiltonian path(a path in an undirected or directed graph that visits each vertex exactly once) exists in a graph(directed or undirected)."
    },
    {
        "id": 602,
        "Question": "Hamilton Circuit problem is a special case of ____________",
        "Options": [
            "a) travelling salesman problem",
            "b) halting problem",
            "c) hitting set",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Hamilton circuit problem is a special case of travelling salesman problem, obtained by setting the distance between two cities to one if they are adjacent and two otherwise, and verifying that the total distance travelled is equal to n (if so, the route is a Hamiltonian circuit; if there is no Hamiltonian circuit then the shortest route will be longer)."
    },
    {
        "id": 603,
        "Question": "Which of the following cannot solve Hamilton Circuit problem?",
        "Options": [
            "a) DNA Computer",
            "b) Monte Carlo algorithm",
            "c) Dynamic programming",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Using Inclusion-exclusion principle, Andreas showed how to solve Hamilton Circuit problem in arbitrary n-vertex graphs by a Monte Carlo algorithm in time O(1.657n)."
    },
    {
        "id": 604,
        "Options": [
            "9. State true or false:",
            "Statement: Hamiltonian cycles through any fixed edge is always even, so if one such cycle is given, the second one must also exists.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: Handshaking lemma states that ‘Every finite undirected graph has an even number of vertices  with odd degree."
    },
    {
        "id": 605,
        "Question": "Fibonacci number falls in the category of _________ combinatorics.",
        "Options": [
            "a) Algebric",
            "b) Enumerative",
            "c) Analytic",
            "d) Extremal"
        ],
        "Answer": "Answer: b\nExplanation: Enumerative combinatorics is the most classical area of combinatorics and concentrates on counting the number of certain combinatorial objects. Fibonacci series is a basic example of Enumerative Combinatorics."
    },
    {
        "id": 606,
        "Question": "All set of polynomial questions which can be solved by a turing machine using a polynomial amount of space:",
        "Options": [
            "a) PSPACE",
            "b) NPSPACE",
            "c) EXPSPACE",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: PSPACE is the problem class that contains all set of decision problems which can be solved using a turing machine taking polynomial amount of space."
    },
    {
        "id": 607,
        "Question": "PSPACE is strictly the super set of:",
        "Options": [
            "a) Regular language",
            "b) Context free language",
            "c) Context Sensitive Language",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Membership of a string in a language defined by an arbitrary context sensitive grammar, or by an arbitrary deterministic context sensitive grammar, is a PSPACE -complete problem."
    },
    {
        "id": 608,
        "Question": "Savitch theorem relates to which of the following:",
        "Options": [
            "a) PSPACE=NPSPACE",
            "b) Alternating Turing Machine",
            "c) Time complexity",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Some important conclusions of Savitch theorem includes:\na) PSPACE=NPSPACE: square of a polynomial function is still a polynomial function.\nb) NL∈L2"
    },
    {
        "id": 609,
        "Question": "The class PSPACE is closed under the following operations:",
        "Options": [
            "a) Union",
            "b) Concatenation",
            "c) Kleene",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: The closure property of PSPACE class includes :- Union, Concatenation and Kleene operation."
    },
    {
        "id": 610,
        "Options": [
            "7. Statement : All PSPACE problems can be reduced to PSPACE-complete problems.",
            "State true or false:",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: c\nExplanation: The given order is the only correct order and further PSPACE belongs to EXPTIME class and subsequently occurs EXPSPACE class."
    },
    {
        "id": 611,
        "Question": "Without needing extra __________ we can simulate non deterministic turing machine using deterministic turing machine.",
        "Options": [
            "a) time",
            "b) space",
            "c) both time and space",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: From space hierarchy theorem: NL ∈ NPSPACE, from Savitch’s theorem: NPSPACE= PSPACE."
    },
    {
        "id": 612,
        "Question": "Complement of all the problems in PSPACE is ________",
        "Options": [
            "a) PSPACE",
            "b) NL",
            "c) P",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: PSPACE-complete problems are the most difficult problems is PSPACE. Finding a simple solution to PSPACE-complete means simple solution to all other problems in PSPACE because all PSPACE problems can be reduced to PSPACE-complete problems."
    },
    {
        "id": 613,
        "Question": "Which of the following PSPACE can be characterized into?",
        "Options": [
            "a) APTIME",
            "b) AP",
            "c) Quantom complexity class",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: Though it may use extra time, but as PSPACE=NPSPACE from savitch’s theorem, we can say that space taken is same for both the machines, deterministic as well as non-deterministic."
    },
    {
        "id": 614,
        "Question": "A randomized algorithm uses random bits as input inorder to achieve a _____________ good performance over all possible choice of random bits.",
        "Options": [
            "a) worst case",
            "b) best case",
            "c) average case",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: A randomized algorithm is an algorithm that employs a degree of randomness as a part of its logic using random bits as inputs and in hope of producing average case good performace."
    },
    {
        "id": 615,
        "Question": "Which of the following are probalistic algorithms?",
        "Options": [
            "a) Las Vegas Algorithm",
            "b) Monte Carlo Algorithm",
            "c) Atlantic City Algorithm",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: The other type of algorithms are probabalistic algorithms, which depending upon the random input, have a chance of producing incorrect results or fail to produce a result."
    },
    {
        "id": 616,
        "Question": "Which of the following algorithms are probably correct as well as fast?",
        "Options": [
            "a) Las Vegas Algorithm",
            "b) Monte Carlo Algorithm",
            "c) Atlantic City Algorithm",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Monte Carlo algorithms are very vast, but only probably correct. On thr other side, Las  Vegas algorithms are always correct, but probably fast."
    },
    {
        "id": 617,
        "Question": "Prisonner’s dilemma can be related to the following:",
        "Options": [
            "a) cooperative behaviour",
            "b) graph theory",
            "c) all of the mentioned",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The atlantic city algorithms which are bounded polynomial time algorithms are probably correct and probably fast. It is correct more than 75% of the times."
    },
    {
        "id": 618,
        "Question": "Unix sort command uses _________ as its sorting technique.",
        "Options": [
            "a) Quick Sort",
            "b) Bucket Sort",
            "c) Radix Sort",
            "d) Merge Sort"
        ],
        "Answer": "Answer: a\nExplanation: Prisonner’s dilemma is a standard example of a game analysed in game theory where rational cooperative behaviour is judged on the basis of rewards and punishment."
    },
    {
        "id": 619,
        "Options": [
            "7. State true or false:",
            "Statement: A turing machine has the capability of using randomly ‘generated’ numbers.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: a\nExplanation: Quicksort is the method of choice in many applications( Unix sort command) with O(nlogn) in worst case."
    },
    {
        "id": 620,
        "Question": "8. For the given algorithm, find the probability of finding after k iterations:<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"txt\"><pre class=\"de1\">find_a(array A, n, k)\nbegin\n   i=0\n     repeat\n           Randomly select one element out of n elements\n           i=i+1\n     until i=k or a is found\nend</pre></div></div></div></div></div></div>",
        "Options": [
            "a) (1/2)k",
            "b) (1-(1/3))k",
            "c) 1-(1/2)k",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: a\nExplanation: Complexity theories models randomized algorithms as probalistic turing machines. A probalistic turing machine is a non deterministic turing machine which randomly chooses between the available transitions at each point according to some probalistic distribution."
    },
    {
        "id": 621,
        "Question": "Which of the following can be solved in computer science?",
        "Options": [
            "a) P=BPP problem",
            "b) NP=co-NP problem",
            "c) Do one way problems exist?",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: The given is known as Monte Carlo Algorithm. If a is fount, the algorithm succeeds, else the algorith fails. The algorithm doesn not guarantee success but the run time is bounded."
    },
    {
        "id": 622,
        "Question": "Which of the following can be referred to as applications of Randomized algorithm?",
        "Options": [
            "a) Quicksort",
            "b) Min Cut",
            "c) Verifying Matrix Multiplication",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: There exists a list of unsolved problems in computational theory which includes many problems including the ones given."
    },
    {
        "id": 623,
        "Question": "Which among the following is smallest for n=50",
        "Options": [
            "a) 2n2",
            "b) n2+3n+7",
            "c) n3",
            "d) 2n"
        ],
        "Answer": "Answer: b\nExplanation:\n2n2=5000\nn2+3n+7=2567\nn3=125000\n2n=1.13*1015\n"
    },
    {
        "id": 624,
        "Question": "The space complexity of a turing machine is undefined if:",
        "Options": [
            "a) It is a multitape turing machine",
            "b) If no string of length n causes T to use infinite number of tape squares",
            "c) If some input of length n causes T to loop forever",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: If there exists an input string of length n that causes T to use an infinite number of tape squares, the space complexity of the turing machine is undefined."
    },
    {
        "id": 625,
        "Question": "In order to reduce the run time of a turing machine:",
        "Options": [
            "a) we can reduce the number of tapes",
            "b) we can increase the number of tapes",
            "c) use infinite tapes",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: One way to reduce the run time can be to increase the number of tapes. Sometimes, using two tapes can be used to avoid back and forth motions altogether."
    },
    {
        "id": 626,
        "Question": "Which of the following are basic complexity classes for a function f:N->N?",
        "Options": [
            "a) Ntime(f)",
            "b) Nspace(f)",
            "c) Space(f)",
            "d) All of the mentioned"
        ],
        "Answer": "Answer: d\nExplanation: Ntime(f): is a set of languages that can be accepted by a NTM T with non deterministic time complexity function t <=f. In all four cases, the machines are allowed to be multitape TM’s."
    },
    {
        "id": 627,
        "Question": "A function f is called __________ if there exists a TM T so that for any n and any input string of length n, T halts in exactly f(n) moves.",
        "Options": [
            "a) Step function",
            "b) Step counting function",
            "c) Inplace functions",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: If f is a step counting function, T is a TM halting in f(n) moves where n is the length of input string."
    },
    {
        "id": 628,
        "Question": "Let f: N->N be a step counting function. Then for some constant C, Time(f) is a proper subset of Time(_______)",
        "Options": [
            "a) O(nf)",
            "b) O(n+f)",
            "c) O(n2f2)",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: Using the encoding function, it is possible to show that if the function f is a step counting function, then the function Cn2(f(n))2 is the total number of moves required."
    },
    {
        "id": 629,
        "Question": "Which of the following is not correct for ZPP?",
        "Options": [
            "a) zero error probabalistic polynomial time",
            "b) it runs in non-polynomial time",
            "c) it returns an answer yes, no or do not know",
            "d) none of the mentioned"
        ],
        "Answer": "Answer: c\nExplanation: f,g,h,k are partial functions and each is defined at all but a finite number of points."
    },
    {
        "id": 630,
        "Question": "ZPP is based on ________",
        "Options": [
            "a) Probabalistic turing machine",
            "b) Alternative turing machine",
            "c) Quantum turing machine",
            "d) None of the mentioned"
        ],
        "Answer": "Answer: b\nExplanation: ZPP is zero error probabalistic polynomial time complexity class which run in polynomial time, returns an answer: yes, no or do not know."
    },
    {
        "id": 631,
        "Question": "ZPP is exactly equal to the ____________of the classes RP and co-RP.",
        "Options": [
            "a) Union",
            "b) Intersection",
            "c) Concatenation",
            "d) Difference"
        ],
        "Answer": "Answer: a\nExplanation: A probabalistic turing machine is a non deterministic turing machine which randomly chooses between the available transitions at each point according to some probability distribution."
    },
    {
        "id": 632,
        "Options": [
            "12. State true or false:",
            "Statement:  ZPP is closed under complement function.",
            "a) true",
            "b) false"
        ],
        "Answer": "Answer: b\nExplanation: To prove the following statement, we need to take in note that every problem in RP and co-RP has a Las-Vegas algorithm."
    }
]