[
    {
        "id": 1,
        "Question": "Which one of the following offers CPUs as integrated memory or peripheral interfaces?",
        "Options": [
            "a) Microcontroller",
            "b) Microprocessor",
            "c) Embedded system",
            "d) Memory system"
        ],
        "Answer": "Answer: a\nExplanation: Microcontrollers are the CPUs which have integrated memory and peripherals but microprocessor possesses external chips for memory."
    },
    {
        "id": 2,
        "Question": "Which of the following offers external chips for memory and peripheral interface circuits?",
        "Options": [
            "a) Microcontroller",
            "b) Microprocessor",
            "c) Peripheral system",
            "d) Embedded system"
        ],
        "Answer": "Answer: b\nExplanation:  Microcontrollers are the CPUs which have integrated memory and peripherals whereas microprocessor offers external chips for memory."
    },
    {
        "id": 3,
        "Question": "How many bits does an MC6800 family have?",
        "Options": [
            "a) 16",
            "b) 32",
            "c) 4",
            "d) 8"
        ],
        "Answer": "Answer: d\nExplanation: MC6800 is an 8-bit processor proposed by Motorola."
    },
    {
        "id": 4,
        "Question": "Which of the following is a 4-bit architecture?",
        "Options": [
            "a) MC6800",
            "b) 8086",
            "c) 80386",
            "d) National COP series"
        ],
        "Answer": "Answer: d\nExplanation: National COP series is a 4-bit processor whereas MC6800 is an 8-bit processor, 8086 is a 16-bit processor and 80386 is a 32-bit processor."
    },
    {
        "id": 5,
        "Question": "What is CISC?",
        "Options": [
            "a) Computing instruction set complex",
            "b) Complex instruction set computing",
            "c) Complimentary instruction set computing",
            "d) Complex instruction set complementary"
        ],
        "Answer": "Answer: b\nExplanation: It is complementary to RISC architecture and has complex instruction set compared to RISC architecture."
    },
    {
        "id": 6,
        "Question": "How is the protection and security for an embedded system made?",
        "Options": [
            "a) OTP",
            "b) IPR",
            "c) Memory disk security",
            "d) Security chips"
        ],
        "Answer": "Answer: b\nExplanation: Intellectual property right provides security and protection to embedded systems."
    },
    {
        "id": 7,
        "Question": "Which of the following possesses a CISC architecture?",
        "Options": [
            "a) MC68020",
            "b) ARC",
            "c) Atmel AVR",
            "d) Blackfin"
        ],
        "Answer": "Answer: a\nExplanation: MC68020 is having a CISC architecture. CISC architecture is used for code efficiency whereas RISC architecture is used for speeding up the processor. ARC, Atmel AVR, and Blackfin are RISC architectures."
    },
    {
        "id": 8,
        "Question": "Which of the following is a RISC architecture?",
        "Options": [
            "a) 80286",
            "b) MIPS",
            "c) Zilog Z80",
            "d) 80386"
        ],
        "Answer": "Answer: b\nExplanation: MIPS possess a RISC architecture whereas 80386, 80286 and Zilog Z80 are  CISC architectures."
    },
    {
        "id": 9,
        "Question": "Which one of the following is board based system?",
        "Options": [
            "a) Data bus",
            "b) Address bus",
            "c) VMEbus",
            "d) DMA bus"
        ],
        "Answer": "Answer: c\nExplanation: VMEbus is Versa Module Europa Bus which is used as a board based system for easy manipulation. VMEbus is a computer bus standard developed for the Motorola MC6800 family and is mainly based on Eurocard sizes."
    },
    {
        "id": 10,
        "Question": "VME bus stands for",
        "Options": [
            "a) Versa module Europa bus",
            "b) Versa module embedded bus",
            "c) Vertical module embedded bus",
            "d) Vertical module Europa bus"
        ],
        "Answer": "Answer: a\nExplanation: A computer bus standard in Eurocard sizes mainly developed for Motorola MC6800 family and later on used in many applications and approved by IEEE."
    },
    {
        "id": 11,
        "Question": "It retains its content when power is removed. What type of memory is this?",
        "Options": [
            "a) Volatile memory",
            "b) Nonvolatile memory",
            "c) RAM",
            "d) SRAM"
        ],
        "Answer": "Answer: b\nExplanation: Nonvolatile devices are those which always retains it content even when any abrupt change occurs and nonvolatile memory are a kind of such devices. But RAM is a volatile memory which is primary storage that can only access its data only when the device is powered and SRAM is a type of RAM which is called Static RAM."
    },
    {
        "id": 12,
        "Question": "Name a volatile memory.",
        "Options": [
            "a) RAM",
            "b) EPROM",
            "c) ROM",
            "d) EEPROM"
        ],
        "Answer": "Answer: a\nExplanation: Volatile memory is those which can access data only when the device is powered."
    },
    {
        "id": 13,
        "Question": "Name a nonvolatile memory.",
        "Options": [
            "a) ROM",
            "b) RAM",
            "c) SRAM",
            "d) DRAM"
        ],
        "Answer": "Answer: a\nExplanation: Non-volatile memory is the one which retains its content even when the power is removed. This is done by an on-chip read only memory (ROM) or an external EPROM. The software that it contains the program which is capable of obtaining the full software from another source within or outside of the system. This initialisation routine is also referred to as a bootstrap program or routine."
    },
    {
        "id": 14,
        "Question": "The initial routine is often referred to as",
        "Options": [
            "a)  Initial program",
            "b) Bootstrap program",
            "c) Final program",
            "d) Initial embedded program"
        ],
        "Answer": "Answer: b\nExplanation: ROM contains the program which is capable of obtaining the full software from another source within or outside of the system. This initialisation routine is also referred to as bootstrap program or routine."
    },
    {
        "id": 15,
        "Question": "What kind of socket does an external EPROM to plugged in for prototyping?",
        "Options": [
            "a) Piggyback",
            "b) Single socket",
            "c) Multi-socket",
            "d) Piggyback reset socket"
        ],
        "Answer": "Answer: a\nExplanation: Some controllers use a special package called piggyback socket on the top of the package to allow the EPROM for prototyping."
    },
    {
        "id": 16,
        "Question": "Which one of the following is UV erasable?",
        "Options": [
            "a) Flash memory",
            "b) SRAM",
            "c) EPROM",
            "d) DRAM"
        ],
        "Answer": "Answer: c\nExplanation: EPROM is an erasable program and it can be erased by ultraviolet radiations. SRAM  and DRAM are volatile memories. Flash memory to is a volatile memory but it is not UV erasable."
    },
    {
        "id": 17,
        "Question": "What kind of memory does an OTP have?",
        "Options": [
            "a) SRAM",
            "b) RAM",
            "c) EPROM",
            "d) DRAM"
        ],
        "Answer": "Answer: c\nExplanation: OTP is one-time programming so it should possess a nonvolatile memory and   EPROM is a nonvolatile memory whereas SRAM, DRAM and RAM are volatile memories."
    },
    {
        "id": 18,
        "Question": "Which type of memory is suitable for low volume production of embedded systems?",
        "Options": [
            "a) ROM",
            "b) Volatile",
            "c) Non-volatile",
            "d) RAM"
        ],
        "Answer": "Answer: c\nExplanation: The devices which use non-volatile memory allow the software to download and returned in the device. UV erasable EPROM is favorable but EEPROM is also gaining favor. Therefore,  this type of memory is used in low volume production."
    },
    {
        "id": 19,
        "Question": "Which is the single device capable of providing prototyping support for a range of microcontroller?",
        "Options": [
            "a) ROM",
            "b) Umbrella device",
            "c) OTP",
            "d) RAM"
        ],
        "Answer": "Answer: b\nExplanation: Umbrella device is capable of providing prototyping support for a range of microcontrollers."
    },
    {
        "id": 20,
        "Question": "What type of memory is suitable for high volume production?",
        "Options": [
            "a) RAM",
            "b) ROM",
            "c) EPROM",
            "d) EEPROM"
        ],
        "Answer": " Answer: b\nExplanation: Read Only Memory is suitable for high volume production since it is a nonvolatile memory."
    },
    {
        "id": 21,
        "Question": "What type of memory is suitable for medium volume production?",
        "Options": [
            "a) Umbrella devices",
            "b) OTP",
            "c) ROM",
            "d) RAM"
        ],
        "Answer": "Answer: b\nExplanation: One-time programmable memory is also a nonvolatile memory so it is used for medium volume production."
    },
    {
        "id": 22,
        "Question": "How an embedded system communicate with the outside world?",
        "Options": [
            "a) Peripherals",
            "b) Memory",
            "c) Input",
            "d) Output"
        ],
        "Answer": "Answer: a\nExplanation: The system communicates with the outside world through peripherals."
    },
    {
        "id": 23,
        "Question": "How the input terminals are associated with external environments?",
        "Options": [
            "a) Actuators",
            "b) Sensors",
            "c) Inputs",
            "d) Outputs"
        ],
        "Answer": "Answer: b\nExplanation: Sensors measures the physical quantity and convert it into electrical means whereas actuators convert electrical quantity into physical quantity."
    },
    {
        "id": 24,
        "Question": "Which of the following are external pins whose logic state can be controlled by the processor to either be a logic zero or logic one is known as",
        "Options": [
            "a) Analogue value",
            "b) Display values",
            "c) Binary values",
            "d) Time derived digital outputs"
        ],
        "Answer": "Answer: c\nExplanation: Binary values possess logic zeros and logic ones."
    },
    {
        "id": 25,
        "Question": "What kind of visual panel is used for seven segmented display?",
        "Options": [
            "a) LED",
            "b) LCD",
            "c) Binary output",
            "d) Analogue output"
        ],
        "Answer": "Answer: b\nExplanation: None."
    },
    {
        "id": 26,
        "Question": "Which one of the following is a microcontroller from Motorola?",
        "Options": [
            "a) MC68HC05",
            "b) 4004",
            "c) MIPS",
            "d) 8080"
        ],
        "Answer": "Answer: a\nExplanation: MC68HC05 is designed by Motorola but 4004 and 8080 are designed by Intel.                               MIPS is designed by MIPS technology."
    },
    {
        "id": 27,
        "Question": "Which is the first microcontroller?",
        "Options": [
            "a) 8051",
            "b) Arm",
            "c) TMS1000",
            "d) Intel 4004"
        ],
        "Answer": "Answer: c\nExplanation:  TMS1000 is the first microcontroller which was done in April 1971 but Intel   4004    was designed in November 1971."
    },
    {
        "id": 28,
        "Question": "How many bits does MC68HC05 possess?",
        "Options": [
            "a) 4",
            "b) 8",
            "c) 16",
            "d) 32"
        ],
        "Answer": "Answer: b\nExplanation: MC68HC05 is a 8 bit controller."
    },
    {
        "id": 29,
        "Question": "What is the bit size of the program counter in MC68HC05?",
        "Options": [
            "a) 7",
            "b) 9",
            "c) 13",
            "d) 17"
        ],
        "Answer": "Answer: c\nExplanation: MC68HC05 have a 13-bit program counter."
    },
    {
        "id": 30,
        "Question": "Which of the following microcontroller is used in engine management system?",
        "Options": [
            "a) MC68HC05",
            "b) MC68HC11",
            "c) Intel 80286",
            "d) Intel 8086"
        ],
        "Answer": "Answer: b\nExplanation: MC68HC11 was originally designed in conjunction with General Motors for use      within engine management systems. As a result, its initial versions had built-in EEPROM/OTP ROM, RAM, digital I/O, timers,8 channel 8 bit A/D converter, PWM generator, and synchronous and asynchronous communications channels (RS232 and SPI)."
    },
    {
        "id": 31,
        "Question": "Which is the concatenated register of MC68HC11?",
        "Options": [
            "a) D",
            "b) X",
            "c) IP",
            "d) DI"
        ],
        "Answer": "Answer: a\nExplanation: The MC68HC11 architecture is similar to that of the 6800 and has two 8 bit accumulators referred to as registers A and B.They are concatenated to provide a 16-bit double accumulator called register D."
    },
    {
        "id": 32,
        "Question": "What does CCR stand for?",
        "Options": [
            "a) Condition code register",
            "b) Computing code register",
            "c) Complex code register",
            "d) Code control register"
        ],
        "Answer": "Answer: a\nExplanation: Condition code register is a special register in the MC68HC11."
    },
    {
        "id": 33,
        "Question": "How many bytes of EPROM does MC68HC7054A possess?",
        "Options": [
            "a) 176 bytes",
            "b) 240 bytes",
            "c) 4144 bytes",
            "d) 1024 bytes"
        ],
        "Answer": "Answer: c\nExplanation: There are defined memory size for different processors and controllers. The MC68HC705A has 4144 bytes of EPROM."
    },
    {
        "id": 34,
        "Question": "Which of the following is an 8-bit command in MC68HC11?",
        "Options": [
            "a)  Add",
            "b) Shift",
            "c) Multiply",
            "d) Subtract"
        ],
        "Answer": "Answer: c\nExplanation: Multiplying two 8 bit requires a 16-bit register."
    },
    {
        "id": 35,
        "Question": "Which one of the following is an asynchronous communication channel?",
        "Options": [
            "a) SPI",
            "b) MUDs",
            "c) MOO",
            "d) VOIP"
        ],
        "Answer": "Answer: a\nExplanation: MC68HC05 have different registers such as the accumulator, stack pointer, index register . Condition code register has to carry flag, zero flags, negative flag, interrupt flag, Half carry flag."
    },
    {
        "id": 36,
        "Question": "Which of the following microprocessor is designed by Zilog?",
        "Options": [
            "a) Z80",
            "b) Zigbee",
            "c) 80386",
            "d) 8087"
        ],
        "Answer": "Answer: a\nExplanation: Designed by Zilog in 1976. 80386 and 8087 are the processors designed by Intel and Zigbee is IEEE based which is used for high-level communication protocol."
    },
    {
        "id": 37,
        "Question": "Z80 is mainly based on",
        "Options": [
            "a) Intel 8080",
            "b) MIPS",
            "c) TIMS",
            "d) 8051"
        ],
        "Answer": "Answer: a\nExplanation: Its architecture is based on Intel 8080 but has an extended instruction set and hardware improvement."
    },
    {
        "id": 38,
        "Question": "Flag register of Z80 is also known as",
        "Options": [
            "a) Program status register",
            "b) Program status address",
            "c) Program status word",
            "d) Program address register"
        ],
        "Answer": "Answer: c\nExplanation: The flag register of Z80 contains status information such as carry, overflow, signed etc."
    },
    {
        "id": 39,
        "Question": "What are the two register sets used in Z80?",
        "Options": [
            "a) C’D’ and BC’",
            "b) CD and BD",
            "c) IV and MR",
            "d) Main and alternate"
        ],
        "Answer": "Answer: d\nExplanation: Z80 have two sets of registers which are the main registers and alternate registers."
    },
    {
        "id": 40,
        "Question": "How an alternate set of the register can be identified in Z80?",
        "Options": [
            "a) ‘Suffix",
            "b) ‘Prefix",
            "c) ,suffix",
            "d) ,prefix"
        ],
        "Answer": "Answer: a\nExplanation: In order to identify the main register and alternate register ‘ is used in the suffix."
    },
    {
        "id": 41,
        "Question": "What is the purpose of memory refresh register of Z80?",
        "Options": [
            "a) To control on-chip DRAM",
            "b) To control on-chip SRAM",
            "c) To control ROM",
            "d) To  clear cache"
        ],
        "Answer": "Answer: a\nExplanation: In addition to the general purpose registers, a stack pointer, program counter, and two index registers are included in Z80. It was also used in many embedded designs because of its high-quality performance and for its in-built refresh circuitry for DRAMs."
    },
    {
        "id": 42,
        "Question": "What is the clock frequency of Z80?",
        "Options": [
            "a) 6 MHz",
            "b) 8 MHz",
            "c) 4 MHz",
            "d) 2 MHz"
        ],
        "Answer": "Answer: c\nExplanation: It is the maximum clock frequency or runs a time of the processor."
    },
    {
        "id": 43,
        "Question": "Which are the two additional registers of Z80?",
        "Options": [
            "a) Interrupt and NMI",
            "b) NMI and PSW",
            "c) Interrupt vector and memory refresh",
            "d) NMI and memory refresh"
        ],
        "Answer": "Answer: c\nExplanation: The Interrupt vector(IV) register is used in the interrupt handling. Mode 2 is used to point the required software routine to process the interrupt. In mode 1, the interrupt vector is supplied via the external data bus."
    },
    {
        "id": 44,
        "Question": "By which instruction does the switching of registers take place?",
        "Options": [
            "a) Instruction opcodes",
            "b) AXX instruction",
            "c) EXX instruction",
            "d) Register instruction"
        ],
        "Answer": "Answer: c\nExplanation: Only one set of registers can be used at one time and the switching of registers and data transfer is performed by the EXX instruction."
    },
    {
        "id": 45,
        "Question": "Which of the following can be a paired set of 16-bit register?",
        "Options": [
            "a) CD",
            "b) HL",
            "c) AB",
            "d) EH"
        ],
        "Answer": "Answer: b\nExplanation: Registers B, C, D, E, H and L are 8-bit general-purpose registers that can be concatenated to produce 16 registers known as BC, DE, and HL."
    },
    {
        "id": 46,
        "Question": "Which signal is used to differentiates the access from a normal memory cycle?",
        "Options": [
            "a) HALT",
            "b) RESET",
            "c) MREQ",
            "d) IORQ"
        ],
        "Answer": "Answer: d\nExplanation: The IORQ signal is used to differentiate the access from a normal memory cycle. These input/output accesses are similar from a hardware perspective to a memory cycle but only occur when an input/output port instruction is executed."
    },
    {
        "id": 47,
        "Question": "What is done in mode1 of Z80?",
        "Options": [
            "a) Interrupt vector is supplied via the external bus",
            "b) Interrupt vector is supplied via the peripherals",
            "c) NMI gets started",
            "d) Interrupt gets acknowledge from peripheral"
        ],
        "Answer": "Answer: a\nExplanation: In mode 1, the interrupt vector is supplied via the external data bus. The memory refresh register is used to control the on-chip DRAM refresh circuitry."
    },
    {
        "id": 48,
        "Question": "What does m1 signal in Z80 describes?",
        "Options": [
            "a) I/O operation status",
            "b) Memory refresh output",
            "c) Output pulse on instruction fetch cycle",
            "d) Interrupt request input"
        ],
        "Answer": "Answer: c\nExplanation: It is a signal which describes output pulse on the instruction fetch cycle. Interrupt request input, input/output operation status, memory refresh output are the other signals in Z80 for various operations."
    },
    {
        "id": 49,
        "Question": "Which is the first device by Intel, that started the microprocessor revolution?",
        "Options": [
            "a) 8080",
            "b) 8086",
            "c) 8087",
            "d) 8088"
        ],
        "Answer": "Answer: a\nExplanation: 8086 was released in 1978 and 8088 was released in 1979. 8087 is a numeric coprocessor that was released in 1977. Furthermore, 8080 is a device designed by Intel in 1974."
    },
    {
        "id": 50,
        "Question": "Which is the first microprocessor by Motorola?",
        "Options": [
            "a) MC6800",
            "b) MC68001",
            "c) MIPS",
            "d) PowerPC"
        ],
        "Answer": "Answer: a\nExplanation: MC6800 is the first microprocessor by Motorola which started a revolution in the embedded systems."
    },
    {
        "id": 51,
        "Question": "Motorola MC6800 is a how many-bit processor?",
        "Options": [
            "a) 4",
            "b) 8",
            "c) 16",
            "d) 32"
        ],
        "Answer": "Answer: b\nExplanation: MC6800 is an 8-bit processor and having two 8 bit accumulator registers."
    },
    {
        "id": 52,
        "Question": "How many accumulators does an MC6800 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: MC6800 is having 2 accumulators both comprising of 8 bits."
    },
    {
        "id": 53,
        "Question": "How many bits does an accumulator register of MC6800 have?",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 32",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: MC6800 possesses an 8-bit accumulator register since it is an 8-bit processor."
    },
    {
        "id": 54,
        "Question": "What is the purpose of an accumulator?",
        "Options": [
            "a) Storing data and performing logical operations",
            "b) Storing data and performing arithmetic and logical operations",
            "c) Storing addresses",
            "d) Pointer"
        ],
        "Answer": "Answer: b\nExplanation: Accumulator is used for all the arithmetic operations such as addition, subtraction, multiplication, as well as relational & logical operations."
    },
    {
        "id": 55,
        "Question": "Which of the following is the area of memory that is used for temporary storage?",
        "Options": [
            "a) Register",
            "b) Stack",
            "c) Accumulator",
            "d) Hard Disk"
        ],
        "Answer": "Answer: b\nExplanation: Stack can be used at the time of function call or it is a short time large-scale storage of data. Therefore, a stack is an area within memory for storage."
    },
    {
        "id": 56,
        "Question": "How a stack is accessed?",
        "Options": [
            "a) By using code segment pointer",
            "b) By using data segment register",
            "c) By using stack segment register",
            "d) By using heap segment register"
        ],
        "Answer": "Answer: c\nExplanation: Stack segment register is a special register that indexes into the stack."
    },
    {
        "id": 57,
        "Question": "PUSH-POP mechanism is seen in _______",
        "Options": [
            "a) Stack pointer",
            "b) Register",
            "c) Memory",
            "d) Index register"
        ],
        "Answer": "Answer: a\nExplanation: Stack pointer is used to store data like subroutine calls in which a push-pop mechanism is followed. Data is pushed into the stack to store it and popped off to retrieve it."
    },
    {
        "id": 58,
        "Question": "What is the range of values an 8-bit register can store?",
        "Options": [
            "a) 128",
            "b) 64",
            "c) 256",
            "d) 32"
        ],
        "Answer": "Answer: c\nExplanation: 28 = 256. So, an 8-bit register can store 256 values (from 0 to 255)."
    },
    {
        "id": 59,
        "Question": "What is the address range in 80286?",
        "Options": [
            "a) 1 Mbytes",
            "b) 2 Mbytes",
            "c) 16 Mbytes",
            "d) 32 mbytes"
        ],
        "Answer": "Answer: c\nExplanation: 80286 is a 16-bit processor. It has an address range of 16 Mbytes."
    },
    {
        "id": 60,
        "Question": "Which is the first 32-bit member of Intel?",
        "Options": [
            "a) 8086",
            "b) 8088",
            "c) 80286",
            "d) 80386"
        ],
        "Answer": "Answer: d\nExplanation: The first generation of Intel started with 80386 which had 32-bit registers."
    },
    {
        "id": 61,
        "Question": "What supports multitasking in 80386?",
        "Options": [
            "a) Read mode",
            "b) External paging memory management unit",
            "c) Paging and segmentation",
            "d) On-chip paging memory management unit"
        ],
        "Answer": "Answer: d\nExplanation: Because of the efficient paging mechanism of 80386 in the memory management unit, it supports multitasking which means different tasks can be done at a time, a kind of parallel execution."
    },
    {
        "id": 62,
        "Question": "Which one of the following is the successor of 8086 and 8088 processor?",
        "Options": [
            "a) 80286",
            "b) 80387",
            "c) 8051",
            "d) 8087"
        ],
        "Answer": "Answer: a\nExplanation: 80286 is the successor of 8086 and 8088  because it possess a CPU based on 8086 and 8088. 8051 is a microcontroller designed by Intel which is commonly known as Intel MCS-51. 8087 is the first floating point coprocessor of 8086."
    },
    {
        "id": 63,
        "Question": "Which is the processor behind the IBM PC AT?",
        "Options": [
            "a) 80387",
            "b) 8088",
            "c) 80286",
            "d) 8086"
        ],
        "Answer": "Answer: c\nExplanation: The processor was successful in the PC market and it was a successful processor behind the IBM."
    },
    {
        "id": 64,
        "Question": " Which are the two modes of 80286?",
        "Options": [
            "a) Real mode and protected mode",
            "b) Mode1 and mode2",
            "c) Alternate and main",
            "d) Mode A and mode B"
        ],
        "Answer": "Answer: a\nExplanation: It possess two modes which are called real and protected modes. In real modes it adds some additional register in order to access a size greater than 16MB but still preserving its compatibility with 8086 and 8088."
    },
    {
        "id": 65,
        "Question": "Which register set of 80286 form the same register set of 8086 processor?",
        "Options": [
            "a) AH,AL",
            "b) BX",
            "c) BX,AX",
            "d) EL"
        ],
        "Answer": "Answer: a\nExplanation: The 16 bit register of 80286 can also act as 8 bit register by splitting into a higher register and lower register."
    },
    {
        "id": 66,
        "Question": "Which are the 4 general purposes 16 bit register in Intel 80286?",
        "Options": [
            "a) CS,DS,SS,ES",
            "b) AX,BX,CX,DX",
            "c) IP,FL,DI,SI",
            "d) DI,SI,BP,SP"
        ],
        "Answer": "Answer: b\nExplanation: Intel 80286 possess 4 general purpose registers and these are 16-bit in size. In addition to the general purpose register, there are four segmented registers, two index registers and a base pointer register."
    },
    {
        "id": 67,
        "Question": "Which are the 4 segmented registers in intel 80286?",
        "Options": [
            "a) AX,BX,CX,DX",
            "b) AS,BS,CS,DS",
            "c) SP,DI,SI,BP",
            "d) IP,FL,SI,DI"
        ],
        "Answer": "Answer: b\nExplanation: Intel 80286 possess 4 general purpose registers, 4 segmented registers, 2 index register and a base pointer register."
    },
    {
        "id": 68,
        "Question": "How is expanded memory accessed in 80286?",
        "Options": [
            "a) Paging",
            "b) Interleaving",
            "c) RAM",
            "d) External storage"
        ],
        "Answer": "Answer: a\nExplanation: The 80286 processor can access beyond 1MB by paging and special hardware to stimulate the missing address lines. This is called expanded memory."
    },
    {
        "id": 69,
        "Question": "When is the register set gets expanded in 80286?",
        "Options": [
            "a) In real mode",
            "b) In expanded mode",
            "c) In protected mode",
            "d) Interrupt mode"
        ],
        "Answer": "Answer: c\nExplanation: In protected mode, two additional register arises which is called index register and base pointer register which helps in expanding the register."
    },
    {
        "id": 70,
        "Question": "Which are the two register available in the protected mode of 80286?",
        "Options": [
            "a) General and segmented",
            "b) General and pointer",
            "c) Index and base pointer",
            "d) Index and segmented"
        ],
        "Answer": "Answer: c\nExplanation: In the protected mode of 80286, two additional register arises which is called index register and base pointer register."
    },
    {
        "id": 71,
        "Question": "What kind of support does 80286 access in protected mode?",
        "Options": [
            "a) Real mode",
            "b) Address access",
            "c) Data access",
            "d) Virtual memory"
        ],
        "Answer": "Answer: d\nExplanation: In the protected mode of 80286, two additional register arises which is called index register and base pointer register. This allows the 80286 to support virtual memory scheme."
    },
    {
        "id": 72,
        "Question": "Which of the following processor possess memory management?",
        "Options": [
            "a) 8086",
            "b) 8088",
            "c) 80286",
            "d) 8051"
        ],
        "Answer": "Answer: c\nExplanation: Because of the efficient paging mechanism, 80286 is one of the processors which allows the memory management unit. 8086 and 8088 does not allow paging mechanism. 8051 is a microcontroller which have an in-built memory and does not possess a paging mechanism."
    },
    {
        "id": 73,
        "Question": "What is the size of the address bus in 80286?",
        "Options": [
            "a) 20",
            "b) 24",
            "c) 16",
            "d) 32"
        ],
        "Answer": "Answer: b\nExplanation: The size of the address bus in 80286 is 24 bits and 20 bits in 8088 and 8086."
    },
    {
        "id": 74,
        "Question": "Which is the interrupt vector in 80286 which functions for stack fault?",
        "Options": [
            "a) 11",
            "b) 12",
            "c) 14",
            "d) 16"
        ],
        "Answer": "Answer: b\nExplanation: 12 is the interrupt vector indicating stack fault. It will be different for a different microprocessor."
    },
    {
        "id": 75,
        "Question": "Which is the interrupt vector that functions as invalid opcode?",
        "Options": [
            "a) 9",
            "b) 8",
            "c) 7",
            "d) 6"
        ],
        "Answer": "Answer: d\nExplanation: 6 is the interrupt vector indicating invalid opcode. It will be different for a different microprocessor."
    },
    {
        "id": 76,
        "Question": "Which of the following possess the same set of instructions?",
        "Options": [
            "a) 8088 and 80286",
            "b) 8086 and 80286",
            "c) 8051 and 8088",
            "d) 8051 and 8086"
        ],
        "Answer": "Answer: b\nExplanation: 80286 is based on the architecture of 8086. So both the processors have the same set of instructions with slight variations."
    },
    {
        "id": 77,
        "Question": "Which of the following is a coprocessor of 80386?",
        "Options": [
            "a) 80387",
            "b) 8087",
            "c) 8089",
            "d) 8088"
        ],
        "Answer": "Answer: a\nExplanation: 80386 have 80387 as a floating point arithmetic coprocessor which can perform various floating point calculations."
    },
    {
        "id": 78,
        "Question": "Name the processor which helps in floating point calculations.",
        "Options": [
            "a) microprocessor",
            "b) microcontroller",
            "c) coprocessor",
            "d) controller"
        ],
        "Answer": "Answer: c\nExplanation: The coprocessor can perform signal processing, floating point arithmetics, encryption etc."
    },
    {
        "id": 79,
        "Question": "Which is the coprocessor of 8086?",
        "Options": [
            "a) 8087",
            "b) 8088",
            "c) 8086",
            "d) 8080"
        ],
        "Answer": "Answer: a\nExplanation: 8087 is the coprocessor for both 8086 and 8088. 8089 is also a coprocessor of 8086 and 80888."
    },
    {
        "id": 80,
        "Question": "Which of the following is a coprocessor of Motorola 68000 family?",
        "Options": [
            "a) 68001",
            "b) 68011",
            "c) 68881",
            "d) 68010"
        ],
        "Answer": "Answer: c\nExplanation: The 68881 coprocessor of Motorola provides floating point arithmetics."
    },
    {
        "id": 81,
        "Question": "Which of the following processors can perform exponential, logarithmic and trigonometric functions?",
        "Options": [
            "a) 8086",
            "b) 8087",
            "c) 8080",
            "d) 8088"
        ],
        "Answer": "Answer: b\nExplanation: 8087 is a coprocessor which can perform all the mathematical functions including addition, subtraction, multiplication, division, exponential, logarithmic, trigonometric etc. 8086, 8080 and 8088 are microprocessors which require the help of a coprocessor for floating point arithmetic."
    },
    {
        "id": 82,
        "Question": "How many stack register does an 8087 have?",
        "Options": [
            "a) 4",
            "b) 8",
            "c) 16",
            "d) 32"
        ],
        "Answer": "Answer: b\nExplanation: The 8087 coprocessor does not have a main register set but they have an 8-level deep stack register from st0 to st7."
    },
    {
        "id": 83,
        "Question": "Which of the following processor can handle infinity values?",
        "Options": [
            "a) 8080",
            "b) 8086",
            "c) 8087",
            "d) 8088"
        ],
        "Answer": "Answer: c\nExplanation: 8087 is a coprocessor which can handle infinity values with two types of closure known as affine closure and projective closure."
    },
    {
        "id": 84,
        "Question": "Which coprocessor supports affine closure?",
        "Options": [
            "a) 80187",
            "b) 80287",
            "c) 80387",
            "d) 8088"
        ],
        "Answer": "Answer: b\nExplanation: 80287 uses an affine closure for infinity values whereas 80387 and 80187 support projective closure for infinity values."
    },
    {
        "id": 85,
        "Question": "Which one is the floating point coprocessor of 80286?",
        "Options": [
            "a) 8087",
            "b) 80187",
            "c) 80287",
            "d) 80387"
        ],
        "Answer": "Answer: c\nExplanation: 80286 supports 80287 as its floating point coprocessor which helps in floating point calculations."
    },
    {
        "id": 86,
        "Question": "How many pins does 8087 have?",
        "Options": [
            "a)  40 pin DIP",
            "b) 20 pin DIP",
            "c) 40 pins",
            "d) 20 pins"
        ],
        "Answer": "Answer: a\nExplanation: All 8087 models have a 40 pin DIP which is operated in 5V."
    },
    {
        "id": 87,
        "Question": "What is the clock frequency of 8087?",
        "Options": [
            "a) 10 MHz",
            "b) 5 MHz",
            "c) 6 MHz",
            "d) 4 MHz"
        ],
        "Answer": "Answer: b\nExplanation: 8087 have 5 MHz as its clock frequency because the coprocessor must have the same clock frequency as that of the main processor."
    },
    {
        "id": 88,
        "Question": "How are negative numbers stored in a coprocessor?",
        "Options": [
            "a) 1’s complement",
            "b) 2’s complement",
            "c) decimal",
            "d) gray"
        ],
        "Answer": "Answer: b\nExplanation: In a coprocessor, negative numbers are stored in 2’s complement with its leftmost sign bit of 1 whereas positive numbers are stored in the form of true value with its leftmost sign bit of 0."
    },
    {
        "id": 89,
        "Question": "How many bits are used for storing signed integers?",
        "Options": [
            "a) 2",
            "b) 4",
            "c) 8",
            "d) 16"
        ],
        "Answer": "Answer: d\nExplanation: Signed integers in a coprocessor are stored as a 16-bit word, 32-bit double word or 64-bit quadword."
    },
    {
        "id": 90,
        "Question": "Which of the processor has an internal coprocessor?",
        "Options": [
            "a) 8087",
            "b) 80287",
            "c) 80387",
            "d) 80486DX"
        ],
        "Answer": "Answer: d\nExplanation: 8087 is an external IC designed to operate with the 8088/8086 processor but 80486DX is an on-chip coprocessor that is, it does not require an extra integrated chip for floating point arithmetics."
    },
    {
        "id": 91,
        "Question": "What are the two major sections in a coprocessor?",
        "Options": [
            "a) control unit and numeric control unit",
            "b) integer unit and control unit",
            "c) floating point unit and coprocessor unit",
            "d) coprocessor unit and numeric control unit"
        ],
        "Answer": "Answer: a\nExplanation: Control unit interfaces the coprocessor with its main microprocessor whereas numeric control unit can execute the coprocessor instructions."
    },
    {
        "id": 92,
        "Question": "What are the three stages included in pipelining of 80386?",
        "Options": [
            "a) Fetch, decode, execute",
            "b) Fetch, execute, decode",
            "c) Execute, fetch, decode",
            "d) Decode, execute, fetch"
        ],
        "Answer": "Answer: a\nExplanation: The instruction can execute in a single cycle which is done by pipelining the instruction flow. The address calculations are performed as the instruction proceeds down the line. Pipelining may take several cycles, an instruction can potentially be started and completed on every clock edge, thus achieving the single cycle performance."
    },
    {
        "id": 93,
        "Question": "How instructions and data are accessed to pipeline stages of 80486 processor?",
        "Options": [
            "a) Through internal unified cache",
            "b) Through external unified cache",
            "c) Through external cache",
            "d) Through multiple caches"
        ],
        "Answer": "Answer: a\nExplanation: In order to have instruction and data to the pipeline, the 80486 has an internal unified cache to contain both data and instructions. This helps in the independency of the processor on external memory."
    },
    {
        "id": 94,
        "Question": "Which of the following processor possesses a similar instruction of 80486?",
        "Options": [
            "a) 8086",
            "b) 80286",
            "c) 80386",
            "d) 8080"
        ],
        "Answer": "Answer: c\nExplanation: The instruction set is same as that of 80386 but there are some additional instructions available when the processor is in protected mode."
    },
    {
        "id": 95,
        "Question": "What are the two external interrupt signals in 80386?",
        "Options": [
            "a) IV and NMI",
            "b) NMI and INTR",
            "c) INTR and IV",
            "d) PC and NMI"
        ],
        "Answer": "Answer: b\nExplanation: The 80386 has two external interrupt signals which allow external devices to interrupt the processor. The INTR input creates a maskable interrupt while the NMI creates a non-maskable interrupt."
    },
    {
        "id": 96,
        "Question": "How many bit vector number is used in an interrupt cycle of 80386?",
        "Options": [
            "a) 4",
            "b) 8",
            "c) 16",
            "d) 32"
        ],
        "Answer": "Answer: b\nExplanation: While an interrupt cycle is running, the processor possesses two interrupts to acknowledge bus cycles and reads an 8-bit vector number. This vector is then used to locate, within the vector table and it has the address of the corresponding interrupt service routine. NMI is automatically assigned as vector number 2."
    },
    {
        "id": 97,
        "Question": "In how many modes does 80386 can run?",
        "Options": [
            "a) 2",
            "b) 4",
            "c) 3",
            "d) 5"
        ],
        "Answer": "Answer: c\nExplanation: The 80386 can run in three different modes: the real mode, the protected mode, and a virtual mode. In real mode, the size of each segment is limited to 64 Kbytes and in protected mode, the largest segment size is increased to 4 Gbytes and the virtual mode is a special version of the protected mode."
    },
    {
        "id": 98,
        "Question": "How many bit flag register does 80386 have?",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 32",
            "d) 64"
        ],
        "Answer": "Answer: c\nExplanation: The 32-bit flag register possesses the normal carry zero, auxiliary carry, parity, sign and overflow flags."
    },
    {
        "id": 99,
        "Question": "Which processor is the derivative of 80386DX?",
        "Options": [
            "a) 80387",
            "b) 80386SX",
            "c) 80386 DDX",
            "d) 8087"
        ],
        "Answer": "Answer: b\nExplanation: Derivative of the 80386DX called the 80386SX which provides the same architecture and lowers cost. To minimal the cost value, it uses an external 16-bit data bus and a 24-bit memory bus."
    },
    {
        "id": 100,
        "Question": "Which of the following is a portable device of Intel?",
        "Options": [
            "a) 80386DX",
            "b) 8087",
            "c) 80386SL",
            "d) 80386SX"
        ],
        "Answer": "Answer: c\nExplanation: Intel has 80386SL as the portable PCs which helps in controlling power and increases the power efficiency of the processor."
    },
    {
        "id": 101,
        "Question": "Which of the processor has a 5 stage pipeline?",
        "Options": [
            "a) 80386",
            "b) 80486",
            "c) 80286",
            "d) 80386DX"
        ],
        "Answer": "Answer: b\nExplanation: 80486 have a five stage pipeline ALU. These include fetch, decode, execute, memory access and write back. This helps in accessing instruction faster and thus makes the processor faster. 80386DX have a three-stage pipelining which only includes fetch, decode and execute."
    },
    {
        "id": 102,
        "Question": "Which of the following processor can execute two instructions per cycle?",
        "Options": [
            "a) 80486",
            "b) 80386DX",
            "c) Intel Pentium",
            "d) 80386"
        ],
        "Answer": "Answer: c\nExplanation: Intel Pentium have many advanced features one of which is, it can execute two instructions per cycle thus improving the speed of the processor whereas 80486, 80386 and 80386DX does not have this feature."
    },
    {
        "id": 103,
        "Question": "Which of the following processors have two five-stage pipelines?",
        "Options": [
            "a) 80486",
            "b) 80386",
            "c) Intel Pentium",
            "d) 80386DX"
        ],
        "Answer": "Answer: c\nExplanation: The intel Pentium possess two five-stage pipelines which allow the execution of two integer instruction jointly."
    },
    {
        "id": 104,
        "Question": "In which processor does the control register and system management mode register first appeared?",
        "Options": [
            "a) 80386",
            "b) 80386SL",
            "c) 80386DX",
            "d) 80486"
        ],
        "Answer": "Answer: b\nExplanation: The control register and system management mode register has first appeared in 80386SL and later on succeeded by other processors. These registers can provide intelligent power control."
    },
    {
        "id": 105,
        "Question": "Which is the next successor of Intel Pentium?",
        "Options": [
            "a) Pentium pro",
            "b) P1",
            "c) P2",
            "d) P5"
        ],
        "Answer": "Answer: a\nExplanation: Intel Pentium is succeeded by Pentium pro. P1, P2, and P5 are the other processors of Intel."
    },
    {
        "id": 106,
        "Question": "Which of the following processor allows a multiple branch prediction?",
        "Options": [
            "a) 80386",
            "b) P1",
            "c) Intel Pentium",
            "d) Intel Pentium pro"
        ],
        "Answer": "Answer: d\nExplanation: A branch instruction can change the program flow and multiple branch prediction allows the continuous execution of instructions based on assumptions. This can eliminate delay and thus speeds up the execution."
    },
    {
        "id": 107,
        "Question": "Which are the processors based on RISC?",
        "Options": [
            "a) SPARC",
            "b) 80386",
            "c) MC68030",
            "d) MC68020"
        ],
        "Answer": "Answer: a\nExplanation: SPARC and MIPS processors are the first generation processors of RISC architecture."
    },
    {
        "id": 108,
        "Question": "What is 80/20 rule?",
        "Options": [
            "a) 80% instruction is generated and 20% instruction is executed",
            "b) 80% instruction is executed and 20% instruction is generated",
            "c) 80%instruction is executed and 20% instruction is not executed",
            "d) 80% instruction is generated and 20% instructions are not generated"
        ],
        "Answer": "Answer: a\nExplanation: 80% of instructions are generated and only 20% of the instruction set is executed that is, by simplifying the instructions, the performance of the processor can be increased which lead to the formation of RISC that is reduced instruction set computing."
    },
    {
        "id": 109,
        "Question": "Which of the architecture is more complex?",
        "Options": [
            "a) SPARC",
            "b) MC68030",
            "c) MC68030",
            "d) 8086"
        ],
        "Answer": "Answer: a\nExplanation: SPARC have RISC architecture which has a simple instruction set but MC68020, MC68030, 8086 have CISC architecture which is more complex than CISC."
    },
    {
        "id": 110,
        "Question": "Which is the first company who defined RISC architecture?",
        "Options": [
            "a) Intel",
            "b) IBM",
            "c) Motorola",
            "d) MIPS"
        ],
        "Answer": "Answer: b\nExplanation: In 1970s IBM identified RISC architecture."
    },
    {
        "id": 111,
        "Question": "Which of the following processors execute its instruction in a single cycle?",
        "Options": [
            "a) 8086",
            "b) 8088",
            "c) 8087",
            "d) MIPS R2000"
        ],
        "Answer": "Answer: d\nExplanation: MIPS R2000 possess RISC architecture in which the processor executes its instruction in a single clock cycle and also synthesize complex operations from the same reduced instruction set."
    },
    {
        "id": 112,
        "Question": "How is memory accessed in RISC architecture?",
        "Options": [
            "a) load and store instruction",
            "b) opcode instruction",
            "c) memory instruction",
            "d) bus instruction"
        ],
        "Answer": "Answer: a\nExplanation: The data of memory address is loaded into a register and manipulated, its contents are written out to the main memory."
    },
    {
        "id": 113,
        "Question": "Which of the following has a Harvard architecture?",
        "Options": [
            "a) EDSAC",
            "b) SSEM",
            "c) PIC",
            "d) CSIRAC"
        ],
        "Answer": "Answer: c\nExplanation: PIC follows Harvard architecture in which the external bus architecture consist of separate buses for instruction and data whereas SSEM, EDSAC, CSIRAC are stored program architecture."
    },
    {
        "id": 114,
        "Question": "Which of the following statements are true for von Neumann architecture?",
        "Options": [
            "a) shared bus between the program memory and data memory",
            "b) separate bus between the program memory and data memory",
            "c) external bus for program memory and data memory",
            "d) external bus for data memory only"
        ],
        "Answer": "Answer: a\nExplanation: von Neumann architecture shares bus between program memory and data memory whereas Harvard architecture have a separate bus for program memory and data memory."
    },
    {
        "id": 115,
        "Question": "What is CAM stands for?",
        "Options": [
            "a) content-addressable memory",
            "b) complex addressable memory",
            "c) computing addressable memory",
            "d) concurrently addressable memory"
        ],
        "Answer": "Answer: a\nExplanation: Non-von Neumann architecture is based on content-addressable memory."
    },
    {
        "id": 116,
        "Question": "Which of the following processors uses Harvard architecture?",
        "Options": [
            "a) TEXAS TMS320",
            "b) 80386",
            "c) 80286",
            "d) 8086"
        ],
        "Answer": "Answer: a\nExplanation: It is a digital signal processor which have small and highly optimized audio or video processing signals. It possesses multiple parallel data bus."
    },
    {
        "id": 117,
        "Question": "Which company further developed the study of RISC architecture?",
        "Options": [
            "a) Intel",
            "b) Motorola",
            "c) university of Berkeley",
            "d) MIPS"
        ],
        "Answer": "Answer: c\nExplanation: The University of Berkeley and Stanford university provides the basic architecture model of RISC."
    },
    {
        "id": 118,
        "Question": "Princeton architecture is also known as",
        "Options": [
            "a) von Neumann architecture",
            "b) Harvard",
            "c) RISC",
            "d) CISC"
        ],
        "Answer": "Answer: a\nExplanation: The von Neumann architecture is also known as von Neumann model or Princeton architecture."
    },
    {
        "id": 119,
        "Question": "Who coined the term RISC?",
        "Options": [
            "a) David Patterson",
            "b) von Neumann",
            "c) Michael J Flynn",
            "d) Harvard"
        ],
        "Answer": "Answer: a\nExplanation: David Patterson of Berkeley university coined the term RISC whereas Michael J Flynn who first views RISC."
    },
    {
        "id": 120,
        "Question": "Which of the following is an 8-bit RISC Harvard architecture?",
        "Options": [
            "a) AVR",
            "b) Zilog80",
            "c) 8051",
            "d) Motorola 6800"
        ],
        "Answer": "Answer: a\nExplanation: AVR is an 8-bit RISC architecture developed by Atmel. Zilog80, 8051, Motorola 6800 are having CISC architectures."
    },
    {
        "id": 121,
        "Question": "Which of the following processors has CISC architecture?",
        "Options": [
            "a) AVR",
            "b) Atmel",
            "c) Blackfin",
            "d) Zilog Z80"
        ],
        "Answer": "Answer: d\nExplanation: Zilog80 have CISC architecture whereas AVR, Atmel and  blackfin possess RISC architecture."
    },
    {
        "id": 122,
        "Question": "What are the factors of filters which are determined by the speed of the operation in a digital signal processor?",
        "Options": [
            "a) attenuation constant",
            "b) frequency",
            "c) bandwidth",
            "d) phase"
        ],
        "Answer": "Answer: c\nExplanation: The bandwidth of any filter depends on the speed of operations held in a digital signal processor."
    },
    {
        "id": 123,
        "Question": "How many tables does an FIR function of a digital signal processor possess?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: Digital signal processor function involves setting up of two tables and one is for sampled data and the other table is for filter coefficients which determine the filter response. It takes values from the table and performs programs."
    },
    {
        "id": 124,
        "Question": "Why is said that branch prediction is not applicable in a digital signal processor?",
        "Options": [
            "a) low bandwidth",
            "b) high bandwidth",
            "c) low frequency",
            "d) high frequency"
        ],
        "Answer": "Answer: a\nExplanation: Loop control timing varies depending on the branch predictions which in turn make bandwidth predictions difficult thereby lowering the bandwidth of the digital signal processor."
    },
    {
        "id": 125,
        "Question": "Which architecture can one overcome the low bandwidth issue in MC6800 family?",
        "Options": [
            "a) RISC",
            "b) CISC",
            "c) von Neumann",
            "d) program stored"
        ],
        "Answer": "Answer: a\nExplanation: RISC architecture can offer some improvement in the low bandwidth issue since it has the ability to perform operations in a single cycle."
    },
    {
        "id": 126,
        "Question": "Which architecture in digital signal processor reduces the execution time?",
        "Options": [
            "a) Harvard",
            "b) CISC",
            "c) program storage",
            "d) von Neumann"
        ],
        "Answer": "Answer: a\nExplanation: Harvard architecture in a digital signal processor allows continuous data fetching and performing the corresponding instructions."
    },
    {
        "id": 127,
        "Question": "Which of the following processors also can work as a digital signal processor?",
        "Options": [
            "a) 8086",
            "b) 8088",
            "c) 8080",
            "d) ARM9E"
        ],
        "Answer": "Answer: d\nExplanation: ARM9E can also have DSP level of performance without having a digital signal processor by its enhanced DSP instructions."
    },
    {
        "id": 128,
        "Question": "What types of modules are used in the digital signal processor to form the loop structure?",
        "Options": [
            "a) modulo-timer",
            "b) modulo-counter",
            "c) timer",
            "d) external timer"
        ],
        "Answer": "Answer: b\nExplanation: By using hardware multipliers, counters etc the entire hardware can be redesigned to perform some specific functions which are used in digital signal processors. One such is the modulo-counter to form the loop structure."
    },
    {
        "id": 129,
        "Question": "Name a processor which is used in digital audio appliances.",
        "Options": [
            "a) 8086",
            "b) Motorola DSP56000",
            "c) 80486",
            "d) 8087"
        ],
        "Answer": "Answer: b\nExplanation: Motorola DSP56000 is a powerful digital signal processor which is used in digital audio applications which have the capability of noise reduction and multi-band graphics whereas 8087 is a coprocessor and 80486 and 8086 are microprocessors."
    },
    {
        "id": 130,
        "Question": "How many bits does DSP56000 processor have?",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 24",
            "d) 32"
        ],
        "Answer": "Answer: c\nExplanation: In order to increase the resolution, DSP56000 is a 24-bit data word processor."
    },
    {
        "id": 131,
        "Question": "How many buses did DSP56000 possess?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: b\nExplanation: It possess three separate external buses, one is for the program and the remaining two buses are for X and Y memories for data."
    },
    {
        "id": 132,
        "Question": "Which of the following architecture does  DSP56000 possess?",
        "Options": [
            "a) Harvard",
            "b) von Neumann",
            "c) CISC",
            "d) program-stored"
        ],
        "Answer": "Answer: a\nExplanation: DSP56000 possess Harvard architecture since this architecture has a separate bus for program memory and data memory."
    },
    {
        "id": 133,
        "Question": "What does AAU stand for?",
        "Options": [
            "a) arithmetic address unit",
            "b) address arithmetic unit",
            "c) address access unit",
            "d) arithmetic access unit"
        ],
        "Answer": "Answer: b\nExplanation: DSP56000 possess two external bus switches in which one is for data and the other is for the address for communicating with the outside world and these two switches are reproduced by the internal data bus and AAU."
    },
    {
        "id": 134,
        "Question": "How many address register does the AAU of a DSP56000 have?",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 24",
            "d) 32"
        ],
        "Answer": "Answer: c\nExplanation: AAU have 24 address registers in three banks of eight."
    },
    {
        "id": 135,
        "Question": "How many registers does a DSP56000 have?",
        "Options": [
            "a) 4",
            "b) 5",
            "c) 7",
            "d) 6"
        ],
        "Answer": "Answer: c\nExplanation: DSP56000 has six 24-bit registers for controlling the loop counts, operating mode, stack manipulation and condition codes."
    },
    {
        "id": 136,
        "Question": " Which of the following bits are used for sign extension in DSP56000?",
        "Options": [
            "a) upper 8 bits of the stack pointer",
            "b) lower 8 bits of the stack pointer",
            "c) lower 8 bits of the program counter",
            "d) upper 8 bits of the program counter"
        ],
        "Answer": "Answer: d\nExplanation: The DSP56000 have a 24-bit program counter in which the upper 8 bits are only used for sign extension."
    },
    {
        "id": 137,
        "Question": "How many bit register set does RISC 1 model used?",
        "Options": [
            "a) 138*24",
            "b) 138*32",
            "c) 69*16",
            "d) 69*32"
        ],
        "Answer": "Answer: b\nExplanation: RISC 1 model is developed in the 1970s and uses a large register set of 138*32 bit. These are arranged in eight overlapping windows which have 24 registers each and these windows are split so that six registers can be used during function calls."
    },
    {
        "id": 138,
        "Question": "Which of the following processor commercializes the Berkeley RISC model?",
        "Options": [
            "a) SPARC",
            "b) Stanford",
            "c) RISC-1",
            "d) RISC"
        ],
        "Answer": "Answer: a\nExplanation: The Berkeley RISC design was developed between the year 1980 and 1984 and later on the RISC design were commercialized as SPARC processor."
    },
    {
        "id": 139,
        "Question": "How many transistors does RISC 1 possess?",
        "Options": [
            "a) 44000",
            "b) 45000",
            "c) 44500",
            "d) 45500"
        ],
        "Answer": "Answer: c\nExplanation: The final design of the RISC concept is called the RISC 1 which was published by ACM ISCA. It possesses 44500 transistors which can implement 31 instruction."
    },
    {
        "id": 140,
        "Question": "How many registers does RISC 1 model have?",
        "Options": [
            "a) 68",
            "b) 58",
            "c) 78",
            "d) 88"
        ],
        "Answer": "Answer: c\nExplanation: The RISC 1 model have 78 registers of size 32 bits."
    },
    {
        "id": 141,
        "Question": "Which of the architectures are made to speed up the processor?",
        "Options": [
            "a) CISC",
            "b) RISC",
            "c) program stored",
            "d) von Neumann"
        ],
        "Answer": "Answer: b\nExplanation: RISC architecture is made for speeding up the processor with limited execution time whereas CISC architecture is mainly for code efficiency."
    },
    {
        "id": 142,
        "Question": "How did 8086 pass its control to 8087?",
        "Options": [
            "a) BUSY instruction",
            "b) ESCAPE instruction",
            "c) CONTROL instruction",
            "d) fetch 8087"
        ],
        "Answer": "Answer: b\nExplanation: When 8086 comes across any floating point arithmetic operations, it executes ESCAPE instruction code in order to pass the control of bus and instruction op-code to 8087."
    },
    {
        "id": 143,
        "Question": "Which of the following processor supports MMX instructions?",
        "Options": [
            "a) 8080",
            "b) 80486",
            "c) Intel Pentium",
            "d) 80386"
        ],
        "Answer": "Answer: c\nExplanation: MMX instructions or multimedia extensions were introduced in Pentium processors to provide support for multimedia software running on a PC."
    },
    {
        "id": 144,
        "Question": "Which of the following processors has a speculative execution?",
        "Options": [
            "a) 80486",
            "b) P1",
            "c) Intel Pentium",
            "d) Pentium pro"
        ],
        "Answer": "Answer: d\nExplanation: Speculative execution is executed speculatively that is, following the predicted branch paths in the code until the true path is determined. If the processor executes correctly, then the performance is gained, if not, the results are discarded and the processor continues to execute until the correct path is identified."
    },
    {
        "id": 145,
        "Question": "How many bit accumulator does DSP56000 have?",
        "Options": [
            "a) 28",
            "b) 56",
            "c) 112",
            "d) 14"
        ],
        "Answer": "Answer: b\nExplanation: The ALU of DSP56000 have two 56-bit accumulator A and B each of which have a small register with it."
    },
    {
        "id": 146,
        "Question": "How many additional registers does DSP56000 have?",
        "Options": [
            "a) 2",
            "b) 4",
            "c) 6",
            "d) 8"
        ],
        "Answer": "Answer: b\nExplanation: In addition to the six registers of DSP56000, it has four 24-bit registers X1, X0, Y1, Y0 which can be concatenated to form 48 bit register X and Y."
    },
    {
        "id": 147,
        "Question": "What does MAC instruction of DSP56000 stand for?",
        "Options": [
            "a) multiply accumulator",
            "b) multiple access",
            "c) multiple accounting",
            "d) multiply accumulator counter"
        ],
        "Answer": "Answer: a\nExplanation: When MAC instruction is executed, the two of the 24-bit additional registers are multiplied together and then added or subtracted from A and B. It takes place in a single machine cycle of 75ns at 27MHz."
    },
    {
        "id": 148,
        "Question": "What does SPARC stand for?",
        "Options": [
            "a) scalable processor architecture",
            "b) speculating architecture",
            "c) speculating processor",
            "d) scaling Pentium architecture"
        ],
        "Answer": "Answer: a\nExplanation: SPARC was designed for optimizing compilers and easily pipelined hardware implementations and it can license by anyone that is, having a nonproprietary architecture which is used to develop various microprocessors."
    },
    {
        "id": 149,
        "Question": "How many bits does SPARC have?",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 32",
            "d) 64"
        ],
        "Answer": "Answer: c\nExplanation: It is a 32 bit RISC architecture having 32-bit wide register bank."
    },
    {
        "id": 150,
        "Question": "Which company developed SPARC?",
        "Options": [
            "a) intel",
            "b) IBM",
            "c) Motorola",
            "d) sun microsystem"
        ],
        "Answer": "Answer: d\nExplanation: SPARC is developed by Sun Microsystem but different manufacturers from other companies like Intel, Texas worked on it."
    },
    {
        "id": 151,
        "Question": "What improves the context switching and parameter passing?",
        "Options": [
            "a) register windowing",
            "b) large register",
            "c) stack register",
            "d) program counter"
        ],
        "Answer": "Answer: a\nExplanation: SPARC follows Berkeley architecture model and uses register windowing in order to improve the context switching and parameter passing. It also supports superscalar operations."
    },
    {
        "id": 152,
        "Question": "How many external interrupts does SPARC processor support?",
        "Options": [
            "a) 5",
            "b) 10",
            "c) 15",
            "d) 20"
        ],
        "Answer": "Answer: c\nExplanation: SPARC processor provides 15 external interrupts which are generated by the interrupt lines IRL0-IRL3."
    },
    {
        "id": 153,
        "Question": "Which level is an in-built nonmaskable interrupt in SPARC processor?",
        "Options": [
            "a) 15",
            "b) 14",
            "c) 13",
            "d) 12"
        ],
        "Answer": "Answer: a\nExplanation: The level 15 of the SPARC processor is assigned to be a nonmaskable interrupt and the remaining 14 levels are unmasked and if necessary they can be made maskable."
    },
    {
        "id": 154,
        "Question": "How many instructions does SPARC processor have?",
        "Options": [
            "a) 16",
            "b) 32",
            "c) 64",
            "d) 128"
        ],
        "Answer": "Answer: c\nExplanation: The instruction set of SPARC processor have 64 instructions which can be accessed by load and store operation with a RISC architecture."
    },
    {
        "id": 155,
        "Question": "What is generated by an external interrupt in SPARC?",
        "Options": [
            "a) internal trap",
            "b) external trap",
            "c) memory trap",
            "d) interfaced trap"
        ],
        "Answer": "Answer: a\nExplanation: In SPARC when an external interrupt is generated, an internal trap is created in the trap base register in which the current and next instructions are saved, the pipeline gets flushed and the processor turns into a supervisor mode."
    },
    {
        "id": 156,
        "Question": "When an external interrupt is generated, what type of mode does the processor supports?",
        "Options": [
            "a) real mode",
            "b) virtual mode",
            "c) protected mode",
            "d) supervisor mode"
        ],
        "Answer": "Answer: d\nExplanation: In SPARC when an external interrupt is called, it creates an internal trap in which the current and next instructions get saved and mode of the processor switches to supervisor mode."
    },
    {
        "id": 157,
        "Question": "Where is trap vector table located in SPARC processor?",
        "Options": [
            "a) program counter",
            "b) Y register",
            "c) status register",
            "d) trap base register"
        ],
        "Answer": "Answer: d\nExplanation: The trap vector table is located in the trap base register which supplies the address of the service routine. When it is completed REIT instructions are executed."
    },
    {
        "id": 158,
        "Question": "How many bits does SPARC-V9 processor have?",
        "Options": [
            "a) 16",
            "b) 32",
            "c) 64",
            "d) 128"
        ],
        "Answer": "Answer: c\nExplanation: There are three major versions of SPARC which are SPARC-V7, SPARC-V8 and SPARC-V9. The former two are 32 bits processor and the later is a 64-bit processor."
    },
    {
        "id": 159,
        "Question": "What are the three modules in the SPARC processor?",
        "Options": [
            "a) IU, FPU, CU",
            "b) SP, DI, SI",
            "c) AX, BX, CX",
            "d) CU, CH, CL"
        ],
        "Answer": "Answer: a\nExplanation: The SPARC processor has three modules which are Integer unit, Floating point unit, and coprocessor unit. Each module has its own functions and integer unit controls the overall operation of the processor."
    },
    {
        "id": 160,
        "Question": "How many floating point register does the FPU of the SPARC have?",
        "Options": [
            "a) 16 128-bit",
            "b) 32 128-bit",
            "c) 64 128-bit",
            "d) 10 128-bit"
        ],
        "Answer": "Answer: a\nExplanation: It possesses 32 32-bit single precision, 32 64-bit double precision and 16 128-bit quads precise floating registers."
    },
    {
        "id": 161,
        "Question": "Which module of SPARC contains the general purpose registers?",
        "Options": [
            "a) IU",
            "b) FPU",
            "c) CU",
            "d) control unit"
        ],
        "Answer": "Answer: a\nExplanation: Integer unit contains the general purpose registers and it controls the overall operation and performance of the processor and the memory address is also calculated by the integer unit."
    },
    {
        "id": 162,
        "Question": "What shows the brightness of the pixel in a digital signal processor?",
        "Options": [
            "a) luminance",
            "b) transparent",
            "c) chrominance",
            "d) opaque"
        ],
        "Answer": "Answer: a\nExplanation: The color image of a digital signal processor have multiple channels. The brightness of the pixel is determined by luminance and the color of the pixel is determined by chrominance."
    },
    {
        "id": 163,
        "Question": "What is the color format of chrominance in a digital signal processor?",
        "Options": [
            "a) VGBA",
            "b) VIBGYOR",
            "c) White",
            "d) RGBA"
        ],
        "Answer": "Answer: d\nExplanation: RGBA colors have four channels red, green, blue, and alpha, which is transparent."
    },
    {
        "id": 164,
        "Question": "Which of the following processor are designed to perform calculations in graphics rendering?",
        "Options": [
            "a) GPU",
            "b) digital signal processor",
            "c) microprocessor",
            "d) microcontroller"
        ],
        "Answer": "Answer: a\nExplanation: Graphics processing unit is designed to perform calculations in graphics rendering. Intel, NVIDIA, and AMD are dominant providers of GPU."
    },
    {
        "id": 165,
        "Question": "Which of the processor is a good match for applications such as video games?",
        "Options": [
            "a) GPU",
            "b) VLIW",
            "c) Coprocessor",
            "d) Microcontroller"
        ],
        "Answer": "Answer: a\nExplanation: GPU is a graphics processing unit. Therefore, more graphical images can be created by  GPU which is necessary for video games. Therefore, GPU is a good match for video games."
    },
    {
        "id": 166,
        "Question": "Which of the following statement is true for concurrency?",
        "Options": [
            "a) different parts of the program executes physically",
            "b) different parts of the program executes sequentially",
            "c) different parts of the program executes conceptually",
            "d) different parts of the program executes sequentially and physically"
        ],
        "Answer": "Answer: c\nExplanation: A concurrent program executes different parts of the program conceptually, a parallel program executes different programs physically and a non-concurrent program executes the program in sequential order."
    },
    {
        "id": 167,
        "Question": "Which is an imperative language?",
        "Options": [
            "a) C program",
            "b) SQL",
            "c) XQuery",
            "d) Concurrent model of HDL"
        ],
        "Answer": "Answer: a\nExplanation: Imperative language is one which executes the program in sequential order. C program is an example of imperative language, SQL and  XQuery are examples of declarative languages or non-imperative language. Concurrent model in HDL is a hardware description language which executes the program concurrently."
    },
    {
        "id": 168,
        "Question": "Which of the following instructions supports parallel execution?",
        "Options": [
            "a) VLIW",
            "b) TTA",
            "c) ALU operation",
            "d) Test-and-set instructions"
        ],
        "Answer": "Answer: a\nExplanation: VLIW is a very long instruction word which receives many instructions and is executed in one instructed word. VLIW is majorly designed for instruction-level parallel (ILP) that is, it can execute codes concurrently or parallel in some time. TTA is a transport triggered architecture which is a type of CPU design which programs controlling the internal buses of the processor. Test-and-set is used to write to a memory location and return its old values. ALU used to perform arithmetic and logic operations."
    },
    {
        "id": 169,
        "Question": "Who invented VLIW architecture?",
        "Options": [
            "a) Josh Fisher",
            "b) John Ellis",
            "c) John Ruttenberg",
            "d) John O’Donnell"
        ],
        "Answer": "Answer: a\nExplanation: Josh Fisher from Yale Universities invented the concept of VLIW architecture. John Ellis described the VLIW compiler. John Ruttenberg develops some important algorithms in scheduling."
    },
    {
        "id": 170,
        "Question": "What is ILP?",
        "Options": [
            "a) instruction-level parallelism",
            "b) instruction-level panel",
            "c) instruction-language panel",
            "d) inter-language parallelism"
        ],
        "Answer": "Answer: a\nExplanation: A processor which supports instruction-level parallelism can perform multiple independent operations in every instruction cycle. Basically, there are four types of instructions. These are CISC instructions, subword parallelism, superscalar, and VLIW."
    },
    {
        "id": 171,
        "Question": "Which ILP supports the  ALU division?",
        "Options": [
            "a) Subword parallelism",
            "b) CISC",
            "c) Superscalar",
            "d) VLIW"
        ],
        "Answer": "Answer: a\nExplanation: In subword parallelism, the wide ALU is divided into smaller slices which enable simultaneous arithmetic and logical operations."
    },
    {
        "id": 172,
        "Question": "Which is a vector processor?",
        "Options": [
            "a) Subword parallelism",
            "b) CISC",
            "c) Superscalar",
            "d) VLIW"
        ],
        "Answer": "Answer: a\nExplanation: Subword parallelism is a form of a vector processing. A vector processor is the one whose instruction set includes operations on multiple data elements simultaneously."
    },
    {
        "id": 173,
        "Question": "Which of the following architecture supports out-of-order execution?",
        "Options": [
            "a) RISC",
            "b) CISC",
            "c) Superscalar",
            "d) Subword parallelism"
        ],
        "Answer": "Answer: c\nExplanation: Superscalar architecture support out-of-order execution in which the instructions later in the stream are executed before earlier instructions."
    },
    {
        "id": 174,
        "Question": "Which is an example of superscalar architecture?",
        "Options": [
            "a) Pentium 4",
            "b) 8086",
            "c) 80386",
            "d) Pentium pro"
        ],
        "Answer": "Answer: a\nExplanation: Pentium 4 is a single core CPU used in desktops, laptops which are proposed by Intel. It has Netburst architecture."
    },
    {
        "id": 175,
        "Question": "Which of the following is a combination of several processors on a single chip?",
        "Options": [
            "a) Multicore architecture",
            "b) RISC architecture",
            "c) CISC architecture",
            "d) Subword parallelism"
        ],
        "Answer": "Answer: a\nExplanation: The Multicore machine is a combination of many processors on a single chip. The heterogeneous multicore machine also combines a  variety of processor types on a single chip."
    },
    {
        "id": 176,
        "Question": "Which is an example of the multi-core processor which possesses 10 cores?",
        "Options": [
            "a) Intel Xeon E7-2850",
            "b) AMD Phenom IIX2",
            "c) Intel core duo",
            "d) AMD Phenom IIX3"
        ],
        "Answer": "Answer: a\nExplanation: Intel Xeon E7-2850 have ten cores whereas AMD Phenom IIx2 and Intel core duo has two cores and AMD Phenom IIX3 has three cores."
    },
    {
        "id": 177,
        "Question": "Which is the most basic non-volatile memory?",
        "Options": [
            "a) Flash memory",
            "b) PROM",
            "c) EPROM",
            "d) ROM"
        ],
        "Answer": "Answer: d\nExplanation: The basic non-volatile memory is ROM or mask ROM, and the content of ROM is fixed in the chip which is useful in firmware programs for booting up the system."
    },
    {
        "id": 178,
        "Question": "Who has invented flash memory?",
        "Options": [
            "a) Dr.Fujio Masuoka",
            "b) John Ellis",
            "c) Josh Fisher",
            "d) John Ruttenberg"
        ],
        "Answer": "Answer: a\nExplanation: Flash memory is invented by Dr. Fujio Masuoka at Toshiba in the 1980s which are non-volatile memory."
    },
    {
        "id": 179,
        "Question": "Which of the following is serial access memory?",
        "Options": [
            "a) RAM",
            "b) Flash memory",
            "c) Shifters",
            "d) ROM"
        ],
        "Answer": "Answer: c\nExplanation: The memory arrays are basically divided into three which are random access memory, serial access memory, and content address memory. Serial access memory is divided into two, theses are shifters and queues."
    },
    {
        "id": 180,
        "Question": "Which is the early form of non-volatile memory?",
        "Options": [
            "a) magnetic core memory",
            "b) ferrimagnetic memory",
            "c) anti-magnetic memory",
            "d) anti-ferromagnetic"
        ],
        "Answer": "Answer: a\nExplanation: The early form of non-volatile memory is known as magnetic core memory in which the ferromagnetic ring was magnetised to store data."
    },
    {
        "id": 181,
        "Question": "Which of the following memories has more speed in accessing data?",
        "Options": [
            "a) SRAM",
            "b) DRAM",
            "c) EPROM",
            "d) EEPROM"
        ],
        "Answer": "Answer: a\nExplanation: SRAM have more speed than DRAM because it has 4 to 6 transistors arranged as flip-flop logic gates, that is it can be flipped from one binary state to another but DRAM has a small capacitor as its storage element."
    },
    {
        "id": 182,
        "Question": "In which memory, the signals are multiplexed?",
        "Options": [
            "a) DRAM",
            "b) SRAM",
            "c) EPROM",
            "d) EEPROM"
        ],
        "Answer": "Answer: a\nExplanation: The signals in address bus are multiplexed with DRAM non-multiplexed with SRAM."
    },
    {
        "id": 183,
        "Question": "How many main signals are used with memory chips?",
        "Options": [
            "a) 2",
            "b) 4",
            "c) 6",
            "d) 8"
        ],
        "Answer": "Answer: b\nExplanation: The main signals associated with memory chips are four. These are the signals associated with address bus, data bus, chip select signals, and control signals for read and write operations."
    },
    {
        "id": 184,
        "Question": "What is the purpose of the address bus?",
        "Options": [
            "a) to provide data to and from the chip",
            "b) to select a specified chip",
            "c) to select a location within the memory chip",
            "d) to select a read/write cycle"
        ],
        "Answer": "Answer: c\nExplanation: Address bus is used to choose a particular location in the memory chip. Data bus is used to provide data to and from the chip. Chip select signals are used to select a particular chip within the memory."
    },
    {
        "id": 185,
        "Question": "Which are the two main types of processor connection to the motherboard?",
        "Options": [
            "a) sockets and slots",
            "b) sockets and pins",
            "c) slots and pins",
            "d) pins and ports"
        ],
        "Answer": "Answer: a\nExplanation: The type of processor which connects to a socket on the bottom surface of the chip that connects to the motherboard by Zero Insertion Force Socket. Intel 486 is an example of this type of connection. The processor slot is one which is soldered into a card, which connects to a motherboard by a slot. Example for slot connection is Pentium 3."
    },
    {
        "id": 186,
        "Question": "Which of the following has programmable hardware?",
        "Options": [
            "a) microcontroller",
            "b) microprocessor",
            "c) coprocessor",
            "d) FPGA"
        ],
        "Answer": "Answer: d\nExplanation: Field programmable gate arrays are a type of multi-core architecture whose hardware function can be programmed by using hardware design tools."
    },
    {
        "id": 187,
        "Question": "Who invented TriMedia processor?",
        "Options": [
            "a) Intel",
            "b) IBM",
            "c) Apple",
            "d) NXP Semiconductor"
        ],
        "Answer": "Answer: d\nExplanation: TriMedia is a VLIW processor from NXP Semiconductor in the Netherlands. It possesses a Harvard architecture CPU for video and audio applications."
    },
    {
        "id": 188,
        "Question": "Which of the following ahs refreshes control mechanism?",
        "Options": [
            "a) DRAM",
            "b) SRAM",
            "c) Battery backed-up SRAM",
            "d) Pseudo-static RAM"
        ],
        "Answer": "Answer: c\nExplanation: SRAM will retain data as long it is powered up and it does not need to be refreshed as DRAM. It is designed for low power consumption and used in preference. DRAM is cheaper than SRAM but it is based on refresh circuitry as it loses charge since the capacitor is the storage element."
    },
    {
        "id": 189,
        "Question": "Which storage element is used by MAC and IBM PC?",
        "Options": [
            "a) CMOS",
            "b) Transistor",
            "c) Capacitor",
            "d) Inductor"
        ],
        "Answer": "Answer: d\nExplanation: Pseudo RAM uses DRAM cells because of its higher memory density and it have refresh control which is an additional function of DRAM and is suitable for low power consumption. It has both the advantages of SRAM and DRAM."
    },
    {
        "id": 190,
        "Question": "Which type of storage element of SRAM is very fast in accessing data but consumes lots of power?",
        "Options": [
            "a) TTL",
            "b) CMOS",
            "c) NAND",
            "d) NOR"
        ],
        "Answer": "Answer: a\nExplanation: CMOS is complementary metal oxide semiconductor which is used by MAC and IBM PC as storage element because it contains configuration data of SRAM and is battery back-up to ensure that it is powered up when the computer is switched off."
    },
    {
        "id": 191,
        "Question": "What is approximate data access time of SRAM?",
        "Options": [
            "a) 4ns",
            "b) 10ns",
            "c) 2ns",
            "d) 60ns"
        ],
        "Answer": "Answer: a\nExplanation: TTL or transistor-transistor logic which is a type of bipolar junction transistor access data very fastly but consumes lots of power whereas CMOS is used in low power consumption."
    },
    {
        "id": 192,
        "Question": "Who proposed the miniature card format?",
        "Options": [
            "a) Intel",
            "b) IBM",
            "c) MIPS",
            "d) Apple"
        ],
        "Answer": "Answer: a\nExplanation: SRAM access data in approximately 4ns because of its flip-flop arrangement of transistors whereas the data access time in DRAM is approximately 60ns since it has a single capacitor for one-bit storage."
    },
    {
        "id": 193,
        "Question": "How many MOSFETs are required for SRAM?",
        "Options": [
            "a) 2",
            "b) 4",
            "c) 6",
            "d) 8"
        ],
        "Answer": "Answer: a\nExplanation: Miniature Card is an SRAM memory card proposed by Intel in the 1980s but it was no longer manufactured."
    },
    {
        "id": 194,
        "Question": "Which of the following is an SRAM?",
        "Options": [
            "a) 1T-RAM",
            "b) PROM",
            "c) EEPROM",
            "d) EPROM"
        ],
        "Answer": "Answer: c\nExplanation: Six MOSFETs are required for a typical SRAM. Each bit of SRAM is stored in four transistors which form two cross-coupled inverters."
    },
    {
        "id": 195,
        "Question": "Which of the following can access data even when the power supply is lost?",
        "Options": [
            "a) Non-volatile SRAM",
            "b) DRAM",
            "c) SRAM",
            "d) RAM"
        ],
        "Answer": "Answer: a\nExplanation: 1T-RAM is a pseudo-static RAM which is developed by MoSyS, Inc. PROM, EPROM, and EEPROM are non-volatile memories."
    },
    {
        "id": 196,
        "Question": "Which of the following can easily convert to a non-volatile memory?",
        "Options": [
            "a) SRAM",
            "b) DRAM",
            "c) DDR SRAM",
            "d) Asynchronous DRAM"
        ],
        "Answer": "Answer: a\nExplanation: Random Access Memory is the primary storage which can access data only when it is powered up. But non-volatile SRAM can access data even when the power supply is lost. It is used in many applications like networking, aerospace etc."
    },
    {
        "id": 197,
        "Question": "Which memory storage is widely used in PCs and Embedded Systems?",
        "Options": [
            "a) SRAM",
            "b) DRAM",
            "c) Flash memory",
            "d) EEPROM"
        ],
        "Answer": "Answer: b\nExplanation: DRAM is used in PCs and Embedded systems because of its low cost. SRAM, flash memory and EEPROM are more costly than DRAM."
    },
    {
        "id": 198,
        "Question": "Which of the following memory technology is highly denser?",
        "Options": [
            "a) DRAM",
            "b) SRAM",
            "c) EPROM",
            "d) Flash memory"
        ],
        "Answer": "Answer: a\nExplanation: DRAM is highly denser and cheaper because it only uses a single capacitor for storing one bit."
    },
    {
        "id": 199,
        "Question": "Which is the storage element in DRAM?",
        "Options": [
            "a) inductor",
            "b) capacitor",
            "c) resistor",
            "d) mosfet"
        ],
        "Answer": "Answer: b\nExplanation: DRAM uses a small capacitor whose voltage represents a binary zero which is used as a storage element in DRAM in which a single transistor cell is used to store each bit of data."
    },
    {
        "id": 200,
        "Question": "Which one of the following is a storage element in SRAM?",
        "Options": [
            "a) capacitor",
            "b) inductor",
            "c) transistor",
            "d) resistor"
        ],
        "Answer": "Answer: c\nExplanation: Four to six transistors are used to store a single bit of data and form a flip-flop logic gate and thus SRAM is faster in accessing data."
    },
    {
        "id": 201,
        "Question": "Which of the following is more volatile?",
        "Options": [
            "a) SRAM",
            "b) DRAM",
            "c) ROM",
            "d) RAM"
        ],
        "Answer": "Answer: b\nExplanation: DRAM is said to be more volatile because it has a capacitor as its storage element in which the data disappears when the capacitor loses its charge so even when the device is powered the data can be lost."
    },
    {
        "id": 202,
        "Question": "What is the size of a trench capacitor in DRAM?",
        "Options": [
            "a) 1 Mb",
            "b) 4-256 Mb",
            "c) 8-128 Mb",
            "d) 64-128 Mb"
        ],
        "Answer": "Answer: b\nExplanation: Trench capacitor can store from 4-256 Mb but planar capacitor can store up to 1 Mb."
    },
    {
        "id": 203,
        "Question": "Which of the following capacitor can store more data in DRAM?",
        "Options": [
            "a) planar capacitor",
            "b) trench capacitor",
            "c) stacked-cell",
            "d) non-polar capacitor"
        ],
        "Answer": "Answer: c\nExplanation: Stacked-cell can store greater than 1 Gb. Planar capacitor can store up to 1 Mb and trench capacitor can store 4-256 Mb."
    },
    {
        "id": 204,
        "Question": "In which of the memories, does the data disappear?",
        "Options": [
            "a) SRAM",
            "b) DRAM",
            "c) Flash memory",
            "d) EPROM"
        ],
        "Answer": "Answer: b\nExplanation: Both SRAM and DRAM are volatile memories and flash memory and EPROM are non-volatile memories. DRAM has a storage element as a capacitor whose charge loses gradually thereby losing data."
    },
    {
        "id": 205,
        "Question": "Which of the following is the main factor which determines the memory capacity?",
        "Options": [
            "a) number of transistors",
            "b) number of capacitors",
            "c) size of the transistor",
            "d) size of the capacitor"
        ],
        "Answer": "Answer: a\nExplanation: The chip capacity is dependent on the number of transistors which can be fabricated on the silicon, and DRAM offers more storage capacity than SRAM."
    },
    {
        "id": 206,
        "Question": "What does VRAM stand for?",
        "Options": [
            "a) video RAM",
            "b) verilog RAM",
            "c) virtual RAM",
            "d) volatile RAM"
        ],
        "Answer": "Answer: a\nExplanation: Video RAM is a derivative of DRAM. It functions as a DRAM and has additional functions to access data for video hardware for creating the display."
    },
    {
        "id": 207,
        "Question": "What does TCR stand for?",
        "Options": [
            "a) temperature-compensated refresh",
            "b) temperature-compensated recovery",
            "c) texas CAS-RAS",
            "d) temperature CAS-RAS"
        ],
        "Answer": "Answer: a\nExplanation: The temperature-compensated refresh is one of the refreshing techniques used for extending the battery life by reducing the refresh rate."
    },
    {
        "id": 208,
        "Question": "How many data lines does 256*4 have?",
        "Options": [
            "a) 256",
            "b) 8",
            "c) 4",
            "d) 32"
        ],
        "Answer": "Answer: c\nExplanation: There are four data lines in the memory and these different organisations of memory and these different organisations of memory are apparent when upgrading memory and it also determines how many chips are needed."
    },
    {
        "id": 209,
        "Question": "How is the number of chips required is determined?",
        "Options": [
            "a) number of data lines",
            "b) the minimum number of data",
            "c) width of the data path from the processor",
            "d) number of data lines and the width of the data path from the processor"
        ],
        "Answer": "Answer: d\nExplanation: The minimum number of chips is determined by the number of data lines and the width of the data path from the processor. For example, MC6800 family have a 16-bit wide datapath, 16*1 devices, 4*4 or 2*8 devices are needed."
    },
    {
        "id": 210,
        "Question": "Where is memory address stored in a C program?",
        "Options": [
            "a) stack",
            "b) pointer",
            "c) register",
            "d) accumulator"
        ],
        "Answer": "Answer: b\nExplanation: Memory model is defined by a range of memory address which is accessible to the program. For example, in the C program, the memory address is stored in the pointer."
    },
    {
        "id": 211,
        "Question": "Which is the term that is used to refer the order of bytes?",
        "Options": [
            "a) endianness",
            "b) memory organisation",
            "c) bit",
            "d) register"
        ],
        "Answer": "Answer: a\nExplanation: Endianness defines the order of bytes, that is, whether it is big endian or little endian. The former represents the higher order bits and the latter represents the lower order bits."
    },
    {
        "id": 212,
        "Question": "Which of the following processors uses big endian representation?",
        "Options": [
            "a) 8086",
            "b) ARM",
            "c) PowerPC",
            "d) Zilog Z80"
        ],
        "Answer": "Answer: c\nExplanation: The IBM’s PowerPC uses big endian representation whereas 8086, ARM and Zilog Z80 use little representation."
    },
    {
        "id": 213,
        "Question": "Which statement is true for a cache memory?",
        "Options": [
            "a) memory unit which communicates directly with the CPU",
            "b) provides backup storage",
            "c) a very high-speed memory to increase the speed of the processor",
            "d) secondary storage"
        ],
        "Answer": "Answer: c\nExplanation: The RAM is the primary storage which directly communicates with the CPU. ROM is the secondary storage. Disk drives are capable of providing backup storage and the cache memory is a small high-speed memory which increases the speed of the processor."
    },
    {
        "id": 214,
        "Question": "Which of the following memory organisation have the entire memory available to the processor at all times?",
        "Options": [
            "a) segmented addressing",
            "b) paging",
            "c) virtual address",
            "d) linear address"
        ],
        "Answer": "Answer: d\nExplanation: There are two types of memory organisation, linear addressing in which the entire memory is available to the processor of all times as in Motorola 6800 and the other is segmented addressing where the memory space is divided into several segments and the processor is limited to access the program instructions and data which are located in particular segments."
    },
    {
        "id": 215,
        "Question": "How many memory locations can be accessed by 8086?",
        "Options": [
            "a) 1 M",
            "b) 2 M",
            "c) 3 M",
            "d) 4 M"
        ],
        "Answer": "Answer: a\nExplanation: The 8086 processor has a 20-bit address bus, hence it can access a memory of 220-1 M locations."
    },
    {
        "id": 216,
        "Question": "Which of them is a memory that is allocated to the program in LIFO pattern?",
        "Options": [
            "a) stack",
            "b) index",
            "c) accumulator",
            "d) base"
        ],
        "Answer": "Answer: a\nExplanation: A stack is a memory which is allocated to the program in last-in, first out pattern. Stack pointer contains the memory address of the stack."
    },
    {
        "id": 217,
        "Question": "What does SIMM stand for?",
        "Options": [
            "a) single in-line memory module",
            "b) single interrupt memory module",
            "c) single information memory module",
            "d) same-in-line memory module"
        ],
        "Answer": "Answer: a\nExplanation: SIMM is single in-line memory module is a kind of memory module, which contains random access memory used in computers of the early 1980s and 1990s."
    },
    {
        "id": 218,
        "Question": "Which of the memory organisation is widely used in parity bit?",
        "Options": [
            "a) by 1 organisation",
            "b) by 4 organisation",
            "c) by 8 organisation",
            "d) by 9 organisation"
        ],
        "Answer": "Answer: a\nExplanation: The use of By 1 organisation is declined because of the wider data path devices. But it is still used in parity bit and were used in SIMM memory."
    },
    {
        "id": 219,
        "Question": "Which configuration of memory organisation replaces By 1 organisation?",
        "Options": [
            "a) by 4 organisation",
            "b) by 8 organisation",
            "c) by 9 organisation",
            "d) by 16 organisation"
        ],
        "Answer": "Answer: a\nExplanation: By 1 organisation is replaced with By 4 organisation because of its reduced address bus and complexity."
    },
    {
        "id": 220,
        "Question": "Which shifting helps in finding the physical address in 8086?",
        "Options": [
            "a) shifting the segment by 8",
            "b) shifting the segment by 6",
            "c) shifting the segment by 4",
            "d) shifting the segment by 2"
        ],
        "Answer": "Answer: c\nExplanation: The address bus of the 8086 is 20-bit and the data bus is 16-bit in size. So the physical address can be calculated by shifting the segment register by 4 to left and by adding the address bus to it."
    },
    {
        "id": 221,
        "Question": "Which memory organisation is supported in wider memories?",
        "Options": [
            "a) by 8 organisation",
            "b) by 16 organisation",
            "c) by 9 organisation",
            "d) by 4 organisation"
        ],
        "Answer": "Answer: b\nExplanation: The wider memories support 16-bits because it can integrate more number of the interface logic so that the time consumed by the latches and buffers removes the memory access thus allowing the slower parts to be used in wait state free designs."
    },
    {
        "id": 222,
        "Question": "Which of the following is a plastic package used primarily for DRAM?",
        "Options": [
            "a) SIMM",
            "b) DIMM",
            "c) Zig-zag",
            "d) Dual-in-line"
        ],
        "Answer": "Answer: c\nExplanation: Zig-zag package of memory is a plastic package used for DRAM. The leads of this package are arranged in a zigzag manner."
    },
    {
        "id": 223,
        "Question": "Which of the following have a 16 Mbytes addressed range?",
        "Options": [
            "a) PowerPC",
            "b) M68000",
            "c) DSP56000",
            "d) TMS 320"
        ],
        "Answer": "Answer: b\nExplanation: The M68000 family has a 16 Mbyte addressing range. The PowerPC family has a larger 4 Gbyte range and the DSP56000 has a 128-kilo word address space."
    },
    {
        "id": 224,
        "Question": "Which of the following can destroy the accuracy in the algorithms?",
        "Options": [
            "a) delays",
            "b) error signal",
            "c) interrupt",
            "d) mmu"
        ],
        "Answer": "Answer: a\nExplanation: The delays occurring in the memory management unit can destroy the accuracy in the algorithms and in order to avoid this, the linear addressing range should be increased."
    },
    {
        "id": 225,
        "Question": "How many numbers of ways are possible for allocating the memory to the modular blocks?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: Most of the systems have a multitasking operating system in which the software consists of modular blocks of codes which run under the control of the operating system. There are three ways for allocating memory to these blocks. The first way distributes the block in a predefined way. The second way for allocating memory includes relocation or position independency in the software and the other way of allocating memory to the block is the address translation in which the logical address is translated to the physical address."
    },
    {
        "id": 226,
        "Question": "Which of the following is replaced with the absolute addressing mode?",
        "Options": [
            "a) relative addressing mode",
            "b) protective addressing mode",
            "c) virtual addressing mode",
            "d) temporary addressing mode"
        ],
        "Answer": "Answer: a\nExplanation: The memory allocation of the modular blocks can be done by the writing the software program in relocatable or position independent manner which can execute anywhere in the memory map, but relocatable code must have the same address between its data and code segments. This is used to avoid the use of absolute addressing modes which is replaced by the relative addressing modes."
    },
    {
        "id": 227,
        "Question": "What is the main purpose of the memory management unit?",
        "Options": [
            "a) address translation",
            "b) large storage",
            "c) reduce the size",
            "d) provides address space"
        ],
        "Answer": "Answer: a\nExplanation: The memory management unit handles with physical addresses. Therefore, the virtual or the logical address is first translated to the physical address."
    },
    {
        "id": 228,
        "Question": "Which of the following provides stability to the multitasking system?",
        "Options": [
            "a) memory",
            "b) DRAM",
            "c) SRAM",
            "d) Memory partitioning"
        ],
        "Answer": "Answer: d\nExplanation: The memory partitioning provides stability to the multitasking system so that the errors within one task will not corrupt the other tasks."
    },
    {
        "id": 229,
        "Question": "Which of the following is used by the M68000 family?",
        "Options": [
            "a) M68000",
            "b) 80386",
            "c) 8086",
            "d) 80286"
        ],
        "Answer": "Answer: a\nExplanation: The M68000 uses memory partitioning by the use of function code or by the combination of superscalar signals and the Harvard architecture."
    },
    {
        "id": 230,
        "Question": "What can be done for the fine grain protection of the processor?",
        "Options": [
            "a) add extra description bit",
            "b) add error signal",
            "c) add wait stage",
            "d) remains unchanged"
        ],
        "Answer": "Answer: a\nExplanation: The finer grain protection of memory management is achieved by the addition of extra description bit to an address to declare its status. The memory management unit can detect an error if the task attempts to access memory that has not been allocated to it or a certain kind of mismatch occurs."
    },
    {
        "id": 231,
        "Question": "Which of the following technique is used by the UNIX operating system?",
        "Options": [
            "a) logical address memory",
            "b) physical address memory",
            "c) virtual memory technique",
            "d) translational address"
        ],
        "Answer": "Answer: c\nExplanation: In the workstation and in the UNIX operating system virtual memory technique is frequently used in which the main memory is divided into different segments and pages. These pages will have a virtual address which can increase the address spacing."
    },
    {
        "id": 232,
        "Question": "Which of the following consist two lines of legs on both sides of a plastic or ceramic body?",
        "Options": [
            "a) SIMM",
            "b) DIMM",
            "c) Zig-zag",
            "d) Dual in-line"
        ],
        "Answer": "Answer: d\nExplanation: The dual-in-line package consists of two lines of legs on both sides of the plastic or ceramic. Most commonly used are BIOS EPROMs, DRAM and SRAM."
    },
    {
        "id": 233,
        "Question": "Which package has high memory speed and change in the supply?",
        "Options": [
            "a) DIP",
            "b) SIMM",
            "c) DIMM",
            "d) zig-zag"
        ],
        "Answer": "Answer: c\nExplanation: DIMM is a special version of SIMM which is 168-bits wider bus and looks similar to a larger SIMM. The wider bus increases the memory speed and change in supply voltage."
    },
    {
        "id": 234,
        "Question": "Which is a subassembly package?",
        "Options": [
            "a) dual-in-line",
            "b) zig-zag",
            "c) simm",
            "d) ceramic shell"
        ],
        "Answer": "Answer: c\nExplanation: The SIMM is basically a subassembly, not a package. It is a small board which possesses finger connection on the bottom and sufficient memory on the board in order to make up the required configuration."
    },
    {
        "id": 235,
        "Question": "What is the required voltage of DIMM?",
        "Options": [
            "a) 2V",
            "b) 2.2V",
            "c) 5V",
            "d) 3.3V"
        ],
        "Answer": "Answer: d\nExplanation: For increasing the speed and reducing the power consumption, it is necessary to reduce the power supply. Today’s CPUs and memories have 3.3V supply or even lower instead of the signal level from 0 to 5V. DIMMS are described by its voltage, speed, and memory type respectively as 3.3V 133MHz SDRAM DIMM."
    },
    {
        "id": 236,
        "Question": "Which memory package has a single row of pins?",
        "Options": [
            "a) SIMM",
            "b) DIP",
            "c) SIP",
            "d) zig-zag"
        ],
        "Answer": "Answer: c\nExplanation: The Single-in-line package is the same as that of SIMM, in which the finger connections are replaced by a single row of pins. SIP took the popularity of SIMM but nowadays it is rarely seen."
    },
    {
        "id": 237,
        "Question": "What is the access time of MCM51000AP10?",
        "Options": [
            "a) 100ns",
            "b) 80ns",
            "c) 60ns",
            "d) 40ns"
        ],
        "Answer": "Answer: a\nExplanation: The access time of memory is defined as the maximum time taken by the chip to read/write data and it is very important to match the access time to the design. For example, MCM51000AP10 have 100ns access time for the memory."
    },
    {
        "id": 238,
        "Question": "Which is the very basic technique of refreshing DRAM?",
        "Options": [
            "a) refresh cycle",
            "b) burst refresh",
            "c) distributive refresh",
            "d) software refresh"
        ],
        "Answer": "Answer: a\nExplanation: The DRAM needs to be periodically refreshed and the very basic technique is a special refresh cycle, during these cycles no other access is permitted. The whole chip is refreshed within a particular time period otherwise, the data will be lost."
    },
    {
        "id": 239,
        "Question": "How is the refresh rate calculated?",
        "Options": [
            "a) by refresh time",
            "b) by the refresh cycle",
            "c) by refresh cycle and refresh time",
            "d) refresh frequency and refresh cycle"
        ],
        "Answer": "Answer: c\nExplanation: The time required for refreshing the whole chip is known as refresh time. The number of access needed to complete refresh is called as the number of cycles. The number of cycles divided by the refresh time gives the refresh rate."
    },
    {
        "id": 240,
        "Question": "Which is the commonly used refresh rate?",
        "Options": [
            "a) 125 microseconds",
            "b) 120 microseconds",
            "c) 130 microseconds",
            "d) 135 microseconds"
        ],
        "Answer": "Answer: a\nExplanation: There are two refresh rates used in common. They are standard refresh rate of 15.6 microseconds and 125 microseconds which the extended form."
    },
    {
        "id": 241,
        "Question": "How can we calculate the length of the refresh cycle?",
        "Options": [
            "a) twice of normal access",
            "b) thrice of normal access",
            "c) five times of normal access",
            "d) six times of normal access"
        ],
        "Answer": "Answer: a\nExplanation: Each of the refresh cycles is approximately as twice as the length of the normal access, for example, a 70ns DRAM has a refresh cycle time of 130ns."
    },
    {
        "id": 242,
        "Question": "What type of error occurs in the refresh cycle of the DRAM?",
        "Options": [
            "a) errors in data",
            "b) power loss",
            "c) timing issues",
            "d) not accessing data"
        ],
        "Answer": "Answer: c\nExplanation: When the refresh cycle in a DRAM is running, it will not access data, so the processor will have to wait for its data. This arises some timing issues."
    },
    {
        "id": 243,
        "Question": "What is the worst case delay of the burst refresh in 4M by 1 DRAM?",
        "Options": [
            "a) 0.4ms",
            "b) 0.2ms",
            "c) 170ns",
            "d) 180ns"
        ],
        "Answer": "Answer: b\nExplanation: A 4M by 1 DRAM have 1024 refresh cycles. Bursting delay will be 0.2ms that are, the worst case delay is 1024 times larger than that of the single refresh cycle. The distributed delay is about 170ns."
    },
    {
        "id": 244,
        "Question": "Which refresh techniques depends on the size of time critical code for calculating the refresh cycle?",
        "Options": [
            "a) burst refresh",
            "b) distributed refresh",
            "c) refresh cycle",
            "d) software refresh"
        ],
        "Answer": "Answer: b\nExplanation: Most of the system uses the distributed method and depending on the size of the time critical code, the number of refresh cycles can be calculated."
    },
    {
        "id": 245,
        "Question": "Which of the following uses a timer for refresh technique?",
        "Options": [
            "a) RAS",
            "b) CBR",
            "c) software refresh",
            "d) CAS"
        ],
        "Answer": "Answer: c\nExplanation: The software refresh performs the action by using a routine to periodically cycle through the memory and refreshes. It uses a timer in the program generating an interrupt. This interrupt performs the refreshing part in the DRAM."
    },
    {
        "id": 246,
        "Question": "What is the main disadvantage in the software refresh of the DRAM?",
        "Options": [
            "a) timer",
            "b) delay",
            "c) programming delay",
            "d) debugging"
        ],
        "Answer": "Answer: d\nExplanation: Debugging in software refresh is very difficult to perform because they may stop the refreshing and if the refreshing is stopped, the contents get lost."
    },
    {
        "id": 247,
        "Question": "Which refresh technique is useful for low power consumption?",
        "Options": [
            "a) Software refresh",
            "b) CBR",
            "c) RAS",
            "d) Burst refresh"
        ],
        "Answer": "Answer: b\nExplanation: CBR that is, CAS before RAS refresh is the one which is commonly used. It has low power consumption quality because it does not have address bus and the buffers can be switched off. It is worked by using an internal address counter which is stored on the memory chip itself and this can be incremented periodically."
    },
    {
        "id": 248,
        "Question": "Which refreshing techniques generate a recycled address?",
        "Options": [
            "a) RAS",
            "b) CBR",
            "c) Distributed refresh",
            "d) Software refresh"
        ],
        "Answer": "Answer: a\nExplanation: The row address is placed on the address bus and the column address is held off which generates the recycle address. The address generation is done by an external hardware controller."
    },
    {
        "id": 249,
        "Question": "Which of the following uses a software refresh in the DRAM?",
        "Options": [
            "a) 8086",
            "b) 80386",
            "c) Pentium",
            "d) Apple II personal computer"
        ],
        "Answer": "Answer: d\nExplanation: The Apple II personal computer has a particular memory configuration, periodically the DRAM gets blocked and is used for video memory accessing to update the screen which can refresh the DRAM."
    },
    {
        "id": 250,
        "Question": "How do CBR works?",
        "Options": [
            "a) by asserting CAS before RAS",
            "b) by asserting CAS after RAS",
            "c) by asserting RAS before CAS",
            "d) by asserting CAS only"
        ],
        "Answer": "Answer: a\nExplanation: CBR works by an internal address counter which is periodically incremented. The mechanism is based on CAS before RAS. Each time when RAS is asserted, the refresh cycle performs and the counter is incremented."
    },
    {
        "id": 251,
        "Question": "Which of the refresh circuit is similar to CBR?",
        "Options": [
            "a) software refresh",
            "b) hidden refresh",
            "c) burst refresh",
            "d) distribute refresh"
        ],
        "Answer": "Answer: b\nExplanation: In the hidden refresh, the refresh cycle is added to the end of a normal read cycle. The RAS signal goes high and is then asserted low. At the end of the read cycle, the CAS is still asserted. This is similar to the CBR mechanism, that is, toggling of the RAS signal at the end of the read cycle starts a CBR refresh cycle."
    },
    {
        "id": 252,
        "Question": "Which technology is standardized in DRAM for determining the maximum time interval between the refresh cycle?",
        "Options": [
            "a) IEEE",
            "b) RAPID",
            "c) JEDEC",
            "d) UNESCO"
        ],
        "Answer": "Answer: c\nExplanation: The maximum time interval between refresh cycle is standardized by JEDEC, Joint Electron Device Engineering Council which is an independent semiconductor engineering trade organization. This standardized JEDEC in DRAM is specified in the manufacturer’s chip specification."
    },
    {
        "id": 253,
        "Question": "In which pin does the data appear in the basic DRAM interfacing?",
        "Options": [
            "a) dout pin",
            "b) din pin",
            "c) clock",
            "d) interrupt pin"
        ],
        "Answer": "Answer: a\nExplanation: In the basic DRAM interfacing, the higher order bits asserts the RAS signal and the lower order bits asserts the CAS signal. When the access got expired, the data appears on the dout pin and is latched by the processor."
    },
    {
        "id": 254,
        "Question": "What is the duration for memory refresh to remain compatible?",
        "Options": [
            "a) 20 microseconds",
            "b) 12 microseconds",
            "c) 15 microseconds",
            "d) 10 microseconds"
        ],
        "Answer": "Answer: c\nExplanation: The memory refresh is performed every 15 microseconds in order to remain compatible."
    },
    {
        "id": 255,
        "Question": "Which interfacing method lowers the speed of the processor?",
        "Options": [
            "a) basic DRAM interface",
            "b) page mode interface",
            "c) page interleaving",
            "d) burst mode interface"
        ],
        "Answer": "Answer: a\nExplanation: The direct method access limits the wait state-free operation which lowers the processor speed."
    },
    {
        "id": 256,
        "Question": "What is EDO RAM?",
        "Options": [
            "a) extreme data operation",
            "b) extended direct operation",
            "c) extended data out",
            "d) extended DRAM out"
        ],
        "Answer": "Answer: c\nExplanation: EDO RAM is a special kind of random access memory which can improve the time to read from the memory on faster microprocessors. The example of such a microprocessor is Intel Pentium."
    },
    {
        "id": 257,
        "Question": "What is RDRAM?",
        "Options": [
            "a) refresh DRAM",
            "b) recycle DRAM",
            "c) Rambus DRAM",
            "d) refreshing DRAM"
        ],
        "Answer": "Answer: c\nExplanation: Rambus DRAM is a synchronous memory developed by Rambus. It can replace SDRAM and is useful in high bandwidth applications."
    },
    {
        "id": 258,
        "Question": "Which of the following can transfer up to 1.6 billion bytes per second?",
        "Options": [
            "a) DRAM",
            "b) RDRAM",
            "c) EDO RAM",
            "d) SDRAM"
        ],
        "Answer": "Answer: b\nExplanation: The Rambus RAM can transfer up to 1.6 billion bytes per second. It possesses RAM controller, a bus which connects the microprocessor and the device, and random access memory."
    },
    {
        "id": 259,
        "Question": "Which of the following cycle is larger than the access time?",
        "Options": [
            "a) write cycle",
            "b) set up time",
            "c) read cycle",
            "d) hold time"
        ],
        "Answer": "Answer: c\nExplanation: The read cycle in the DRAM interfacing is larger than the access time because of the precharge time."
    },
    {
        "id": 260,
        "Question": "Which mode of operation selects an internal page of memory in the DRAM interfacing?",
        "Options": [
            "a) page interleaving",
            "b) page mode",
            "c) burst mode",
            "d) EDO RAM"
        ],
        "Answer": "Answer: b\nExplanation: In the page mode operation, the row address is provided as normal but the RAS signal is left asserted. This, in turn, selects an internal page within the DRAM memory where any bit of data can be accessed by placing the column address and asserting CAS."
    },
    {
        "id": 261,
        "Question": "What is the maximum time that the RAS signal can be asserted in the page mode operation?",
        "Options": [
            "a) 5 microseconds",
            "b) 10 microseconds",
            "c) 15 microseconds",
            "d) 20 microseconds"
        ],
        "Answer": "Answer: b\nExplanation: The maximum time that the RAS signal can be asserted during the page mode operation is about 10 microseconds. But this is a major disadvantage for page mode operation, that is, the standard PCs have a maximum time of 15 microseconds for the refresh cycle."
    },
    {
        "id": 262,
        "Question": "Which of the following mode of operation in the DRAM interfacing has a page boundary?",
        "Options": [
            "a) burst mode",
            "b) EDO RAM",
            "c) page mode",
            "d) page interleaving"
        ],
        "Answer": "Answer: c\nExplanation: The page mode operation have memory cycles that exhibit some form of locality, that is, stay within the page boundary which causes page missing when there is access outside the page boundary and two or more wait states."
    },
    {
        "id": 263,
        "Question": "Which mode offers the banking of memory in the DRAM interfacing technique?",
        "Options": [
            "a) page mode",
            "b) basic DRAM interfacing",
            "c) page interleaving",
            "d) burst mode"
        ],
        "Answer": "Answer: c\nExplanation: The accessing of data outside the page boundary can cause missing of pages in the page mode operation. So a program has to operate for frequently accessing data thereby, increasing the efficiency in the page selection. One such mode is the page interleaving mode in which the memory is divided into different banks, depending on the number of memories installed."
    },
    {
        "id": 264,
        "Question": "Which of the following has a fast page mode RAM?",
        "Options": [
            "a) burst mode",
            "b) page interleaving",
            "c) EDO memory",
            "d) page mode"
        ],
        "Answer": "Answer: c\nExplanation: Extended data out memory is a fast page mode RAM which has a faster cycling process which makes EDO memory a faster page mode access."
    },
    {
        "id": 265,
        "Question": "Which mode reduces the need for fast static RAMs?",
        "Options": [
            "a) page mode",
            "b) page interleaving",
            "c) burst mode",
            "d) EDO memory"
        ],
        "Answer": "Answer: c\nExplanation: The page mode, nibble mode devices can provide data fastly when the new column address is given. In burst mode operation, the processor can fetch more data than it needs and keeps the remaining data in an internal cache for the future use which can reduce the need for fast static RAMs."
    },
    {
        "id": 266,
        "Question": "Which of the following is also known as hyper page mode enabled DRAM?",
        "Options": [
            "a) page mode",
            "b) EDO DRAM",
            "c) burst EDO DRAM",
            "d) page interleaving"
        ],
        "Answer": "Answer: b\nExplanation: The EDO  DRAM is also known as hyper page mode enable DRAM because of the faster page mode operation along with some additional features."
    },
    {
        "id": 267,
        "Question": "What does BEDO DRAM stand for?",
        "Options": [
            "a) burst EDO DRAM",
            "b) buffer EDO DRAM",
            "c) BIBO EDO DRAM",
            "d) bilateral EDO DRAM"
        ],
        "Answer": "Answer: a\nExplanation: The burst EDO DRAM is evolved from the EDO DRAM and it can access four memory addresses in one burst. It also supports pipeline stages which allow the page access cycle into two parts."
    },
    {
        "id": 268,
        "Question": "Which of the following is more quickly accessed?",
        "Options": [
            "a) RAM",
            "b) Cache memory",
            "c) DRAM",
            "d) SRAM"
        ],
        "Answer": "Answer: b\nExplanation: The cache memory is a small random access memory which is faster than a normal RAM. It has a direct connection with the CPU otherwise, there will be a separate bus for accessing data. The processor will check whether the copy of the required data is present in the cache memory if so it will access the data from the cache memory."
    },
    {
        "id": 269,
        "Question": "Which factor determines the effectiveness of the cache?",
        "Options": [
            "a) hit rate",
            "b) refresh cycle",
            "c) refresh rate",
            "d) refresh time"
        ],
        "Answer": "Answer: a\nExplanation: The proportion of accesses of data that forms the cache hit, which measures the effectiveness of the cache memory."
    },
    {
        "id": 270,
        "Question": "Which of the following determines a high hit rate of the cache memory?",
        "Options": [
            "a) size of the cache",
            "b) number of caches",
            "c) size of the RAM",
            "d) cache access"
        ],
        "Answer": "Answer: a\nExplanation: The size of the cache increases, a large amount of data can be stored, which can access more data which in turn increases the hit rate of the cache memory."
    },
    {
        "id": 271,
        "Question": "Which of the following is a common cache?",
        "Options": [
            "a) DIMM",
            "b) SIMM",
            "c) TLB",
            "d) Cache"
        ],
        "Answer": "Answer: c\nExplanation: The translation lookaside buffer is common cache memory seen in almost all CPUs and desktops which are a part of the memory management unit. It can improve the virtual address translation speed."
    },
    {
        "id": 272,
        "Question": "Which factor determines the number of cache entries?",
        "Options": [
            "a) set commutativity",
            "b) set associativity",
            "c) size of the cache",
            "d) number of caches"
        ],
        "Answer": "Answer: b\nExplanation: The set associativity is a criterion which describes the number of cache entries which could possibly contain the required data."
    },
    {
        "id": 273,
        "Question": "What is the size of the cache for an 8086 processor?",
        "Options": [
            "a) 64 Kb",
            "b) 128 Kb",
            "c) 32 Kb",
            "d) 16 Kb"
        ],
        "Answer": "Answer: a\nExplanation: The 8086 processor have a 64 Kbytes cache, beyond this size, the cost will be extremely high."
    },
    {
        "id": 274,
        "Question": "How many possibilities of mapping does a direct mapped cache have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: The direct mapped cache only have one possibility to fetch data whereas a two-way system, there are two possibilities, for a three-way system, there are three possibilities and so on. It is also known as the one-way set associative cache."
    },
    {
        "id": 275,
        "Question": "Which of the following allows speculative execution?",
        "Options": [
            "a) 12-way set associative cache",
            "b) 8-way set associative cache",
            "c) direct mapped cache",
            "d) 4-way set associative cache"
        ],
        "Answer": "Answer: c\nExplanation: The direct mapped cache has the advantage of allowing a simple and fast speculative execution."
    },
    {
        "id": 276,
        "Question": "Which of the following refers to the number of consecutive bytes which are associated with each cache entry?",
        "Options": [
            "a) cache size",
            "b) associative set",
            "c) cache line",
            "d) cache word"
        ],
        "Answer": "Answer: c\nExplanation: The cache line refers to the number of consecutive bytes which are associated with each cache entry. The data is transferred between the memory and the cache in a particular size which is called a cache line."
    },
    {
        "id": 277,
        "Question": "Which factor determines the cache performance?",
        "Options": [
            "a) software",
            "b) peripheral",
            "c) input",
            "d) output"
        ],
        "Answer": "Answer: a\nExplanation: The cache performance is completely dependent on the system and software. In software, the processor checks out each loop and if a duplicate is found in the cache memory, immediately it is accessed."
    },
    {
        "id": 278,
        "Question": "What are the basic elements required for cache operation?",
        "Options": [
            "a) memory array, multivibrator, counter",
            "b) memory array, comparator, counter",
            "c) memory array, trigger circuit, a comparator",
            "d) memory array, comparator, CPU"
        ],
        "Answer": "Answer: b\nExplanation: The cache memory operation is based on the address tag, that is, the processor generates the address which is provided to the cache and this cache stores its data with an address tag. The tag is compared with the address, if they did not match, the next tag is checked. If they match, a cache hit occurs, the data is passed to the processor. So the basic elements required is a memory array, comparator, and a counter."
    },
    {
        "id": 279,
        "Question": "How many divisions are possible in the cache memory based on the tag or index address?",
        "Options": [
            "a) 3",
            "b) 2",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: c\nExplanation: There is four classification based on the tag or index address corresponds to a virtual or physical address. They are PIPT, VIVT, PIVT, VIPT that is, physically indexed physically tagged, virtually indexed virtually tagged, physically indexed virtually tagged, virtually indexed physically tagged respectively."
    },
    {
        "id": 280,
        "Question": "What does DMA stand for?",
        "Options": [
            "a) direct memory access",
            "b) direct main access",
            "c) data main access",
            "d) data memory address"
        ],
        "Answer": "Answer: a\nExplanation: The DMA is direct memory access which can modify the memory without the help of the processor. If any kind of memory access by DMA to be done, it will passes a request to the processor bus and the processor provides an acknowledgment and gives the control of the bus to the DMA."
    },
    {
        "id": 281,
        "Question": "Which of the following cache has a separate comparator for each entry?",
        "Options": [
            "a) direct mapped cache",
            "b) fully associative cache",
            "c) 2-way associative cache",
            "d) 16-way associative cache"
        ],
        "Answer": "Answer: b\nExplanation: A fully associative cache have a comparator for each entry so that all the entries can be tested simultaneously."
    },
    {
        "id": 282,
        "Question": "What is the disadvantage of a fully associative cache?",
        "Options": [
            "a) hardware",
            "b) software",
            "c) memory",
            "d) peripherals"
        ],
        "Answer": "Answer: a\nExplanation: The major disadvantage of the fully associative cache is the amount of hardware needed for the comparison increases in proportion to the cache size and hence, limits the fully associative cache."
    },
    {
        "id": 283,
        "Question": "How many comparators present in the direct mapping cache?",
        "Options": [
            "a) 3",
            "b) 2",
            "c) 1",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: The direct mapping cache have only one comparator so that only one location possibly have all the data irrespective of the cache size."
    },
    {
        "id": 284,
        "Question": "Which mapping of cache is inefficient in software viewpoint?",
        "Options": [
            "a) fully associative",
            "b) 2 way associative",
            "c) 16 way associative",
            "d) direct mapping"
        ],
        "Answer": "Answer: d\nExplanation: The direct mapping cache organization is simple from the hardware design aspects but it is inefficient in the software viewpoint."
    },
    {
        "id": 285,
        "Question": "Which mechanism splits the external memory storage into memory pages?",
        "Options": [
            "a) index mechanism",
            "b) burst mode",
            "c) distributive mode",
            "d) a software mechanism"
        ],
        "Answer": "Answer: a\nExplanation: The index mechanism splits the external memory storage into a series of memory pages in which each page is the same size as the cache. Each page is mapped to the cache so that each page can have its own location in the cache."
    },
    {
        "id": 286,
        "Question": "Which of the following cache mapping can prevent bus thrashing?",
        "Options": [
            "a) fully associative",
            "b) direct mapping",
            "c) n way set associative",
            "d) 2 way associative"
        ],
        "Answer": "Answer: c\nExplanation: Only one data can be accessed in direct mapping that is, if one word is accessed at a time, all other words are discarded at the same time. This is known as bus thrashing which can be solved by splitting up the caches so there are 2,4,..n possible entries available. The major advantage of the set associative cache is its capability to prevent the bus thrashing at the expense of hardware."
    },
    {
        "id": 287,
        "Question": "Which cache mapping have a sequential execution?",
        "Options": [
            "a) direct mapping",
            "b) fully associative",
            "c) n way set associative",
            "d) burst fill"
        ],
        "Answer": "Answer: d\nExplanation: The burst fill mode of cache mapping have a sequential nature of executing instructions and data access. The instruction fetches and execution accesses to sequential memory locations until it has a jump instruction or a branch instruction. This kind of cache mapping is seen in the MC68030 processor."
    },
    {
        "id": 288,
        "Question": "Which address is used for a tag?",
        "Options": [
            "a) memory address",
            "b) logical address",
            "c) cache address",
            "d) location address"
        ],
        "Answer": "Answer: b\nExplanation: The cache memory uses either a physical address or logical address for its tag data. For a logical cache, the tag refers to a logical address and for a physical cache, the tag refers to the physical address."
    },
    {
        "id": 289,
        "Question": "In which of the following the data is preserved within the cache?",
        "Options": [
            "a) logical cache",
            "b) physical cache",
            "c) unified cache",
            "d) harvard cache"
        ],
        "Answer": "Answer: b\nExplanation: In the physical cache, the data is preserved within the cache because it does not flush out during the context switching but on the other hand, the logical cache flushes out the data and clear it during a context switching."
    },
    {
        "id": 290,
        "Question": "What is the disadvantage of the physical address?",
        "Options": [
            "a) debugging",
            "b) delay",
            "c) data preservation",
            "d) data cleared"
        ],
        "Answer": "Answer: b\nExplanation: The physical address access the data through the memory management unit which causes a delay."
    },
    {
        "id": 291,
        "Question": "Which cache memory solve the cache coherency problem?",
        "Options": [
            "a) physical cache",
            "b) logical cache",
            "c) unified cache",
            "d) harvard cache"
        ],
        "Answer": "Answer: a\nExplanation: The physical cache is more efficient and can provide the cache coherency problem solved and MMU delay is kept to a minimum. PowerPC is an example for this advantage."
    },
    {
        "id": 292,
        "Question": "What type of cache is used in the Intel 80486DX?",
        "Options": [
            "a) logical",
            "b) physical",
            "c) harvard",
            "d) unified"
        ],
        "Answer": "Answer: d\nExplanation: The Intel 80486DX processor has a unified cache. Similarly, Motorola MPC601PC also uses the unified cache. The unified cache has the same mechanism to store both data and instructions."
    },
    {
        "id": 293,
        "Question": "Which of the following has a separate cache for the data and instructions?",
        "Options": [
            "a) unified",
            "b) harvard",
            "c) logical",
            "d) physical"
        ],
        "Answer": "Answer: b\nExplanation: The Harvard cache have a separate cache for the data and the instruction whereas the unified cache has a same cache for the data and instructions."
    },
    {
        "id": 294,
        "Question": "Which type of cache is used the SPARC architecture?",
        "Options": [
            "a) unified",
            "b) harvard",
            "c) logical",
            "d) physical"
        ],
        "Answer": "Answer: c\nExplanation: The SPARC architecture uses logical cache whereas most of the internal cache designed now, uses physical cache because data is not flushed out in this cache."
    },
    {
        "id": 295,
        "Question": "Which of the following approach uses more silicon area?",
        "Options": [
            "a) unified",
            "b) harvard",
            "c) logical",
            "d) physical"
        ],
        "Answer": "Answer: b\nExplanation: The Harvard architecture have a separate bus for data and instruction, therefore, it requires more area. It also uses more silicon area for the second set of tags and the comparators."
    },
    {
        "id": 296,
        "Question": "Which of the following is the biggest challenge in the cache memory design?",
        "Options": [
            "a) delay",
            "b) size",
            "c) coherency",
            "d) memory access"
        ],
        "Answer": "Answer: c\nExplanation: The coherency is a major challenge in designing the cache memory. The cache has to be designed by solving the problem of data coherency while remaining hardware and software compatible."
    },
    {
        "id": 297,
        "Question": "What arises when a copy of data is held both in the cache and in the main memory?",
        "Options": [
            "a) stall data",
            "b) stale data",
            "c) stop data",
            "d) wait for the state"
        ],
        "Answer": "Answer: b\nExplanation: The stale data arises when the copy is held both in the cache memory and in the main memory. If either copy is modified, the other data become stale and the system coherency can be destroyed."
    },
    {
        "id": 298,
        "Question": "In which writing scheme does all the data writes go through to main memory and update the system and cache?",
        "Options": [
            "a) write-through",
            "b) write-back",
            "c) write buffering",
            "d) no caching of writing cycle"
        ],
        "Answer": "Answer: a\nExplanation: There are different writing scheme in the cache memory which increases the cache efficiency and one such is the write-through in which all the data go to the main memory and can update the system as well as the cache."
    },
    {
        "id": 299,
        "Question": "In which writing scheme does the cache is updated but the main memory is not updated?",
        "Options": [
            "a) write-through",
            "b) write-back",
            "c) no caching of writing cycle",
            "d) write buffering"
        ],
        "Answer": "Answer: b\nExplanation: The cache write-back mechanism needs a bus snooping system for the coherency. In this write-back scheme, the cache is updated first and the main memory is not updated."
    },
    {
        "id": 300,
        "Question": "In which writing scheme does the cache is not updated?",
        "Options": [
            "a) write-through",
            "b) write-back",
            "c) write buffering",
            "d) no caching of writing cycle"
        ],
        "Answer": "Answer: d\nExplanation: The no caching write cycle does not update the cache but the data is written to the cache. If the previous data had cached, that entry is invalid and will not use. This makes the processor fetch data directly from the main memory."
    },
    {
        "id": 301,
        "Question": "Which writing mechanism forms the backbone of the bus snooping mechanism?",
        "Options": [
            "a) write-back",
            "b) write-through",
            "c) no caching of write cycles",
            "d) write buffer"
        ],
        "Answer": "Answer: c\nExplanation: The no caching of write cycle seems to be wasteful because it does not update the cache, and if any previous data is cached, that entry might be an error and is not used. So the processor access data from the main memory but this writing scheme forms the backbone of the bus snooping system for the coherency issue."
    },
    {
        "id": 302,
        "Question": "What is the main idea of the writing scheme in the cache memory?",
        "Options": [
            "a) debugging",
            "b) accessing data",
            "c) bus snooping",
            "d) write-allocate"
        ],
        "Answer": "Answer: c\nExplanation: There are four main writing scheme in the cache memory which is, write-through, write-back, no caching of the write cycle and write buffer. All these writing schemes are designed for bus snooping which can reduce the coherency."
    },
    {
        "id": 303,
        "Question": "In which scheme does the data write via a buffer to the main memory?",
        "Options": [
            "a) write buffer",
            "b) write-back",
            "c) write-through",
            "d) no caching of the write cycle"
        ],
        "Answer": "Answer: a\nExplanation: The write-buffer is slightly similar to the write-through mechanism in which data is written to the main memory but in write buffer mechanism data writes to the main memory via a buffer."
    },
    {
        "id": 304,
        "Question": "Which of the following can allocate entries in the cache for any data that is written out?",
        "Options": [
            "a) write-allocate cache",
            "b) read-allocate cache",
            "c) memory-allocate cache",
            "d) write cache"
        ],
        "Answer": "Answer: a\nExplanation: A write-allocate cache allocates the entries in the cache for any data that is written out. If the data is transferred to the external memory so that, when it is accessed again, the data is already waiting in the cache. It works efficiently if the size of the cache is large and it does not overwrite even though it is advantageous."
    },
    {
        "id": 305,
        "Question": "Which of the following uses a bus snooping mechanism?",
        "Options": [
            "a) MC88100",
            "b) 8086",
            "c) 8051",
            "d) 80286"
        ],
        "Answer": "Answer: a\nExplanation: The bus snooping mechanism uses a combination of cache tag status, write policies and bus monitoring to ensure coherency. MC88100 or MC88200 uses bus snooping mechanism."
    },
    {
        "id": 306,
        "Question": "What leads to the development of MESI and MEI protocol?",
        "Options": [
            "a) cache size",
            "b) cache coherency",
            "c) bus snooping",
            "d) number of caches"
        ],
        "Answer": "Answer: b\nExplanation: The problem of cache coherency lead to the formation of two standard mechanisms called MESI and MEI protocol. MC88100 have MESI protocol and MC68040 uses an MEI protocol."
    },
    {
        "id": 307,
        "Question": "Which of the following is also known as Illinois protocol?",
        "Options": [
            "a) MESI protocol",
            "b) MEI protocol",
            "c) Bus snooping",
            "d) Modified exclusive invalid"
        ],
        "Answer": "Answer: a\nExplanation: The MESI protocol is also known as Illinois protocol because of its formation at the University of Illinois."
    },
    {
        "id": 308,
        "Question": "What does MESI stand for?",
        "Options": [
            "a) modified exclusive stale invalid",
            "b) modified exclusive shared invalid",
            "c) modified exclusive system input",
            "d) modifies embedded shared invalid"
        ],
        "Answer": "Answer: b\nExplanation: The MESI protocol supports a shared state which is a formal mechanism for controlling the cache coherency by using the bus snooping techniques. MESI refers to the states that cached data can access. In MESI protocol, multiple processors can cache shared data."
    },
    {
        "id": 309,
        "Question": "What does MEI stand for?",
        "Options": [
            "a) modified embedded invalid",
            "b) modified embedded input",
            "c) modified exclusive invalid",
            "d) modified exclusive input"
        ],
        "Answer": "Answer: c\nExplanation: MEI protocol is less complex and is easy to implement. It does not allow shared state for the cache."
    },
    {
        "id": 310,
        "Question": "Which protocol does MPC601 use?",
        "Options": [
            "a) MESI protocol",
            "b) MEI protocol",
            "c) MOSI protocol",
            "d) MESIF protocol"
        ],
        "Answer": "Answer: a\nExplanation: MPC601 uses a MESI protocol, that is they have a shared state for data accessing in the cache. It can reduce the cache coherency but the cache coherency is processor specific. So different processors have different cache coherency implementations."
    },
    {
        "id": 311,
        "Question": "Which of the following include special address generation and data latches?",
        "Options": [
            "a) burst interface",
            "b) peripheral interface",
            "c) dma",
            "d) input-output interfacing"
        ],
        "Answer": "Answer: a\nExplanation: The burst interfacing has special memory interfaces which include special address generation and data latches that help in the high performance of the processors. It takes the advantages of both the nibble mode memories and paging."
    },
    {
        "id": 312,
        "Question": "Which of the following makes use of the burst fill technique?",
        "Options": [
            "a) burst interfaces",
            "b) dma",
            "c) peripheral interfaces",
            "d) input-output interfaces"
        ],
        "Answer": "Answer: a\nExplanation: The burst interfaces use the burst fill technique in which the processor will access four words in succession, which fetches the complete cache line or written out to the memory."
    },
    {
        "id": 313,
        "Question": "How did burst interfaces access faster memory?",
        "Options": [
            "a) segmentation",
            "b) dma",
            "c) static column memory",
            "d) memory"
        ],
        "Answer": "Answer: c\nExplanation: The speed of the memory can be improved by the page mode or the static column memory which offer a faster access in a single cycle."
    },
    {
        "id": 314,
        "Question": "Which of the following memory access can reduce the clock cycles?",
        "Options": [
            "a) bus interfacing",
            "b) burst interfacing",
            "c) dma",
            "d) dram"
        ],
        "Answer": "Answer: b\nExplanation: The burst interfaces reduces the clock cycles. For fetching four words with a three clock memory, it will take 12 clock cycle but in the burst interface, it will only take five clocks to access the data."
    },
    {
        "id": 315,
        "Question": "How many clocks are required for the first access in the burst interface?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: In the burst interface, the first access of the memory address requires two clock cycles and a single cycle for the remaining memory address."
    },
    {
        "id": 316,
        "Question": "In which of the following access, the address is supplied?",
        "Options": [
            "a) the first access",
            "b) the second access",
            "c) third access",
            "d) fourth access"
        ],
        "Answer": "Answer: a\nExplanation: In the burst interface, the address is supplied only for the first access and not for the remaining accesses. An external logic is required for the additional addresses for the memory interface."
    },
    {
        "id": 317,
        "Question": "What type of timing is required for the burst interfaces?",
        "Options": [
            "a) synchronous",
            "b) equal",
            "c) unequal",
            "d) symmetrical"
        ],
        "Answer": "Answer: c\nExplanation: The burst interfacing uses an unequal timing. It takes two clocks for the first access and only one for the remaining accesses which make it an unequal timing."
    },
    {
        "id": 318,
        "Question": "How can gate delays be reduced?",
        "Options": [
            "a) synchronous memory",
            "b) asynchronous memory",
            "c) pseudo asynchronous memory",
            "d) symmetrical memory"
        ],
        "Answer": "Answer: a\nExplanation: The burst interfaced is associated with the SRAM and for the efficiency of the SRAM, it uses a synchronous memory on-chip latches to reduce the gate delays."
    },
    {
        "id": 319,
        "Question": "In which memory does the burst interfaces act as a part of the cache?",
        "Options": [
            "a) DRAM",
            "b) ROM",
            "c) SRAM",
            "d) Flash memory"
        ],
        "Answer": "Answer: c\nExplanation: The burst interface is associated with the static RAM."
    },
    {
        "id": 320,
        "Question": "Which of the following uses a wrap around burst interfacing?",
        "Options": [
            "a) MC68030",
            "b) MC68040",
            "c) HyperBus",
            "d) US 5729504 A"
        ],
        "Answer": "Answer: b\nExplanation: MC68040  is developed by the Motorola which uses a wrap around burst interfacing. MC68030 is also developed by Motorola but it uses a linear line fill burst. HyperBus can switch to both linear and wrap around burst. US 5729504 A uses a linear burst fill."
    },
    {
        "id": 321,
        "Question": "Which of the following is a Motorola’s protocol product?",
        "Options": [
            "a) MCM62940",
            "b) Avalon",
            "c) Slave interfaces",
            "d) AXI slave interfaces"
        ],
        "Answer": "Answer: a\nExplanation: MCM62940 protocol is developed by Motorola, whereas Slave interfaces, AXI slave interfaces are for ARM. Avalon is developed by Altera."
    },
    {
        "id": 322,
        "Question": "Which of the following uses a linear line fill interfacing?",
        "Options": [
            "a) MC68040",
            "b) MC68030",
            "c) US 74707 B2",
            "d) Hyper Bus"
        ],
        "Answer": "Answer: b\nExplanation: MC68030 uses a linear burst fill whereas MC68040, US 74707 B2 uses to wrap around burst interfacing. HyperBus can switch to both linear and wrap around interfacing."
    },
    {
        "id": 323,
        "Question": "Which of the following protocol matches the Intel 80486?",
        "Options": [
            "a) MCM62940",
            "b) MCM62486",
            "c) US 74707 B2",
            "d) Hyper Bus"
        ],
        "Answer": "Answer: b\nExplanation: The MCM62486 has an on-chip counter that matches the Intel 80486 and is developed by the Motorola."
    },
    {
        "id": 324,
        "Question": "Which of the following protocol matches the MC68040?",
        "Options": [
            "a) MCM62486",
            "b) US 5729504 A",
            "c) HyperBus",
            "d) MCM62940"
        ],
        "Answer": "Answer: d\nExplanation:  The MCM62940 and MCM62486 are the specific protocols developed by Motorola, in which the MCM62940 has an on-chip counter which matches the wrap-around burst interfacing of the MC68040."
    },
    {
        "id": 325,
        "Question": "The modified bit is also known as",
        "Options": [
            "a) dead bit",
            "b) neat bit",
            "c) dirty bit",
            "d) invalid bit"
        ],
        "Answer": "Answer:c\nExplanation: The dirty bit is said to be set if the processor modifies its memory. This bit indicates that the associative set of blocks regarding the memory is modified and has not yet saved to the storage."
    },
    {
        "id": 326,
        "Question": "Which of the following have an 8 KB page?",
        "Options": [
            "a) DEC Alpha",
            "b) ARM",
            "c) VAX",
            "d) PowerPC"
        ],
        "Answer": "Answer:a\nExplanation: DEC Alpha divides its memory into 8KB pages whereas VAX is a small page which is only 512 bytes in size. PowerPC pages are normally 4 KB and ARM is having 4 KB and 64 KB pages."
    },
    {
        "id": 327,
        "Question": "Which of the following address is seen by the memory unit?",
        "Options": [
            "a) logical address",
            "b) physical address",
            "c) virtual address",
            "d) memory address"
        ],
        "Answer": "Answer: b\nExplanation: The logical address is the address generated by the CPU. It is also known as virtual address. The physical address is the address which is seen by the memory unit."
    },
    {
        "id": 328,
        "Question": "Which of the following modes offers segmentation in the memory?",
        "Options": [
            "a) virtual mode",
            "b) real mode",
            "c) protected mode",
            "d) memory mode"
        ],
        "Answer": "Answer: c\nExplanation: The main memory can split into small blocks by the method of paging and segmentation and these mechanisms are possible only in protected mode."
    },
    {
        "id": 329,
        "Question": "Which of the following is necessary for the address translation in the protected mode?",
        "Options": [
            "a) descriptor",
            "b) paging",
            "c) segmentation",
            "d) memory"
        ],
        "Answer": "Answer: a\nExplanation: The address translation from the logical address to physical address partitions the main memory into different blocks which is called segmentation. Each of these blocks have a descriptor which possesses a descriptor table. So the size of every block is very important for the descriptor."
    },
    {
        "id": 330,
        "Question": "What does “G” in the descriptor entry describe?",
        "Options": [
            "a) gain",
            "b) granularity",
            "c) gate voltage",
            "d) global descriptor"
        ],
        "Answer": "Answer: b\nExplanation: The granularity bit controls the resolution of the segmented memory. When it is set to logic one, the resolution is 4 KB. When the granularity bit is set to logic zero, the resolution is 1 byte."
    },
    {
        "id": 331,
        "Question": "How many types of tables are used by the processor in the protected mode?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: There are two types of descriptor table used by the processor in the protected mode which are GDT and LDT, that is global descriptor table and local descriptor table respectively."
    },
    {
        "id": 332,
        "Question": "What does the table indicator indicate when it is set to one?",
        "Options": [
            "a) GDT",
            "b) LDT",
            "c) remains unchanged",
            "d) toggles with GTD and LTD"
        ],
        "Answer": "Answer: b\nExplanation: The table indicator is a part of selector that selects which table is to be used. If the table indicator is set to logic one, the will use the local descriptor table and if the table indicator is set to logic zero, it will use the global descriptor table."
    },
    {
        "id": 333,
        "Question": "What does GDTR stand for?",
        "Options": [
            "a) global descriptor table register",
            "b) granularity descriptor table register",
            "c) gate register",
            "d) global direct table register"
        ],
        "Answer": "Answer: a\nExplanation: The global descriptor table register is a special register which have the linear address and the size of its own GDT. Both the global descriptor table register and local descriptor table register are located in the global descriptor table."
    },
    {
        "id": 334,
        "Question": "What does PMMU stands for?",
        "Options": [
            "a) protection mode memory management unit",
            "b) paged memory management unit",
            "c) physical memory management unit",
            "d) paged multiple management unit"
        ],
        "Answer": "Answer: b\nExplanation: The paged memory management unit is used to decrease the amount of storage needed in the page tables, that is, a multi-level tree structure is used. MC68030, PowerPC, ARM 920 uses a paged memory management unit."
    },
    {
        "id": 335,
        "Question": "Which of the following support virtual memory?",
        "Options": [
            "a) segmentation",
            "b) descriptor",
            "c) selector",
            "d) paging"
        ],
        "Answer": "Answer: d\nExplanation: The paging mechanism supports the virtual memory. Paging helps in creating virtual address space which has a major role in memory management."
    },
    {
        "id": 336,
        "Question": "What does DPL in the descriptor describes?",
        "Options": [
            "a) descriptor page level",
            "b) descriptor privilege level",
            "c) direct page level",
            "d) direct page latch"
        ],
        "Answer": "Answer: b\nExplanation: The descriptor privilege level is used to restrict access to the segment which helps in protection mechanism. It acquires two bit of the descriptor."
    },
    {
        "id": 337,
        "Question": "What does “S” bit describe in a descriptor?",
        "Options": [
            "a) descriptor type",
            "b) small type",
            "c) page type",
            "d) segmented type"
        ],
        "Answer": "Answer: a\nExplanation: The S bit determines whether it is a system segment or a normal segment. When the S bit is set, it might be a code segment or a data segment. If the S bit clears, it is a system segment."
    },
    {
        "id": 338,
        "Question": "How many regions are created by the memory range in the ARM architecture?",
        "Options": [
            "a) 4",
            "b) 8",
            "c) 16",
            "d) 32"
        ],
        "Answer": "Answer: b\nExplanation: The memory protection unit in the ARM architecture divides the memory into eight separate regions. Each region can be small as well as big ranging from 4 Kbytes to 4 Gbytes."
    },
    {
        "id": 339,
        "Question": "How many bits does the memory region in the ARM memory protection unit have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: The memory region possesses three bits which are the cacheable bit, bufferable bit and access permission bit."
    },
    {
        "id": 340,
        "Question": "Which of the following uses a priority level for permitting data?",
        "Options": [
            "a) ARM memory management unit",
            "b) ARM protection memory management unit",
            "c) Bus interface unit",
            "d) Execution unit"
        ],
        "Answer": "Answer: b\nExplanation: In the ARM protection architecture, the memory is divided into some regions of size 4 Kbytes to 4 Gbytes. These regions possess bits called the cacheable bit, buffer bit, and access permitted bits. The regions are numbered as per priority level for which the permission bits takes the precedence if any of the regions gets overlapped."
    },
    {
        "id": 341,
        "Question": "What type of bit in the ARM memory mimics to that of the protection unit of ARM management unit?",
        "Options": [
            "a) permission bit",
            "b) buffer bit",
            "c) cacheable bit",
            "d) access permission bit"
        ],
        "Answer": "Answer: a\nExplanation: The ARM architecture memory protection unit divides the memory range into different regions of size ranging from 4 Kbytes to 4 Gbytes. Each region is associated with certain bits called the cacheable bit, buffer bit, and access permitted bit. These bits are similar to the permission bit in the ARM memory management unit architecture which is stored in the control register."
    },
    {
        "id": 342,
        "Question": "Which of the following bits are used to control the cache behaviour?",
        "Options": [
            "a) cacheable bit",
            "b) buffer bit",
            "c) cacheable bit and buffer bit",
            "d) cacheable bit, buffer bit and permission access bit"
        ],
        "Answer": "Answer: c\nExplanation: The cacheable bit and the buffer bit are used to control the behaviour of cache. Depending on the cacheable bit and the buffer bit, the memory access will complete successfully."
    },
    {
        "id": 343,
        "Question": "Which of the following unit provides security to the processor?",
        "Options": [
            "a) bus interface unit",
            "b) execution unit",
            "c) peripheral unit",
            "d) memory protection unit"
        ],
        "Answer": "Answer: d\nExplanation: The memory management unit and the memory protection unit provides security to the processor by trapping the invalid memory accesses before they corrupt other data."
    },
    {
        "id": 344,
        "Question": "Which of the following includes a tripped down memory management unit?",
        "Options": [
            "a) memory protection unit",
            "b) memory real mode",
            "c) memory management unit",
            "d) bus interface unit"
        ],
        "Answer": "Answer: a\nExplanation: The memory protection unit allows a tripped memory down memory management unit in which the memories are partitioned and protected without any address translation. This can remove the time consumption in the address translation thereby increases the speed."
    },
    {
        "id": 345,
        "Question": "Which of the following can reduce the chip size?",
        "Options": [
            "a) memory management unit",
            "b) execution unit",
            "c) memory protection unit",
            "d) bus interface unit"
        ],
        "Answer": "Answer: c\nExplanation: The memory protection unit have many advantages over the other units. It can reduce the chip size, cost and power consumption."
    },
    {
        "id": 346,
        "Question": "How does the memory management unit provide the protection?",
        "Options": [
            "a) disables the address translation",
            "b) enables the address translation",
            "c) wait for the address translation",
            "d) remains unchanged"
        ],
        "Answer": "Answer: a\nExplanation: The memory management unit can be used as a protection unit by disabling the address translation that is, the physical address and the logical address are the same."
    },
    {
        "id": 347,
        "Question": "Which of the following is used to start a supervisor level?",
        "Options": [
            "a) error signal",
            "b) default signal",
            "c) wait for the signal",
            "d) interrupt signal"
        ],
        "Answer": "Answer: a\nExplanation: If memory access from the software does not access the correct data, an error signal is generated which will start a supervisor level software for the decision."
    },
    {
        "id": 348,
        "Question": "What happens when a task attempts to access memory outside its own address space?",
        "Options": [
            "a) paging fault",
            "b) segmentation fault",
            "c) wait",
            "d) remains unchanged"
        ],
        "Answer": "Answer: b\nExplanation: Different tasks assign their own address space and whenever a task access memory outside its own address space, a segmentation fault result and which in turn results in the termination of the offending application."
    },
    {
        "id": 349,
        "Question": "Which of the following can transfer multiple bits of data simultaneously?",
        "Options": [
            "a) serial port",
            "b) sequential port",
            "c) concurrent unit",
            "d) parallel port"
        ],
        "Answer": "Answer: d\nExplanation: The parallel port can transfer multiple bits of data simultaneously. It provides the input or output binary data with a single bit allocated to each pin within the port."
    },
    {
        "id": 350,
        "Question": "Which of the following are interfaced as inputs to the parallel ports?",
        "Options": [
            "a) LEDs",
            "b) switch",
            "c) alphanumeric display",
            "d) seven segmented display"
        ],
        "Answer": "Answer: b\nExplanation: The LEDs, alphanumeric displays, seven segment displays are interfaced for the output whereas the switch is an input port."
    },
    {
        "id": 351,
        "Question": "Which of the following are interfaced as the outputs to the parallel ports?",
        "Options": [
            "a) keyboards",
            "b) switches",
            "c) LEDs",
            "d) knobs"
        ],
        "Answer": "Answer: c\nExplanation: The keyboards, switches, and knobs are used as output whereas the LEDs are used as the input port."
    },
    {
        "id": 352,
        "Question": "How many registers are there to control the parallel port in the basic form?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 2",
            "d) 5"
        ],
        "Answer": "Answer: c\nExplanation: The basic operation of the parallel port dealt with two types of registers which are called data direction register and the data register."
    },
    {
        "id": 353,
        "Question": "Which of the following is also known as tri-state?",
        "Options": [
            "a) output port",
            "b) input port",
            "c) parallel port",
            "d) output-input port"
        ],
        "Answer": "Answer: a\nExplanation: The progression in the parallel ports provides a third register or an individual control bit which can make the pin in a high impedance state. An output port which can do this is also known as tri-state, that is, logic high, logic low and a high impedance state."
    },
    {
        "id": 354,
        "Question": "How buffers are enabled in the parallel ports?",
        "Options": [
            "a) by the data register",
            "b) by data direction register",
            "c) by individual control register",
            "d) by data and individual control register"
        ],
        "Answer": "Answer: b\nExplanation: The implementation of parallel port uses a couple of buffers which are enabled by the data direction register by setting the corresponding bit of the register."
    },
    {
        "id": 355,
        "Question": "Which of the following registers offers high impedance?",
        "Options": [
            "a) data register",
            "b) data direction register",
            "c) individual control bit",
            "d) data register and data direction register"
        ],
        "Answer": "Answer: c\nExplanation: The register which offers high impedance is the individual control bit or the third register which can be implemented by switching off both the buffers and putting their connections to the pin which offers high impedance."
    },
    {
        "id": 356,
        "Question": "Which of the following can be used as a chip select?",
        "Options": [
            "a) multifunction I/O port",
            "b) parallel port",
            "c) DMA port",
            "d) memory port"
        ],
        "Answer": "Answer: a\nExplanation: The multifunction I/O port can also be used a chip select for the memory design. The function that the pin performs is set up internally through the use of a function register which internally configures how the external pins are connected internally."
    },
    {
        "id": 357,
        "Question": "Which of the following is necessary for the parallel input-output port?",
        "Options": [
            "a) inductor",
            "b) pull-up resistor",
            "c) push-up resistor",
            "d) capacitor"
        ],
        "Answer": "Answer: b\nExplanation: The I/O port needs an external pull-up resistor. In some devices, it offers internally. If it is not provided, it can cause incorrect data on reading the port and it prevents the port from turning off an external device."
    },
    {
        "id": 358,
        "Question": "Which of the following can be described as general-purpose?",
        "Options": [
            "a) multifunction I/O port",
            "b) input port",
            "c) dma port",
            "d) output port"
        ],
        "Answer": "Answer: a\nExplanation: The multifunction I/O ports can be described as the general-purpose and it can be shared with other peripherals."
    },
    {
        "id": 359,
        "Question": "Which of the following helps in the generation of waveforms?",
        "Options": [
            "a) timer",
            "b) inputs",
            "c) outputs",
            "d) memory"
        ],
        "Answer": "Answer: a\nExplanation: The embedded systems have a timing component called timer or counter which helps in the timing reference for control sequence, provides system tick for the operating system and also helps in the generation of waveforms for the serial port baud rate generation."
    },
    {
        "id": 360,
        "Question": "Which bit size determines the slowest frequency?",
        "Options": [
            "a)  counter size",
            "b) pre-scalar value",
            "c) counter",
            "d) timer"
        ],
        "Answer": "Answer: b\nExplanation: The pre-scalar value determines the slowest frequency that can be generated from a given clock input. Actually the bit size are determined by the pre-scalar value and the conuter size."
    },
    {
        "id": 361,
        "Question": "Which bit size determines the maximum value of the counter-derived period?",
        "Options": [
            "a) counter size",
            "b) pre-scalar value",
            "c) bit size",
            "d) byte size"
        ],
        "Answer": "Answer: a\nExplanation: The bit size are basically determined by its fundamental properties, that is, the pre-scalar value and the counter size. The counter size determines the maximum value of the counter derived period."
    },
    {
        "id": 362,
        "Question": "Which of the following timer is suitable for IBM PC?",
        "Options": [
            "a) IA-32",
            "b) Intel 8253",
            "c) Intel 64",
            "d) 8051 timer"
        ],
        "Answer": "Answer: b\nExplanation: The Intel 8253 timer is suitable for the IBM PC. IA-32 and Intel 64 are the offload timers used only for Intel. The 8051 timer is used for the timing program in 8051."
    },
    {
        "id": 363,
        "Question": "Which of the following is mode 0 in 8253?",
        "Options": [
            "a) interrupt on start count",
            "b) interrupt for wait statement",
            "c) interrupt on terminal count",
            "d) no interrupt"
        ],
        "Answer": "Answer: c\nExplanation: The interrupt on the terminal count is known as mode 0 for the 8253.  An initial value is loaded into the count register and then starts to count down at the frequency which is determined by the clock input. When the count reaches zero, an interrupt is generated."
    },
    {
        "id": 364,
        "Question": "Which determines the mode 1 in the Intel 8253?",
        "Options": [
            "a) interrupt on terminal count",
            "b) programmable one-shot",
            "c) rate generator",
            "d) square wave rate generator"
        ],
        "Answer": "Answer: b\nExplanation: Programmable one-shot is also known as mode 1 in the Intel 8253. In mode 1, a single pulse with a programmable duration is created first and then the pulse length is loaded into the counter and when the external gate signal is high, the rising edge starts the counter to count down to zero and the counter output signal goes high to start the external pulse. When the counter reaches to zero, the counter output goes low and thus the ending of the pulse."
    },
    {
        "id": 365,
        "Question": "Which mode of 8253 can provide pulse width modulation?",
        "Options": [
            "a) programmable one-shot",
            "b) square wave rate generator",
            "c) software triggered strobe",
            "d) hardware triggered strobe"
        ],
        "Answer": "Answer: a\nExplanation: Mode 1 of the Intel 8253 can provide pulse width modulation for the power control where the gate is connected to a zero crossing detector or a clock source."
    },
    {
        "id": 366,
        "Question": "Which of the following is the mode 3 in the Intel timer 8253?",
        "Options": [
            "a) rate generator",
            "b) hardware triggered strobe",
            "c) square wave rate generator",
            "d) software triggered strobe"
        ],
        "Answer": "Answer: a\nExplanation: The rate generator is the mode 3 in Intel 8253 timer.  The square wave generator is the mode 4 and the hardware triggered strobe is the mode 5 in the Intel 8253 timer."
    },
    {
        "id": 367,
        "Question": "Which of the following determines the rate generation?",
        "Options": [
            "a) divide by N",
            "b) multiply by N",
            "c) addition by N",
            "d) subtraction by N"
        ],
        "Answer": "Answer: a\nExplanation: The rate generator mode is determined by the mode 3 with the Intel 8253. It is a simple divide by N mode where N is the initial value loaded into the counter."
    },
    {
        "id": 368,
        "Question": "Which mode of the Intel 8253 timer can generate a square wave?",
        "Options": [
            "a) mode 1",
            "b) mode 2",
            "c) mode 3",
            "d) mode 4"
        ],
        "Answer": "Answer: d\nExplanation: The mode 4 is the square wave generator. This mode is similar to mode 3 except that the waveform is a square wave."
    },
    {
        "id": 369,
        "Question": "Which mode of the Intel timer 8253 provides a software watchdog timer?",
        "Options": [
            "a) rate generator",
            "b) hardware triggered strobe",
            "c) square wave rate generator",
            "d) software triggered strobe"
        ],
        "Answer": "Answer: d\nExplanation: The software triggered strobe can be used as a software-based watchdog timer in which the output is connected to a non maskable interrupt."
    },
    {
        "id": 370,
        "Question": "Which of the following mode is similar to the mode 4 of the 8253 timer?",
        "Options": [
            "a) mode 5",
            "b) mode 6",
            "c) mode 0",
            "d) mode 1"
        ],
        "Answer": "Answer: a\nExplanation: The mode 5 or the hardware triggered strobe is similar to the mode 4 or the square wave rate generator expect that the retriggering is done by the external gate pin."
    },
    {
        "id": 371,
        "Question": "Which pin of 8253 is used for the generation of an external interrupt signal?",
        "Options": [
            "a) OUT pin",
            "b) IN pin",
            "c) Interrupt pin",
            "d) Ready pin"
        ],
        "Answer": "Answer: a\nExplanation: The Intel 8253 timer has no interrupt pins. Therefore, the timer OUT pin is used to generate an external interrupt signal."
    },
    {
        "id": 372,
        "Question": "Which timer architecture can provide a higher resolution than Intel 8253?",
        "Options": [
            "a) Intel 8253",
            "b) Intel 8254",
            "c) 8051 timer",
            "d) MC68230"
        ],
        "Answer": "Answer: d\nExplanation: The Intel 8253 and 8254 have same pin configuration and functions. 8051 timer is a programmable timer in the 8051 microcontroller. The MC68230 timer developed by Motorola can provide a powerful timer architecture which can provide higher resolution than the Intel 8253."
    },
    {
        "id": 373,
        "Question": "How many bit architecture does MC68230 have?",
        "Options": [
            "a) 16",
            "b) 24",
            "c) 32",
            "d) 40"
        ],
        "Answer": "Answer: b\nExplanation: The MC68230 timer have a 24-bit architecture which is split into three 8-bit components because of the 8-bit bus in the MC68000 CPU."
    },
    {
        "id": 374,
        "Question": "How many bit bus does MC68230 have?",
        "Options": [
            "a) 2",
            "b) 4",
            "c) 8",
            "d) 16"
        ],
        "Answer": "Answer: c\nExplanation: The MC68230 timer have a 24-bit architecture which is split into three 8-bit components because of the 8-bit bus which is used for the communication with the host processor like MC68000 CPU which have an 8-bit architecture."
    },
    {
        "id": 375,
        "Question": "Which of the following is a timer processor?",
        "Options": [
            "a) Intel  8253",
            "b) MC146818",
            "c) MC68332",
            "d) Intel 8259"
        ],
        "Answer": "Answer: c\nExplanation: Intel 8253 and 8259 are timers or counters which supports the processors. MC146818 is a real-time clock. MC68332 which is developed by Motorola is a 32 bit timer processor which can support MC68020."
    },
    {
        "id": 376,
        "Question": "What is the running frequency of MC68332?",
        "Options": [
            "a) 12 MHz",
            "b) 14 MHz",
            "c) 16 MHz",
            "d) 18 MHz"
        ],
        "Answer": "Answer: c\nExplanation: The running frequency of the MC68332 is 16 MHz."
    },
    {
        "id": 377,
        "Question": "Which of the following is a real time clock?",
        "Options": [
            "a) MC146818",
            "b) 8253",
            "c) 8259",
            "d) 8254"
        ],
        "Answer": "Answer: a\nExplanation: The 8253, 8254 and 8259 are timers or counters developed by Intel whereas MC146818 is a real-time clock."
    },
    {
        "id": 378,
        "Question": "Which of the following is the pin efficient method of communicating between other devices?",
        "Options": [
            "a) serial port",
            "b) parallel port",
            "c) peripheral port",
            "d) memory port"
        ],
        "Answer": "Answer: a\nExplanation: The serial ports are considered to be the pin efficient method of communication between other devices within an embedded system."
    },
    {
        "id": 379,
        "Question": "Which of the following depends the number of bits that are transferred?",
        "Options": [
            "a) wait statement",
            "b) ready statement",
            "c) time",
            "d) counter"
        ],
        "Answer": "Answer: c\nExplanation: The time taken for the data transmission within the system depends on the clock frequency and the number of bits that are transferred."
    },
    {
        "id": 380,
        "Question": "Which of the following is the most commonly used buffer in the serial porting?",
        "Options": [
            "a) LIFO",
            "b) FIFO",
            "c) FILO",
            "d) LILO"
        ],
        "Answer": "Answer: b\nExplanation: Most of the serial ports uses a FIFO buffer so that the data is not lost. The FIFO buffer is read to receive the data, that is, first in first out."
    },
    {
        "id": 381,
        "Question": "What does SPI stand for?",
        "Options": [
            "a) serial parallel interface",
            "b) serial peripheral interface",
            "c) sequential peripheral interface",
            "d) sequential port interface"
        ],
        "Answer": "Answer: b\nExplanation: The serial parallel interface bus is a commonly used interface which involves master slave mechanism. The shift registers are worked as master and the slave devices are driven by a common clock."
    },
    {
        "id": 382,
        "Question": "Which allows the full duplex synchronous communication between the master and the slave?",
        "Options": [
            "a) SPI",
            "b) serial port",
            "c) I2C",
            "d) parallel port"
        ],
        "Answer": "Answer: a\nExplanation: The serial peripheral interface allows the full duplex synchronous communication between the master and the slave devices. MC68HC05 developed by Motorola uses SPI for interfacing the peripheral devices."
    },
    {
        "id": 383,
        "Question": "Which of the following processor uses SPI for interfacing?",
        "Options": [
            "a) 8086",
            "b) 8253",
            "c) 8254",
            "d) MC68HC11"
        ],
        "Answer": "Answer: d\nExplanation: The MC68HC05 and MC68HC11 microcontrollers use the serial peripheral interface for the peripheral interfacing."
    },
    {
        "id": 384,
        "Question": "In which register does the data is written in the master device?",
        "Options": [
            "a) index register",
            "b) accumulator",
            "c) SPDR",
            "d) status register"
        ],
        "Answer": "Answer: c\nExplanation: The serial peripheral interface follows a master slave mechanism in which the data is written to the SPDR register in the master device and clocked out into the slave device SPDR by using a common clock signal called SCK."
    },
    {
        "id": 385,
        "Question": "What happens when 8 bits are transferred in the SPI?",
        "Options": [
            "a) wait statement",
            "b) ready statement",
            "c) interrupt",
            "d) remains unchanged"
        ],
        "Answer": "Answer: c\nExplanation: The interrupts are locally generated when 8-bits are transferred so that the data can be read before the next byte is clocked through."
    },
    {
        "id": 386,
        "Question": "Which signal is used to select the slave in the serial peripheral interfacing?",
        "Options": [
            "a) slave select",
            "b) master select",
            "c) interrupt",
            "d) clock signal"
        ],
        "Answer": "Answer: a\nExplanation: The slave select signal selects which slave is to receive data from the master."
    },
    {
        "id": 387,
        "Question": "How much time period is necessary for the slave to receive the interrupt and transfer the data?",
        "Options": [
            "a) 4 clock time period",
            "b) 8 clock time period",
            "c) 16 clock time period",
            "d) 24 clock time period"
        ],
        "Answer": "Answer: b\nExplanation: The SPI uses an eight clock time period for the slave to receive the interrupt and transfer the data which determines the maximum data rate."
    },
    {
        "id": 388,
        "Question": "What does I2C stand for?",
        "Options": [
            "a) inter-IC",
            "b) intra-IC",
            "c) individual integrated chip",
            "d) intel IC"
        ],
        "Answer": "Answer: a\nExplanation: The I2C is known as inter-IC, which is developed by Philips for interfacing with the peripheral devices."
    },
    {
        "id": 389,
        "Question": "Which company developed I2C?",
        "Options": [
            "a) Intel",
            "b) Motorola",
            "c) Phillips",
            "d) IBM"
        ],
        "Answer": "Answer: c\nExplanation: The I2C is developed by Philips for use within the television sets."
    },
    {
        "id": 390,
        "Question": "Which of the following is the most known simple interface?",
        "Options": [
            "a) I2C",
            "b) Serial port",
            "c) Parallel port",
            "d) SPI"
        ],
        "Answer": "Answer: a\nExplanation: The I2C is the most known simple interface which is used currently. It can combine both the hardware and the software protocols to provide a bus interface which helps in the communication with many peripherals."
    },
    {
        "id": 391,
        "Question": "Which are the two lines used in the I2C?",
        "Options": [
            "a) SDA and SPDR",
            "b) SPDR and SCL",
            "c) SDA and SCL",
            "d) SCL and status line"
        ],
        "Answer": "Answer: c\nExplanation: The I2C bus consists of two lines which are called SDA and SCL. The master and slave devices are attached to these lines."
    },
    {
        "id": 392,
        "Question": "Which of the following developed P82B715?",
        "Options": [
            "a) Philips",
            "b) Intel",
            "c) IBM",
            "d) Motorola"
        ],
        "Answer": "Answer: a\nExplanation: The special buffer chip, P82B715 for increasing the current drive is developed by Philips."
    },
    {
        "id": 393,
        "Question": "Which pin provides the reference clock for the transfer of data?",
        "Options": [
            "a) SDA",
            "b) SCL",
            "c) SPDR",
            "d) Interrupt pin"
        ],
        "Answer": "Answer: b\nExplanation: The SCL pin can provide the reference clock for the transmission of data but it is not a free running clock."
    },
    {
        "id": 394,
        "Question": "Which of the following are the three hardware signals?",
        "Options": [
            "a) START, STOP, ACKNOWLEDGE",
            "b) STOP, TERMINATE, END",
            "c) START, SCL, SDA",
            "d) STOP, SCL, SDA"
        ],
        "Answer": "Answer: a\nExplanation:  The three hardware signals are START, STOP and ACKNOWLEDGE. These signals help in the transmission of data between the slave and the masters."
    },
    {
        "id": 395,
        "Question": "Which of the following performs the START signal?",
        "Options": [
            "a) master",
            "b) slave",
            "c) CPU",
            "d) memory"
        ],
        "Answer": "Answer: a\nExplanation: The START signal is performed by the master by making the SCL and SDA pin high."
    },
    {
        "id": 396,
        "Question": "Which of the following are handshake signals?",
        "Options": [
            "a) START",
            "b) STOP",
            "c) ACKNOWLEDGE",
            "d) START and STOP"
        ],
        "Answer": "Answer: c\nExplanation: The START signal and ACKNOWLEDGE signals are almost similar but there exhibits a small change. The START signal is initiated by the master only but the ACKNOWLEDGE signal is a handshake between both the master and slave."
    },
    {
        "id": 397,
        "Question": "A packet is also referred to as",
        "Options": [
            "a) postcard",
            "b) telegram",
            "c) letter",
            "d) data"
        ],
        "Answer": "Answer: b\nExplanation: The data is transmitted in packets with a having one or more bytes. These packets of data are also known as a telegram."
    },
    {
        "id": 398,
        "Question": "Which of the following byte performs the slave selection?",
        "Options": [
            "a) first byte",
            "b) second byte",
            "c) terminal byte",
            "d) eighth byte"
        ],
        "Answer": "Answer: a\nExplanation: The slave selection is performed by using the first byte as an address byte. When the address byte is sent out all the slave devices compares the address by its own value. If there is a match, the ACKNOWLEDGE signal will be sent by the slave."
    },
    {
        "id": 399,
        "Question": "Which of the following indicates the type of operation that the master requests?",
        "Options": [
            "a) address value",
            "b) initial value",
            "c) terminal count",
            "d) first byte"
        ],
        "Answer": "Answer: a\nExplanation: The address value helps the master to select the device and indicates what operation should be taken. If the 8th bit is logic one, read operation takes out and if it is logic zero, write operation takes out."
    },
    {
        "id": 400,
        "Question": "How can both single byte and the double byte address slave use the same bus?",
        "Options": [
            "a) extended memory",
            "b) extended address",
            "c) peripheral count",
            "d) slave bus"
        ],
        "Answer": "Answer: b\nExplanation: For providing more addressing, an extended address is developed which possesses two bytes in which the first byte uses a special code to distinguish it from a single byte address so that the single byte and double byte address slaves can use a shared bus."
    },
    {
        "id": 401,
        "Question": "Which counter selects the next register in the I2C?",
        "Options": [
            "a) auto-incrementing counter",
            "b) decrementing counter",
            "c) auto-decrementing counter",
            "d) terminal counter"
        ],
        "Answer": "Answer: a\nExplanation: The peripheral having a small number of locations can use auto-incrementing counter for accessing the next register. But this will not be applicable in bigger memory devices."
    },
    {
        "id": 402,
        "Question": "Which is an efficient method for the EEPROM?",
        "Options": [
            "a) combined format",
            "b) auto-incrementing counter",
            "c) register set",
            "d) single format"
        ],
        "Answer": "Answer: a\nExplanation: Combined format is an efficient method for the EEPROM because it is having a large number of registers."
    },
    {
        "id": 403,
        "Question": "Which of the following uses two data transfers?",
        "Options": [
            "a) auto-incrementing counter",
            "b) auto-decrementing counter",
            "c) combined format",
            "d) single format"
        ],
        "Answer": "Answer: c\nExplanation: The EEPROM is having a large number of registers, so auto incrementing counter will not be applicable. So there is an alternative method which uses index value that is written to the chip, prior to accessing the data. This is called combined format and this combined format uses two data transfer. One is to write the data and the other is to read."
    },
    {
        "id": 404,
        "Question": "Which of the following is efficient for the small number of registers?",
        "Options": [
            "a) auto-incrementing counter",
            "b) auto-decrementing counter",
            "c) combined format",
            "d) single format"
        ],
        "Answer": "Answer: a\nExplanation: The peripherals which have a small number of locations can use auto-increment counter within the peripheral in which each access selects the next register."
    },
    {
        "id": 405,
        "Question": "Which can determine the timeout value?",
        "Options": [
            "a) polling",
            "b) timer",
            "c) combined format",
            "d) watchdog timer"
        ],
        "Answer": "Answer: a\nExplanation: The polling can be used along with the counter to determine the timeout value."
    },
    {
        "id": 406,
        "Question": "How is bus lockup avoided?",
        "Options": [
            "a) timer and polling",
            "b) combined format",
            "c) terminal counter",
            "d) counter"
        ],
        "Answer": "Answer: a\nExplanation: The timeout value can be changed by the peripheral devices, so for a sophisticated system a combination of polling and timer is used to check for the signal n times within a predefined interval. This can avoid the bus lock."
    },
    {
        "id": 407,
        "Question": "Which of the following can determine if two masters start to use the bus at the same time?",
        "Options": [
            "a) counter detect",
            "b) collision detect",
            "c) combined format",
            "d) auto-incremental counter"
        ],
        "Answer": "Answer: b\nExplanation: The collision detects technique helps to determine whether two or more masters are using the same bus in a multi-master device."
    },
    {
        "id": 408,
        "Question": "Which ports are used in the multi-master system to avoid errors?",
        "Options": [
            "a) unidirectional port",
            "b) bidirectional port",
            "c) multi directional port",
            "d) tridirectional port"
        ],
        "Answer": "Answer: b\nExplanation: By using the bidirectional ports, each master can monitor the line and confirm its expected state and if it is not matched, a mismatch or collision had occurred which will discontinue the transmission by the master."
    },
    {
        "id": 409,
        "Question": "Which of the following can be used for long distance communication?",
        "Options": [
            "a) I2C",
            "b) Parallel port",
            "c) SPI",
            "d) RS232"
        ],
        "Answer": "Answer: d\nExplanation: A slightly different serial port called RS232 is used for long distance communication, otherwise the clock may get skewed. The low voltage signal also affects the long distance communication."
    },
    {
        "id": 410,
        "Question": "Which of the following can affect the long distance communication?",
        "Options": [
            "a) clock",
            "b) resistor",
            "c) inductor",
            "d) capacitor"
        ],
        "Answer": "Answer: a\nExplanation: For small distance communication, the clock signal which allows a synchronous transmission of data is more than enough, and the low voltage signal of TTL or CMOS is sufficient for the operation. But for long distance communication, the clock signal may get skewed and the low voltage can be affected by the cable capacitance. So for long distance communication RS232 can be used."
    },
    {
        "id": 411,
        "Question": "Which are the serial ports of the IBM PC?",
        "Options": [
            "a) COM1",
            "b) COM4 and COM1",
            "c) COM1 and COM2",
            "d) COM3"
        ],
        "Answer": "Answer: c\nExplanation: The IBM PC has one or two serial ports called the COM1 and the COM2, which are used for the data transmission between the PC and many other peripheral units like a printer, modem etc."
    },
    {
        "id": 412,
        "Question": "Which of the following can provide hardware handshaking?",
        "Options": [
            "a) RS232",
            "b) Parallel port",
            "c) Counter",
            "d) Timer"
        ],
        "Answer": "Answer: a\nExplanation: In RS232, several lines are used for transmitting and receiving data and these also provide control for the hardware handshaking."
    },
    {
        "id": 413,
        "Question": "Which of the following have an asynchronous data transmission?",
        "Options": [
            "a) SPI",
            "b) RS232",
            "c) Parallel port",
            "d) I2C"
        ],
        "Answer": "Answer: b\nExplanation: The data is transmitted asynchronously in RS232 which enhance long distance communication, whereas SPI, I2C offers short distance communication, and therefore, they are using synchronous data transmission."
    },
    {
        "id": 414,
        "Question": "How many areas does the serial interface have?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 2",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: The serial interface is divided into two, physical interface and the electrical interface."
    },
    {
        "id": 415,
        "Question": "The RS232 is also known as",
        "Options": [
            "a) UART",
            "b) SPI",
            "c) Physical interface",
            "d) Electrical interface"
        ],
        "Answer": "Answer: d\nExplanation: The RS232 is also known as the physical interface and it is also known as EIA232."
    },
    {
        "id": 416,
        "Question": "How much voltage does the MC1489 can take?",
        "Options": [
            "a) 12V",
            "b) 5V",
            "c) 3.3V",
            "d) 2.2V"
        ],
        "Answer": "Answer: b\nExplanation: The MC1489 is an interface chip which can take a  5V and generate internally the other voltages which are needed to meet the interface specification."
    },
    {
        "id": 417,
        "Question": "Which of the following is not a serial protocol?",
        "Options": [
            "a) SPI",
            "b) I2C",
            "c) Serial port",
            "d) RS232"
        ],
        "Answer": "Answer: d\nExplanation: The RS232 is a physical interface. It does not follow the serial protocol."
    },
    {
        "id": 418,
        "Question": "Which of the following is an ideal interface for LCD controllers?",
        "Options": [
            "a) SPI",
            "b) parallel port",
            "c) Serial port",
            "d) M-Bus"
        ],
        "Answer": "Answer: d\nExplanation: M-Bus or Motorola Bus is an ideal interface for LCD controllers, A/D converters, EEPROMs and many other components which can benefit faster transmission."
    },
    {
        "id": 419,
        "Question": "What does UART stand for?",
        "Options": [
            "a) universal asynchronous receiver transmitter",
            "b) unique asynchronous receiver transmitter",
            "c) universal address receiver transmitter",
            "d) unique address receiver transmitter"
        ],
        "Answer": "Answer: a\nExplanation: The UART or universal asynchronous receiver transmitter is used for the data transmission at a predefined speed or baud rate."
    },
    {
        "id": 420,
        "Question": "How is data detected in a UART?",
        "Options": [
            "a) counter",
            "b) timer",
            "c) clock",
            "d) first bit"
        ],
        "Answer": "Answer: c\nExplanation: The data can be detected by the local clock reference which is generated from the baud rate generator."
    },
    {
        "id": 421,
        "Question": "Which of the signal is set to one, if no data is transmitted?",
        "Options": [
            "a) READY",
            "b) START",
            "c) STOP",
            "d) TXD"
        ],
        "Answer": "Answer: d\nExplanation: The TXD signal goes to logic one when no data is transmitted. When data transmit, it sets to logic zero."
    },
    {
        "id": 422,
        "Question": "What rate can define the timing in the UART?",
        "Options": [
            "a) bit rate",
            "b) baud rate",
            "c) speed rate",
            "d) voltage rate"
        ],
        "Answer": "Answer: b\nExplanation: The timing is defined by the baud rate in which both the transmitter and receiver are used. The baud rate is supplied by the counter or an external timer called baud rate generator which generates a clock signal."
    },
    {
        "id": 423,
        "Question": "How is the baud rate supplied?",
        "Options": [
            "a) baud rate voltage",
            "b) external timer",
            "c) peripheral",
            "d) internal timer"
        ],
        "Answer": "Answer: b\nExplanation: The baud rate is supplied by the counter or an external timer called baud rate generator which generates a clock signal."
    },
    {
        "id": 424,
        "Question": "Which is the most commonly used UART?",
        "Options": [
            "a) 8253",
            "b) 8254",
            "c) 8259",
            "d) 8250"
        ],
        "Answer": "Answer: d\nExplanation: The Intel 8253, 8254 and 8259 are timers whereas Intel 8250 is a UART which is commonly used."
    },
    {
        "id": 425,
        "Question": "Which company developed 16450?",
        "Options": [
            "a) Philips",
            "b) Intel",
            "c) National semiconductor",
            "d) IBM"
        ],
        "Answer": "Answer: c\nExplanation: The Intel 8250 is replaced by the 16450 and 16550 which are developed by the National Semiconductors. 16450 is a chip which can combine all the PC’s input output devices into a single piece of silicon."
    },
    {
        "id": 426,
        "Question": "What does ADS indicate in 8250 UART?",
        "Options": [
            "a) address signal",
            "b) address terminal signal",
            "c) address strobe signal",
            "d) address generating signal"
        ],
        "Answer": "Answer: c\nExplanation: The ADS is address strobe signal and is working as active low in 8250 UART. The ADS signal is used to latch the address and chip select signals while processor access."
    },
    {
        "id": 427,
        "Question": "Which of the following signals are active low in the 8250 UART?",
        "Options": [
            "a) BAUDOUT",
            "b) DDIS",
            "c) INTR",
            "d) MR"
        ],
        "Answer": "Answer: a\nExplanation: The BAUDOUT signal is active low whereas DDIS, INTR and MR are active high in the 8250 UART. BAUDOUT is the clock signal from the transmitter part of the UART. DDIS signal goes low when the CPU is reading data from the UART. INTR is the interrupt pin. MR is the master reset pin."
    },
    {
        "id": 428,
        "Question": "Which of the signal can control bus arbitration logic in 8250?",
        "Options": [
            "a) MR",
            "b) DDIS",
            "c) INTR",
            "d) RCLK"
        ],
        "Answer": "Answer: b\nExplanation: DDIS signal goes low when the CPU is reading data from the UART and it also controls the bus arbitration logic."
    },
    {
        "id": 429,
        "Question": "Which of the following is used to reset the device in 8250?",
        "Options": [
            "a) MR",
            "b) DDIS",
            "c) INTR",
            "d) RCLK"
        ],
        "Answer": "Answer: a\nExplanation: MR is the master reset pin which helps to reset the device and restore the internal registers."
    },
    {
        "id": 430,
        "Question": "Which provides an input clock for the receiver part of the UART 8250?",
        "Options": [
            "a) RD",
            "b) RCLK",
            "c) MR",
            "d) DDIS"
        ],
        "Answer": "Answer: b\nExplanation: RCLK provides an input clock for the receiver part of the UART. RD is the read signal. MR is the master reset pin and DDIS is used to control bus arbitration logic."
    },
    {
        "id": 431,
        "Question": "Which of the following is a general purpose I/O pin?",
        "Options": [
            "a) OUT1",
            "b) RD",
            "c) ADS",
            "d) MR"
        ],
        "Answer": "Answer: a\nExplanation: There are two general purposes I/O pin OUT1 and OUT2. OUT1 is set by the programming bit 2 of the MCR to a ‘1’ whereas OUT2 is set by the programming bit 3 of the MCR to ‘1’. These are active low pins in 8250."
    },
    {
        "id": 432,
        "Question": "Which of the following indicate the type of access that the CPU needs to perform?",
        "Options": [
            "a) MR",
            "b) RD",
            "c) ADS",
            "d) RCLK"
        ],
        "Answer": "Answer: b\nExplanation: RD and WR signals are indicating the type of access that the CPU needs to perform, that is, whether it is a read cycle or write cycle."
    },
    {
        "id": 433,
        "Question": "Which pins are used for additional DMA control?",
        "Options": [
            "a) RXRDY",
            "b) RD",
            "c) MR",
            "d) INR"
        ],
        "Answer": "Answer: a\nExplanation: The  RXRDY and TXRDY are two active low pins which are used for additional DMA control. It can be used for DMA transfers to and from the read and write buffers."
    },
    {
        "id": 434,
        "Question": "Which of the following are not used within the IBM PC?",
        "Options": [
            "a) TXRDY",
            "b) BAUDOUT",
            "c) ADS",
            "d) OUT2"
        ],
        "Answer": "Answer: a\nExplanation: The CPU is responsible for moving data to and from the UART in the IBM PC, therefore it does not have TXRDY and RXRDY pins which are used for DMA accessing."
    },
    {
        "id": 435,
        "Question": "Which pins are used to connect an external crystal?",
        "Options": [
            "a) INR",
            "b) ADS",
            "c) XIN",
            "d) SIN"
        ],
        "Answer": "Answer: c\nExplanation: The XIN and XOUT pins are used to connect an external crystal. These pins can also connect an external clock."
    },
    {
        "id": 436,
        "Question": "Which UART is used in MC680 by 0 design?",
        "Options": [
            "a) Intel 8250",
            "b) 16450",
            "c) 16550",
            "d) MC68681"
        ],
        "Answer": "Answer: d\nExplanation: The MC68681 is a standard UART developed by Motorola. It has been used in many MC680 by 0 designs."
    },
    {
        "id": 437,
        "Question": "Which of the following have large FIFO buffer?",
        "Options": [
            "a) 8253",
            "b) 8250",
            "c) 16550",
            "d) 16450"
        ],
        "Answer": "Answer: c\nExplanation: The largest buffer of 16 bytes is available on 16550 UART which is used for high speed data communications."
    },
    {
        "id": 438,
        "Question": "Which of the following has a quadruple buffered receiver and a double buffered transmitter?",
        "Options": [
            "a) Intel 8250",
            "b) 16450",
            "c) 16550",
            "d) MC68681"
        ],
        "Answer": "Answer: d\nExplanation: The MC68681 is a standard UART developed by Motorola. It possess a quadruple buffered receiver and a double buffered transmitter."
    },
    {
        "id": 439,
        "Question": "Which can prevent the terminal of data transmission?",
        "Options": [
            "a) flow control",
            "b) increasing flow",
            "c) increasing count",
            "d) terminal count"
        ],
        "Answer": "Answer: a\nExplanation:  The flow control can prevent data transmission. It can also prevent the computer from sending more data than the other can cope with."
    },
    {
        "id": 440,
        "Question": "Which of the following is the first flow control method?",
        "Options": [
            "a) software handshaking",
            "b) hardware handshaking",
            "c) UART",
            "d) SPI"
        ],
        "Answer": "Answer: b\nExplanation: The first flow control method is the hardware handshaking in which the hardware in the UART detects the potential overrun and it will assert a handshake line to tell the other UART to stop the transmission."
    },
    {
        "id": 441,
        "Question": "Which one of the following is the second method for flow controlling?",
        "Options": [
            "a) hardware",
            "b) peripheral",
            "c) software",
            "d) memory"
        ],
        "Answer": "Answer: c\nExplanation: In the first method of flow control, there is a chance of data loss. So the second method of the flow control is adopted in which it uses software to send characters XON and XOFF. XOFF can stop the data transfer and XON can restart the data transfer."
    },
    {
        "id": 442,
        "Question": "Which can restart the data transmission?",
        "Options": [
            "a) XON",
            "b) XOFF",
            "c) XRST",
            "d) restart button"
        ],
        "Answer": "Answer: a\nExplanation: The second method of flow control is called software which is based on certain characters called XON and XOFF. XOFF can stop the data transfer and XON can restart the data transfer."
    },
    {
        "id": 443,
        "Question": "Which of the following is a common connector?",
        "Options": [
            "a) UART",
            "b) SPI",
            "c) I2C",
            "d) DB-25"
        ],
        "Answer": "Answer: d\nExplanation: There are two connectors which are used very commonly. They are DB-25 and DB-9 which has 25 pins and 9 pins respectively."
    },
    {
        "id": 444,
        "Question": "What does pin 22 in DB-25 indicate?",
        "Options": [
            "a) transmit data",
            "b) receive data",
            "c) ring indicator",
            "d) signal ground"
        ],
        "Answer": "Answer: c\nExplanation: The 22nd pin in DB-25 and the 9th pin in the DB-9 indicates a ring indicator which is asserted when a connected modem has detected an incoming call."
    },
    {
        "id": 445,
        "Question": "Which pin indicates the DSR in DB-25?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 4",
            "d) 6"
        ],
        "Answer": "Answer: d\nExplanation: The 6th pin in DB-25 indicates DSR, that is, data set ready which indicates that each side is powered on and is ready to access data."
    },
    {
        "id": 446,
        "Question": " Which of the following connections are one to one?",
        "Options": [
            "a) Modem cables",
            "b) SPI",
            "c) UART",
            "d) I2C"
        ],
        "Answer": "Answer: a\nExplanation: The modem cables are straight cables which allow one to one connections without crossover."
    },
    {
        "id": 447,
        "Question": "Which of the following are used to link PCs?",
        "Options": [
            "a) modem cable",
            "b) null modem cable",
            "c) serial port",
            "d) parallel port"
        ],
        "Answer": "Answer: b\nExplanation: The modem cables are used to link PC with other peripherals like printers, plotters, modems etc. But it cannot link with other PCs. So an alternative method is adopted to link PCs which is called null modem cable."
    },
    {
        "id": 448,
        "Question": "Which of the following method is used by Apple Macintosh?",
        "Options": [
            "a) hardware handshaking",
            "b) software handshaking",
            "c) no handshaking",
            "d) null modem cable"
        ],
        "Answer": "Answer: b\nExplanation: The Apple Macintosh and UNIX use software handshaking for the data transmission where the characters are sent to control the flow of characters between two systems."
    },
    {
        "id": 449,
        "Question": "Which of the following provides an efficient method for transferring data from a peripheral to memory?",
        "Options": [
            "a) dma controller",
            "b) serial port",
            "c) parallel port",
            "d) dual port"
        ],
        "Answer": "Answer: a\nExplanation: The DMA controllers or direct memory access controller provides an efficient method for transferring data from the peripheral to the memory."
    },
    {
        "id": 450,
        "Question": "Which of the following can be adopted for the systems which does not contain DMA controller for data transmission?",
        "Options": [
            "a) counter",
            "b) timer",
            "c) polling",
            "d) memory"
        ],
        "Answer": "Answer: c\nExplanation: The polling and interrupt helps for data transmission for the systems which do not have DMA controller."
    },
    {
        "id": 451,
        "Question": "Which of the following have low-level buffer filling?",
        "Options": [
            "a) output",
            "b) peripheral",
            "c) dma controller",
            "d) input"
        ],
        "Answer": "Answer: c\nExplanation: The DMA controller can initiate and control the bus access between I/O devices and memory, and also between two different memory areas. Therefore, the DMA controller can act as a hardware implementation of low-level buffer filling or emptying the interrupt."
    },
    {
        "id": 452,
        "Question": "How many classifications of DMA controllers are made based on the addressing capability?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: b\nExplanation: There are three classifications for the DMA controllers based on the address capability. These are 1D, 2D and 3D."
    },
    {
        "id": 453,
        "Question": "How many address register are there for the 1D type DMA controller?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: The 1D controller only have a single address register whereas 2D controller have two address register and 3D controller have three or more address register."
    },
    {
        "id": 454,
        "Question": "Which of the following of a generic DMA controller contain a base address register and an auto-incrementing counter?",
        "Options": [
            "a) address bus",
            "b) data bus",
            "c) bus requester",
            "d) address generator"
        ],
        "Answer": "Answer: d\nExplanation: The generic controller have several components associated with it for controlling the operation and one such is the address generator. It consists of the base address register and an auto-incrementing counter which increment the address after every transfer."
    },
    {
        "id": 455,
        "Question": "Which of the following is used to transfer the data from the DMA controller to the destination?",
        "Options": [
            "a) data bus",
            "b) address bus",
            "c) request bus",
            "d) interrupt signal"
        ],
        "Answer": "Answer: a\nExplanation: The data bus is used for the transmission of data from the DMA controller to the destinal. The DMA controller can directly select the peripheral in some cases in which the data transfer is made from the peripheral to the memory."
    },
    {
        "id": 456,
        "Question": "Which of the following is used to request the bus from the main CPU?",
        "Options": [
            "a) data bus",
            "b) address bus",
            "c) bus requester",
            "d) interrupt signal"
        ],
        "Answer": "Answer: c\nExplanation: The bus requester requests the bus from the main CPU. In earlier design, the processor bus does not support the multi master system and there were no bus request signals. In such cases, the processor clock was extended."
    },
    {
        "id": 457,
        "Question": "Which signal can identify the error?",
        "Options": [
            "a) data bus",
            "b) address bus",
            "c) bus requester",
            "d) interrupt signal"
        ],
        "Answer": "Answer: d\nExplanation: The interrupt signal can identify the error occurred in the DMA controller. This makes the processor to reprogram the DMA controller for a different transfer."
    },
    {
        "id": 458,
        "Question": "Which signal allows the DMA controller to select the peripheral?",
        "Options": [
            "a) local peripheral control",
            "b) global peripheral control",
            "c) address bus",
            "d) data bus"
        ],
        "Answer": "Answer: a\nExplanation: The local peripheral control allows the DMA controller to select the peripheral."
    },
    {
        "id": 459,
        "Question": "Which of the following is also known as implicit address?",
        "Options": [
            "a) dual address model",
            "b) single address model",
            "c) 1D model",
            "d) 2D model"
        ],
        "Answer": "Answer: b\nExplanation: The single address model is also known as implicit model because the second address is implied and is not directly given, that is, the source address is not supplied."
    },
    {
        "id": 460,
        "Question": "Which address mode uses two addresses and two accesses to transfer the data between the peripheral and the memory?",
        "Options": [
            "a) dual address model",
            "b) 1D model",
            "c) 2D model",
            "d) 3D model"
        ],
        "Answer": "Answer: a\nExplanation: The dual address mode supports two addresses and two accesses for transferring data between a peripheral or memory and another memory location."
    },
    {
        "id": 461,
        "Question": "Which of the following address mode uses a buffer to hold data temporarily?",
        "Options": [
            "a) 1D model",
            "b) 2D model",
            "c) dual address model",
            "d) 3D model"
        ],
        "Answer": "Answer: c\nExplanation: The dual address mode supports two addresses and two accesses for transferring data between a peripheral or memory and another memory location, which also consumes two bus cycles and a buffer within the DMA controller to hold data temporarily."
    },
    {
        "id": 462,
        "Question": "Which of the following model can implement a circular buffer?",
        "Options": [
            "a) dual address mode",
            "b) 1D model",
            "c) 2D model",
            "d) 3D model"
        ],
        "Answer": "Answer: b\nExplanation: The 1D model can implement a circular buffer which makes an automatic reset to bring the address back to the beginning."
    },
    {
        "id": 463,
        "Question": "Which of the following uses an address and a counter to define the sequence of addresses?",
        "Options": [
            "a) dual address mode",
            "b) 2D model",
            "c) 1D model",
            "d) 3D model"
        ],
        "Answer": "Answer: c\nExplanation: The 1D model of the DMA controller uses an address location and a counter to define the address sequence which is used during the DMA cycles."
    },
    {
        "id": 464,
        "Question": "Which of the following is used to calculate an offset to base address?",
        "Options": [
            "a) single address mode",
            "b) dual address mode",
            "c) 1D model",
            "d) 2D model"
        ],
        "Answer": "Answer: d\nExplanation: An address stride is specified which can be used for calculating the offset to the base address at the terminal of count. This address stride is used in the 2D model of the DMA controller."
    },
    {
        "id": 465,
        "Question": "Which can provide an address stride?",
        "Options": [
            "a) single address mode",
            "b) dual address mode",
            "c) 1D model",
            "d) 2D model"
        ],
        "Answer": "Answer: d\nExplanation: In the 2D model of the DMA controller, an address stride is specified which can be used for calculating the offset to the base address at the terminal of count."
    },
    {
        "id": 466,
        "Question": "How is the count register can be splitted?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: In the 2D model of the DMA controller, in addition to the address stride there is a count register which can be split into two, in which one register is used to specify the count for the block and the second register is used to define the total number of blocks or the bytes to be transferred."
    },
    {
        "id": 467,
        "Question": "Which of the following has the ability to change the stride automatically?",
        "Options": [
            "a) 1D model",
            "b) 2D model",
            "c) 3D model",
            "d) dual address mode"
        ],
        "Answer": "Answer: c\nExplanation: In the 3D model of the DMA controller, it have the ability to change the address stride automatically so that blocks of different sizes and stride can be created."
    },
    {
        "id": 468,
        "Question": "Which is used to prioritise multiple requests?",
        "Options": [
            "a) dual address mode",
            "b) single address mode",
            "c) arbitration",
            "d) chaining"
        ],
        "Answer": "Answer: c\nExplanation: The arbitration is used to provide priority for multiple access. This uses a priority scheme which may offer fair priority to the one channel, or a high priority to the other channel and so on. Such condition is otherwise known as round-robin condition in which the priority is equally divided."
    },
    {
        "id": 469,
        "Question": "Which of the following DMA is used in the IBM PC?",
        "Options": [
            "a) Intel 8253",
            "b) Intel 8254",
            "c) Intel 8237",
            "d) Intel 8259"
        ],
        "Answer": "Answer: c\nExplanation: The Intel 8237 is the DMA used in the IBM PC. 8253, 8254 and 8259 are timers developed by Intel."
    },
    {
        "id": 470,
        "Question": "Which of the following have four transfer modes?",
        "Options": [
            "a) Intel 8253",
            "b) Intel 8254",
            "c) Intel 8259",
            "d) Intel 8237"
        ],
        "Answer": "Answer: d\nExplanation: The Intel 8237 have four transfer modes. These are single mode, block transfer mode, demand mode and cascade mode."
    },
    {
        "id": 471,
        "Question": "Identify the additional transfer mode in the Intel 8237?",
        "Options": [
            "a) single transfer mode",
            "b) demand transfer mode",
            "c) verify transfer mode",
            "d) block transfer mode"
        ],
        "Answer": "Answer: c\nExplanation: In addition to the four main transfer mode, there is a verify transfer mode which is used within the PC to create dummy addresses which are used for refreshing the DRAM."
    },
    {
        "id": 472,
        "Question": "Which of the following transfer mode can refresh the DRAM memory?",
        "Options": [
            "a) verify transfer mode",
            "b) bloch transfer mode",
            "c) demand transfer mode",
            "d) cascade mode"
        ],
        "Answer": "Answer: a\nExplanation: The verify address transfer mode can generate dummy addresses which are used for the DRAM refreshing."
    },
    {
        "id": 473,
        "Question": "Which of the following is used for supporting the priority scheme?",
        "Options": [
            "a) address transfer mode",
            "b) arbitration",
            "c) counter",
            "d) timer"
        ],
        "Answer": "Answer: b\nExplanation: The arbitration is used for providing priority to the DMA requests. The DMA request is simultaneously generating, so in order to avoid the errors, a priority scheme is necessary which is done by the arbitration scheme in the DMA controller."
    },
    {
        "id": 474,
        "Question": "Which of the following consist of a fully programmable DMA controller of two channels?",
        "Options": [
            "a) MC68300",
            "b) Intel 8237",
            "c) Intel 8253",
            "d) Intel 8254"
        ],
        "Answer": "Answer: a\nExplanation: The MC68300 is developed by Motorola, which consists of a two channel fully programmable DMA controller which can support high speed data transfer."
    },
    {
        "id": 475,
        "Question": "Which cycle can support the burst and single transfer mode?",
        "Options": [
            "a) internal",
            "b) external",
            "c) both internal and external",
            "d) address cycle"
        ],
        "Answer": "Answer: b\nExplanation: The internal cycles can be programmed to occupy the partial or complete fulfillment of the available internal bus bandwidth while the external cycles provides support to the single transfer modes and burst mode."
    },
    {
        "id": 476,
        "Question": "Which of the following requires its own local memory and program?",
        "Options": [
            "a) DMA controller",
            "b) DMA address",
            "c) DMA CPU",
            "d) DMA peripheral"
        ],
        "Answer": "Answer: c\nExplanation: The DMA CPU has its own address local memory and program so that it will not harm main memory bus and it is completely isolated."
    },
    {
        "id": 477,
        "Question": "Which DMA is programmed with higher level software?",
        "Options": [
            "a) DMA controller",
            "b) DMA address",
            "c) DMA peripheral",
            "d) DMA CPU"
        ],
        "Answer": "Answer: d\nExplanation: The DMA CPU is programmed with higher level software which is used to transfer the data and for processing it."
    },
    {
        "id": 478,
        "Question": "Which of the following combine an MC68000/MC68020 type of processor with peripheral and DMA controllers?",
        "Options": [
            "a) Intel 8237",
            "b) Intel 8253",
            "c) MC68300",
            "d) MC68000"
        ],
        "Answer": "Answer: c\nExplanation: The MC68300 combines the processors along with the DMA controllers. The processors which support the MC68300 series are MC68000 or MC68020."
    },
    {
        "id": 479,
        "Question": "Which signal is sampled at regular intervals for the purpose of ADC?",
        "Options": [
            "a) analog signal",
            "b) digital signal",
            "c) quantised signal",
            "d) sampled signal"
        ],
        "Answer": "Answer: a\nExplanation: The analog signal is sampled at regular intervals for the analog to digital conversion. Each sample is then quantised to divided by a given value in order to identify the number of approximate analogue value."
    },
    {
        "id": 480,
        "Question": "Which factor depends on the quantisation error?",
        "Options": [
            "a) number of error",
            "b) number of bits",
            "c) size of error",
            "d) conversion process"
        ],
        "Answer": "Answer: b\nExplanation: The quantisation error depends on the number of bits which is used to represent the analogue vale."
    },
    {
        "id": 481,
        "Question": "Which is the first type of error caused during the conversion process?",
        "Options": [
            "a) sampling error",
            "b) interrupt signal",
            "c) counter error",
            "d) quantisation error"
        ],
        "Answer": "Answer: d\nExplanation: The quantisation error is the first type of error caused in the conversion process. This error is caused because the samples are converted to a slightly higher value instead of zero."
    },
    {
        "id": 482,
        "Question": "Which of the following defines the number of samples that are taken in the time period?",
        "Options": [
            "a) sample size",
            "b) sample nature",
            "c) sample rate",
            "d) sample frequency"
        ],
        "Answer": "Answer: c\nExplanation: The sample rate is defined by the number of samples that are taken in a time period. The sample rate is usually measured in Hertz. It can determine the speed of the conversion device itself."
    },
    {
        "id": 483,
        "Question": "Which of the following can determine the speed of conversion device itself?",
        "Options": [
            "a) sample rate",
            "b) sampled data",
            "c) sample size",
            "d) sample nature"
        ],
        "Answer": "Answer: a\nExplanation: The sample rate determines the various aspect of the conversion process and one such is the conversion speed."
    },
    {
        "id": 484,
        "Question": "Which of the following can determine the maximum frequency that can be converted?",
        "Options": [
            "a) sample frequency",
            "b) sample rate",
            "c) sample size",
            "d) sample nature"
        ],
        "Answer": "Answer: b\nExplanation: The sample rate can determine the maximum frequency that can be converted as per the Nyquist theorem. The theorem states that the minimum sampling rate frequency should be twice the maximum frequency of the analog signal."
    },
    {
        "id": 485,
        "Question": "Which term determines the random timing error?",
        "Options": [
            "a) jitter",
            "b) quantisation error",
            "c) sample error",
            "d) delay"
        ],
        "Answer": "Answer: a\nExplanation: Jitter is a random timing error. Jitter can cause irregular sampling errors."
    },
    {
        "id": 486,
        "Question": "Which of the following introduce a phase error?",
        "Options": [
            "a) conversion time",
            "b) sampling rate",
            "c) sample size",
            "d) sample nature"
        ],
        "Answer": "Answer: a\nExplanation: The conversion time always introduces a phase error. The conversion time will delay the digital output and hence introduce a phase error."
    },
    {
        "id": 487,
        "Question": "Which of the following can generate an interrupt?",
        "Options": [
            "a) timer",
            "b) trigger",
            "c) delay",
            "d) counter"
        ],
        "Answer": "Answer: a\nExplanation: The timer can generate an interrupt to the processor at the rate of sampling frequency."
    },
    {
        "id": 488,
        "Question": "Which filter is used for filtering out the high frequency components?",
        "Options": [
            "a) bandpass filter",
            "b) band reject filter",
            "c) analogue filter",
            "d) digital filter"
        ],
        "Answer": "Answer: c\nExplanation: The higher frequency components can be filtered out by using an analog filter after sampling."
    },
    {
        "id": 489,
        "Question": "Which theorem describes the sampling rate with the frequency of the analogue signal?",
        "Options": [
            "a) Nyquist theorem",
            "b) Bayes theorem",
            "c) Sampling theorem",
            "d) Parseval’s theorem"
        ],
        "Answer": "Answer: a\nExplanation: The Nyquist theorem states that the minimum sampling rate frequency should be twice the maximum frequency of the analog signal."
    },
    {
        "id": 490,
        "Question": "From which of the following words does codecs is derived?",
        "Options": [
            "a) coder",
            "b) decoder",
            "c) coder-decoder",
            "d) coder-encoder"
        ],
        "Answer": "Answer: c\nExplanation: The codec is derived coder-decoder and is coupled to perform the coding. It can support both analogue to digital conversion and digital to analogue conversion."
    },
    {
        "id": 491,
        "Question": "Which codec is used in digital audio?",
        "Options": [
            "a) A-law",
            "b) µ-law",
            "c) linear",
            "d) PCM"
        ],
        "Answer": "Answer: c\nExplanation: In the linear codec, the relationship between the analogue and digital values are linear. This method is commonly used in digital audio communication."
    },
    {
        "id": 492,
        "Question": "Which of the following have the same quantisation step throughout the range?",
        "Options": [
            "a) linear",
            "b) PCM",
            "c) DPCM",
            "d) ADPCM"
        ],
        "Answer": "Answer: a\nExplanation: The quantisation step is same throughout the dynamic range in the linear codec and thus any increase in the analogue value increases the digital value, that is, the overall performance is linear."
    },
    {
        "id": 493,
        "Question": "Which is used in the telecommunication applications which has a limited bandwidth of 300 to 3100 HZ?",
        "Options": [
            "a) linear codec",
            "b) logarithmic codec",
            "c) PCM",
            "d) DPCM"
        ],
        "Answer": "Answer: b\nExplanation:  The logarithmic codec is frequently used in the telecommunication system which have a limited bandwidth of 300 to 3100 Hz. this can provide an 8-bit sample at 8 KHz, which are used in the telephones. The commonly used are A-law and µ-law."
    },
    {
        "id": 494,
        "Question": "Which codec is used in the UK?",
        "Options": [
            "a) a-law",
            "b) µ-law",
            "c) linear codec",
            "d) PCM"
        ],
        "Answer": "Answer: a\nExplanation: The a-law is a logarithmic codec which is commonly used in the UK whereas µ-law is used in the US."
    },
    {
        "id": 495,
        "Question": "What does PCM stand for?",
        "Options": [
            "a) pulse codec machine",
            "b) pulse code modulation",
            "c) peripheral code machine",
            "d) peculiar code modulation"
        ],
        "Answer": "Answer: b\nExplanation: The linear codec is also known as pulse code modulation which is commonly used in the telecommunications industry."
    },
    {
        "id": 496,
        "Question": "Which of the following conversion is performed by using a lookup table?",
        "Options": [
            "a) DPCM",
            "b) ADPCM",
            "c) Between DPCM and ADPCM",
            "d) Linear cdec and a-law"
        ],
        "Answer": "Answer: d\nExplanation: The conversion between a-law/µ-law and a linear digital signal or between µ-law and a-law is performed by a lookup table."
    },
    {
        "id": 497,
        "Question": "What does DPCM stand for?",
        "Options": [
            "a) differential pulse code modulation",
            "b) data pulse code modulation",
            "c) dynamic pulse code machine",
            "d) dynamic pulse code modulation"
        ],
        "Answer": "Answer: a\nExplanation: The differential pulse code modulation is similar to pulse code modulation, but DPCM uses an encoded value which is the difference between the current and the previous sample."
    },
    {
        "id": 498,
        "Question": "Which of the following have a 16-bit digital dynamic range?",
        "Options": [
            "a) PCM",
            "b) DPCM",
            "c) linear codec",
            "d) logarithmic codec"
        ],
        "Answer": "Answer: b\nExplanation: The differential pulse code modulation can improve the accuracy and resolution by having a 16-bit dynamic range. It works by the increasing dynamic range."
    },
    {
        "id": 499,
        "Question": "How many types of logarithmic codecs are used commonly?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: There are two types of logarithmic codec which are commonly used. They are a-law which is used in UK and µ-law codec which is used in the US."
    },
    {
        "id": 500,
        "Question": "What does ADPCM stand for?",
        "Options": [
            "a) address differential pulse code modulation",
            "b) adaptive differential pulse code modulation",
            "c) address dynamic pulse code machine",
            "d) adaptive dynamic pulse code modulation"
        ],
        "Answer": "Answer: b\nExplanation: The adaptive differential pulse code modulation is used in telecommunications and is based on non-linear quantisation values. "
    },
    {
        "id": 501,
        "Question": "Which of the following uses a non-linear quantisation value?",
        "Options": [
            "a) PCM",
            "b) DPCM",
            "c) ADPCM",
            "d) linear codec"
        ],
        "Answer": "Answer: c\nExplanation:  The adaptive differential pulse code modulation is based on non-linear quantisation values.  In the ADPCM, instead of using all bit for encoding, only a few bits are used for encoding which makes it non linear."
    },
    {
        "id": 502,
        "Question": "Which of the following works by increasing the dynamic range?",
        "Options": [
            "a) logarithmic codec",
            "b) linear codec",
            "c) DPCM",
            "d) PCM"
        ],
        "Answer": "Answer: c\nExplanation: The differential pulse code modulation can improve the accuracy and resolution by having a 16-bit dynamic range. It works by the increasing dynamic range."
    },
    {
        "id": 503,
        "Question": "Which device can make the PWM operation easier?",
        "Options": [
            "a) timer",
            "b) software",
            "c) hardware",
            "d) transistor"
        ],
        "Answer": "Answer: a\nExplanation: The timer can be used for making up the PWM waveform far more easier and faster and it will free the processor to do other things without affecting the timing."
    },
    {
        "id": 504,
        "Question": " Which of the following can be used for providing high gain?",
        "Options": [
            "a) transistor",
            "b) darlington transistor pair",
            "c) resistor",
            "d) capacitor"
        ],
        "Answer": "Answer:  b\nExplanation: The darlington pair of transistors can provide high gain than a single transistor. This is one of the method used to avoid voltage mismatches that the system produces. By using high gain transistors the voltage mismatches can be reduced upto a limit."
    },
    {
        "id": 505,
        "Question": "Which devices have high drive capability?",
        "Options": [
            "a) transistor",
            "b) fet",
            "c) buffer pack",
            "d) darlington amplifier"
        ],
        "Answer": "Answer:  c\nExplanation: The buffer pack is used to avoid the voltage mismatches which possesses a high drive capacity and it can also provide high drive currents than the normal logic outputs."
    },
    {
        "id": 506,
        "Question": "Which of the following is used to switch heavy loads?",
        "Options": [
            "a) fet",
            "b) transistor",
            "c) buffer pack",
            "d) darlington pair"
        ],
        "Answer": "Answer:  a\nExplanation: The field effect transistor can be used to provide a very high effective gain and hence they can be used to switch heavy loads easily from a logic device. These are also voltage controlled transistors."
    },
    {
        "id": 507,
        "Question": "Which allows the switching of DC motor by using two outputs and four FETs?",
        "Options": [
            "a) transistor",
            "b) H bridge",
            "c) darlington pair",
            "d) buffer pack"
        ],
        "Answer": "Answer:  b\nExplanation: The H bridge can be created by using several switches which allows a DC motor to be switched on and reversed in the direction. The switching can be done by using two outputs and four FETs."
    },
    {
        "id": 508,
        "Question": "Which of the following is used to create H bridge?",
        "Options": [
            "a) switches",
            "b) led",
            "c) capacitor",
            "d) inductor"
        ],
        "Answer": "Answer:  a\nExplanation: The H bridge can be created by using several switches. This allows a DC motor to be switched on and reversed in the direction and the switching of DC motor can be done by using two outputs and four FETs."
    },
    {
        "id": 509,
        "Question": "Which of the following allows voltage reversing?",
        "Options": [
            "a) H bridge",
            "b) Relays",
            "c) LEDs",
            "d) LCDs"
        ],
        "Answer": "Answer: a\nExplanation: The H bridge is used in controlling DC motors or any other loads which need voltage reversing."
    },
    {
        "id": 510,
        "Question": "Which devices are used as indicators in a digital system?",
        "Options": [
            "a) LCD",
            "b) LED",
            "c) Varactor diode",
            "d) Gunn diode"
        ],
        "Answer": "Answer:  b\nExplanation: The light emitting diodes are used as indicators in the digital system and can be directly driven from a logic output."
    },
    {
        "id": 511,
        "Question": "How is the biasing done in LEDs?",
        "Options": [
            "a) forward bias",
            "b) no bias",
            "c) supply voltage",
            "d) reverse bias"
        ],
        "Answer": "Answer:  d\nExplanation: The LEDs will light up only when the diode reverse breakdown is achieved. It is usually about 2 to 2.2V."
    },
    {
        "id": 512,
        "Question": "Which of the following determines the brightness of LEDs?",
        "Options": [
            "a) current",
            "b) voltage",
            "c) resistance",
            "d) conductance"
        ],
        "Answer": "Answer: a\nExplanation:  The current drive determines the brightness of the LEDs and it is usually associated with a current limiting resistor in series with the LED to prevent the overheating."
    },
    {
        "id": 513,
        "Question": "Which of the following is a current limiting device?",
        "Options": [
            "a) voltage",
            "b) current",
            "c) buffer",
            "d) inductor"
        ],
        "Answer": "Answer: c\nExplanation: A buffer can be used as a current limiting device. Similarly, a transistor can also be used as a current limiting device."
    },
    {
        "id": 514,
        "Question": "Which of the following can switch the current by a make or break contact?",
        "Options": [
            "a) transistor",
            "b) relay",
            "c) buffer",
            "d) fet"
        ],
        "Answer": "Answer: b\nExplanation: The relays are a kind of switching power in which the logic signal is used to energise the relay. The relay contacts are break or make accordingly and helps in switching the current."
    },
    {
        "id": 515,
        "Question": "Which of the following generates a back EMF?",
        "Options": [
            "a) relay",
            "b) buffer",
            "c) transistor",
            "d) FET"
        ],
        "Answer": "Answer: a\nExplanation: The relay generates a back voltage across its terminals when the logic output switches from a high to low state."
    },
    {
        "id": 516,
        "Question": "Which of the following is used to avoid the back EMF in the relay?",
        "Options": [
            "a) resistor",
            "b) capacitor",
            "c) inductor",
            "d) diode"
        ],
        "Answer": "Answer:d\nExplanation: In order to get rid of the back EMF which is generated by the relay a diode is connected across the terminals which operate in the reverse bias so that nothing can harm the relay."
    },
    {
        "id": 517,
        "Question": "Which of the following can provide a speed control technique in the DC motor interfacing?",
        "Options": [
            "a) PCM",
            "b) DPCM",
            "c) ADPCM",
            "d) PWM"
        ],
        "Answer": "Answer: d\nExplanation: The pulse width modulation can provide a speed control technique in the DC motor interfacing by changing its mark/space ratio."
    },
    {
        "id": 518,
        "Question": "Which of the following possesses some loops for providing timing functions?",
        "Options": [
            "a) hardware",
            "b) software",
            "c) timer",
            "d) counter"
        ],
        "Answer": "Answer: b\nExplanation: In the software system, certain loops perform the timing functions. A program is created to switch the motor on and it will start counting through a delay loop. When the count is finished, the motor is switched off. In the second delay loop, it can determine the motor-off period."
    },
    {
        "id": 519,
        "Question": "The time taken to respond to an interrupt is known as",
        "Options": [
            "a) interrupt delay",
            "b) interrupt time",
            "c) interrupt latency",
            "d) interrupt function"
        ],
        "Answer": "Answer: c\nExplanation: The interrupts are the most important function of the embedded system and are responsible for many problems while debugging the system. The time taken to respond to an interrupt is called the interrupt latency."
    },
    {
        "id": 520,
        "Question": "Into how many parts does the interrupt can split the software?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: The software interrupt can split into two parts. These are foreground work and background work."
    },
    {
        "id": 521,
        "Question": "Which of the following allows the splitting of the software?",
        "Options": [
            "a) wait statement",
            "b) ready",
            "c) interrupt",
            "d) acknowledgement"
        ],
        "Answer": "Answer: c\nExplanation:  The interrupt can make the software into two main parts and these are foreground work and background work. "
    },
    {
        "id": 522,
        "Question": "Which part of the software is transparent to the interrupt mechanism?",
        "Options": [
            "a) background",
            "b) foreground",
            "c) both background and foreground",
            "d) lateral ground"
        ],
        "Answer": "Answer: a\nExplanation: The interrupt mechanism is transparent to the background software, that is, the background software is not aware of the existence of the foreground software."
    },
    {
        "id": 523,
        "Question": "Which part of the software performs tasks in response to the interrupts?",
        "Options": [
            "a) background",
            "b) foreground",
            "c) lateral ground",
            "d) both foreground and background"
        ],
        "Answer": "Answer: b\nExplanation:  In the foreground work, the tasks are performed in response to the interrupts but in the background work, the tasks are performed while waiting for an interrupt."
    },
    {
        "id": 524,
        "Question": "In which of the following method does the code is written in a straight sequence?",
        "Options": [
            "a) method 1",
            "b) timing method",
            "c) sequence method",
            "d) spaghetti method"
        ],
        "Answer": "Answer: d\nExplanation: In the spaghetti method, the code is written in a straight sequence in which the analysis software goes and polls the port to see if there is data."
    },
    {
        "id": 525,
        "Question": "Which factor depends on the number of times of polling the port while executing the task?",
        "Options": [
            "a) data",
            "b) data transfer rate",
            "c) data size",
            "d) number of bits"
        ],
        "Answer": "Answer: b\nExplanation: The data transfer rate can determine the number of times the port is polled while executing the task."
    },
    {
        "id": 526,
        "Question": "Which of the following can improve the quality and the structure of a code?",
        "Options": [
            "a) polling",
            "b) subroutine",
            "c) sequential code",
            "d) concurrent code"
        ],
        "Answer": "Answer: b\nExplanation: The subroutine can improve the quality and the structure of the code. By using the polling method, as the complexity increases the software structure rapidly fall and it will become inefficient. So the subroutine method is adopted."
    },
    {
        "id": 527,
        "Question": "Which of the following are asynchronous to the operation?",
        "Options": [
            "a) interrupts",
            "b) software",
            "c) DMA",
            "d) memory"
        ],
        "Answer": "Answer: a\nExplanation: The interrupts are asynchronous to the operation and therefore can be used with systems that are the event as opposed to the time driven."
    },
    {
        "id": 528,
        "Question": "Which of the following can be used to create time-driven systems?",
        "Options": [
            "a) memory",
            "b) input",
            "c) output",
            "d) interrupts"
        ],
        "Answer": "Answer: d\nExplanation: The interrupts which are asynchronous can be used with systems that are the event as opposed to the time driven."
    },
    {
        "id": 529,
        "Question": "What does ISR stand for?",
        "Options": [
            "a) interrupt standard routine",
            "b) interrupt service routine",
            "c) interrupt software routine",
            "d) interrupt synchronous routine"
        ],
        "Answer": "Answer: b\nExplanation: The data transfer codes are written as part of the interrupt service routine which is associated with the interrupt generation by the hardware."
    },
    {
        "id": 530,
        "Question": "Which can activate the ISR?",
        "Options": [
            "a) interrupt",
            "b) function",
            "c) procedure",
            "d) structure"
        ],
        "Answer": "Answer: a\nExplanation: When the port receives the data, it will generate an interrupt which in turn activates the ISR."
    },
    {
        "id": 531,
        "Question": "Which code is written as part of the ISR?",
        "Options": [
            "a) data receive code",
            "b) sequential code",
            "c) data transfer code",
            "d) concurrent code"
        ],
        "Answer": "Answer: c\nExplanation: The data transfer codes are written as part of the interrupt service routine which is associated with the interrupt generation by the hardware."
    },
    {
        "id": 532,
        "Question": "Which interrupts are generated by the on-chip peripherals?",
        "Options": [
            "a) internal",
            "b) external",
            "c) software",
            "d) hardware"
        ],
        "Answer": "Answer: a\nExplanation: The internal interrupts are generated by the serial and parallel ports which are on-chip peripherals."
    },
    {
        "id": 533,
        "Question": "Which of the following is the common method for connecting the peripheral to the processor?",
        "Options": [
            "a) internal interrupts",
            "b) external interrupts",
            "c) software",
            "d) exception"
        ],
        "Answer": "Answer: b\nExplanation: The common method for connecting the peripheral to the processor is the external interrupts. The external interrupts are provided through the external pins which are connected to the peripherals."
    },
    {
        "id": 534,
        "Question": "Which interrupt can make a change in the processor’s mode?",
        "Options": [
            "a) internal interrupt",
            "b) external interrupts",
            "c) exceptions",
            "d) software mode"
        ],
        "Answer": "Answer: c\nExplanation: An exception is an event which changes the software flow to process the event. It includes both internal and external interrupts which cause the processor to change to a service routine."
    },
    {
        "id": 535,
        "Question": "How many exceptions does an MC68000 have?",
        "Options": [
            "a) 256",
            "b) 128",
            "c) 90",
            "d) 70"
        ],
        "Answer": "Answer: c\nExplanation: The MC68000 have 256 table entries which describe 90 exceptions."
    },
    {
        "id": 536,
        "Question": "Which interrupts allows a protected state?",
        "Options": [
            "a) internal interrupt",
            "b) external interrupt",
            "c) software interrupt",
            "d) both internal and external interrupts"
        ],
        "Answer": "Answer: c\nExplanation: The software interrupt can change the processor into a protected state by changing the program flow."
    },
    {
        "id": 537,
        "Question": "How a software interrupt is created?",
        "Options": [
            "a) instruction set",
            "b) sequential code",
            "c) concurrent code",
            "d) porting"
        ],
        "Answer": "Answer: a\nExplanation: The software interrupts includes a set of instructions for handling interrupts. The instruction set allows a currently executing program to change its flow."
    },
    {
        "id": 538,
        "Question": "What does SWI stand for?",
        "Options": [
            "a) standard interrupt instruction",
            "b) sequential interrupt instruction",
            "c) software interrupt instruction",
            "d) system interrupt instruction"
        ],
        "Answer": "Answer: c\nExplanation: The instruction set of software interrupts are provided by the special instruction set. One such is the SWI which is commonly used in Z80."
    },
    {
        "id": 539,
        "Question": "Which of the following use SWI as interrupt mechanism?",
        "Options": [
            "a) PowerPC",
            "b) MC68000",
            "c) Z80",
            "d) IBM PC"
        ],
        "Answer": "Answer: c\nExplanation: The PowerPC and  MC68000 use TRAP instruction set for accessing software interrupt. IBM PC uses 8086 NMI. Z80 uses SWI for accessing software interrupts."
    },
    {
        "id": 540,
        "Question": "Which of the following supplies additional data to the software interrupt?",
        "Options": [
            "a) internal interrupt",
            "b) external interrupt",
            "c) software interrupt",
            "d) nmi"
        ],
        "Answer": "Answer: c\nExplanation: For using the software interrupt more effectively, the additional data are used, which specifies the type of the request and data parameters are passed to the specific ISR. This additional data are offered by certain registers."
    },
    {
        "id": 541,
        "Question": "Which software interrupt is used in MC68000?",
        "Options": [
            "a) Internal interrupt",
            "b) TRAP",
            "c) SWI",
            "d) NMI"
        ],
        "Answer": "Answer: b\nExplanation: The MC68000 uses a software interrupt mechanism for accessing interrupts from the peripheral in which the instruction are created using the TRAP mechanism."
    },
    {
        "id": 542,
        "Question": "Which of the following are accessible by the ISR in software interrupt mechanism?",
        "Options": [
            "a) register",
            "b) interrupt",
            "c) nmi",
            "d) memory"
        ],
        "Answer": "Answer: a\nExplanation: The additional data are offered by certain registers and these additional data are used to specify the type of the data parameter and the request with the specific ISR when running in the software interrupt mode. "
    },
    {
        "id": 543,
        "Question": "What allows the data protection in the software interrupt mechanism?",
        "Options": [
            "a) Different mode",
            "b) Same mode",
            "c) SWI",
            "d) TRAP"
        ],
        "Answer": "Answer: a\nExplanation: The switching between user mode and supervisor mode provides protection for the processor, that is, the different modes in the software interrupt allows the memory and the associated code and data to be protected from each other."
    },
    {
        "id": 544,
        "Question": "What does NMI stand for?",
        "Options": [
            "a) non-machine interrupt",
            "b) non-maskable interrupt",
            "c) non-massive interrupt",
            "d) non-memory interrupt"
        ],
        "Answer": "Answer: b\nExplanation: The NMI stand for the non-maskable interrupt in which the external interrupts cannot be masked out."
    },
    {
        "id": 545,
        "Question": "Which NMI is used in the IBM PC?",
        "Options": [
            "a) SWI",
            "b) TRAP",
            "c) 80×86 NMI",
            "d) Maskable interrupt"
        ],
        "Answer": "Answer: c\nExplanation: The most commonly used non-maskable interrupt is the 80×86 NMI, which is implemented in the IBM PC."
    },
    {
        "id": 546,
        "Question": "Which can be used to pass the status information to the calling software in the software interrupt mechanism?",
        "Options": [
            "a) register",
            "b) memory",
            "c) flag",
            "d) nmi"
        ],
        "Answer": "Answer: a\nExplanation: In order to use the software interrupt more effectively, the additional data are used to specify the type of the request and data parameters are passed to the specific ISR. This additional data are offered by certain registers. These registers are accessible by the ISR and it can also be used to pass the status information back to the calling software."
    },
    {
        "id": 547,
        "Question": "Which of the following uses clock edge to generate an interrupt?",
        "Options": [
            "a) edge triggered",
            "b) level-triggered",
            "c) software interrupt",
            "d) nmi"
        ],
        "Answer": "Answer: a\nExplanation: In the edge-triggered interrupt, the clock edge is used to generate an interrupt. The transition is from a logical low to high or vice versa."
    },
    {
        "id": 548,
        "Question": "In which interrupt, the trigger is dependent on the logic level?",
        "Options": [
            "a) edge triggered",
            "b) level-triggered",
            "c) software interrupt",
            "d) nmi"
        ],
        "Answer": "Answer: b\nExplanation: In the level-triggered interrupt, the trigger is completely dependent on the logic level. The processors may require the level to be in a certain clock width so that the shorter pulses which are shorter than the minimum pulse width are ignored."
    },
    {
        "id": 549,
        "Question": "At which point the processor will start to internally process the interrupt?",
        "Options": [
            "a) interrupt pointer",
            "b) instruction pointer",
            "c) instruction boundary",
            "d) interrupt boundary"
        ],
        "Answer": "Answer: c\nExplanation: After the recognition of the interrupt, and finds that it is not an error condition with the currently executing interrupt, then the interrupt will not be internally executed until the current execution has completed. This point is known as the instruction boundary. At this point, the processor will start to internally process the interrupt."
    },
    {
        "id": 550,
        "Question": "What does 80×86 use to hold essential data?",
        "Options": [
            "a) stack frame",
            "b) register",
            "c) internal register",
            "d) flag register"
        ],
        "Answer": "Answer: a\nExplanation: The MC68000 and 80×86 family use stack frame for holding the data whereas RISC processors use special internal registers."
    },
    {
        "id": 551,
        "Question": "What does the RISC processor use to hold the data?",
        "Options": [
            "a) flag register",
            "b) accumulator",
            "c) internal register",
            "d) stack register"
        ],
        "Answer": "Answer: c\nExplanation: The RISC processors uses special internal registers to hold data whereas the 80×86 and MC68000 family uses stack register to hold the data."
    },
    {
        "id": 552,
        "Question": "Which of the following is a stack-based processor?",
        "Options": [
            "a) MC68000",
            "b) PowerPC",
            "c) ARM",
            "d) DEC Alpha"
        ],
        "Answer": "Answer: a\nExplanation: The MC68000, Intel 80×86 and most of the b-bit controllers are based on the stack-based processors whereas PowerPC, DEC alpha, and ARM are RISC families which have a special internal register for holding the data."
    },
    {
        "id": 553,
        "Question": "Which of the following is used to reduce the external memory cycle?",
        "Options": [
            "a) internal hardware stack",
            "b) internal software stack",
            "c) external software stack",
            "d) internal register"
        ],
        "Answer": "Answer: a\nExplanation: Some of the processors use internal hardware stack which helps in reducing the external memory cycle necessary to store the stack frame."
    },
    {
        "id": 554,
        "Question": "How many interrupt levels are supported in the MC68000?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 7"
        ],
        "Answer": "Answer: d\nExplanation: The MC68000 has an external stack for holding the data. The MC68000 family supports a seven interrupt level which are encoded into three interrupt pins."
    },
    {
        "id": 555,
        "Question": "How many interrupt pins are used in MC68000?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: b\nExplanation: The MC68000 family supports a seven interrupt level which are encoded into three interrupt pins. These interrupt pins are IP0, IP1, and IP2."
    },
    {
        "id": 556,
        "Question": "Which priority encoder is used in MC68000?",
        "Options": [
            "a) 4-to-2 priority encoder",
            "b) LS148 7-to-3",
            "c) 2-to-4 priority encoder",
            "d) LS148 3-to-7"
        ],
        "Answer": "Answer: b\nExplanation: The LS148 7-to-3 priority encoder is used in MC68000. This converts the seven external pins into a three-bit binary code."
    },
    {
        "id": 557,
        "Question": "Which of the following converts the seven external pins into a 3-bit binary code?",
        "Options": [
            "a) priority encoder",
            "b) 4-to-2 priority encoder",
            "c) LS148 7-to-3",
            "d) 2-to-4 priority encoder"
        ],
        "Answer": "Answer: c\nExplanation:  The LS148 7-to-3 priority encoder can convert the seven external pins into a three-bit binary code."
    },
    {
        "id": 558,
        "Question": "Which of the following ensures the recognition of the interrupt?",
        "Options": [
            "a) interrupt ready",
            "b) interrupt acknowledge",
            "c) interrupt terminal",
            "d) interrupt start"
        ],
        "Answer": "Answer: b\nExplanation: The interrupt level remains asserted until its interrupt acknowledgment cycle ensures the recognition of the interrupt."
    },
    {
        "id": 559,
        "Question": "Which of the following is raised to the interrupt level to prevent the multiple interrupt request?",
        "Options": [
            "a) internal interrupt mask",
            "b) external interrupt mask",
            "c) non-maskable interrupt",
            "d) software interrupt"
        ],
        "Answer": "Answer: a\nExplanation: The internal interrupt mask is raised to the interrupt level, in order to prevent the multiple interrupt acknowledgments."
    },
    {
        "id": 560,
        "Question": "What does MSR stand for?",
        "Options": [
            "a) machine state register",
            "b) machine software register",
            "c) minimum state register",
            "d) maximum state register"
        ],
        "Answer": "Answer: a\nExplanation: The MSR is a machine state register. When the exception is recognised, the address of the instruction and the MSR are stored in the supervisor registers while handling an exception."
    },
    {
        "id": 561,
        "Question": "How many supervisor registers are associated with the exception mode?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: When the exception is recognised, the address of the instruction and the machine state register(MSR) are stored in the supervisor registers in the exception mode. There are two supervisor registers SRR0 and SRR1."
    },
    {
        "id": 562,
        "Question": "What happens when an exception is completed?",
        "Options": [
            "a) TRAP instruction executes",
            "b) SWI instruction executes",
            "c) RFI instruction executes",
            "d) terminal count increases"
        ],
        "Answer": "Answer: c\nExplanation: When an exception is recognised, the address of the instruction and the MSR are stored in the supervisor registers and the processor moves to the supervisor mode and starts to execute the handler which is associated with the vector table. The handler examines the DSISR and FPSCR registers and carries out the required function. When it gets completed the RFI or return-from-interrupt instruction is executed."
    },
    {
        "id": 563,
        "Question": "How many general types of exceptions are there?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 6",
            "d) 4"
        ],
        "Answer": "Answer: d\nExplanation: There are four general types of exceptions. They are synchronous precise, asynchronous precise, synchronous imprecise and asynchronous imprecise."
    },
    {
        "id": 564,
        "Question": "In which of the exceptions does the external event causes the exception?",
        "Options": [
            "a) synchronous exception",
            "b) asynchronous exception",
            "c) precise",
            "d) imprecise"
        ],
        "Answer": "Answer: b\nExplanation: The asynchronous exception is the one in which an external event causes an exception and is independent of the instruction flow. On the other hand, the synchronous exceptions are synchronised, that is, it is caused by the instruction flow."
    },
    {
        "id": 565,
        "Question": "Which of the exceptions are usually a catastrophic failure?",
        "Options": [
            "a) imprecise exception",
            "b) precise exception",
            "c) synchronous exception",
            "d) asynchronous exception"
        ],
        "Answer": "Answer: a\nExplanation: An imprecise exception is a catastrophic failure in which the processor cannot continue processing or allow a particular task or program to continue."
    },
    {
        "id": 566,
        "Question": "Which of the exceptions allows the system reset or memory fault?",
        "Options": [
            "a) imprecise exception",
            "b) precise exception",
            "c) synchronous exception",
            "d) asynchronous exception"
        ],
        "Answer": "Answer: a\nExplanation: The system reset or memory fault falls into the category of imprecise exceptions while accessing the vector table."
    },
    {
        "id": 567,
        "Question": "Which registers are used to determine the completion status?",
        "Options": [
            "a) MSR",
            "b) flag register",
            "c) DSISR",
            "d) index register"
        ],
        "Answer": "Answer: c\nExplanation: The completion status can be determined by the information bits in the DSISR and FPSCR registers."
    },
    {
        "id": 568,
        "Question": "Which of the following does not support PowerPC architecture?",
        "Options": [
            "a) synchronous precise",
            "b) asynchronous precise",
            "c) synchronous imprecise",
            "d) asynchronous imprecise"
        ],
        "Answer": "Answer: c\nExplanation: The synchronous imprecise is usually not supported on the PowerPC architecture and also in the MPC601, MPC603 etc."
    },
    {
        "id": 569,
        "Question": "Which exceptions are used in the PowerPC for floating point?",
        "Options": [
            "a) synchronous imprecise",
            "b) asynchronous imprecise",
            "c) synchronous precise",
            "d) synchronous imprecise"
        ],
        "Answer": "Answer: a\nExplanation: The PowerPC can handle the floating point exception by making use of the synchronous imprecise mode."
    },
    {
        "id": 570,
        "Question": "Which exception is used in the external interrupts and decrementer-caused exceptions?",
        "Options": [
            "a) synchronous precise",
            "b) asynchronous precise",
            "c) synchronous imprecise",
            "d) asynchronous imprecise"
        ],
        "Answer": "Answer: b\nExplanation: The asynchronous precise type exception is used to handle the external interrupts and decrementer-caused exceptions. Both these can occur at any time within the instruction flow."
    },
    {
        "id": 571,
        "Question": "Which exception can be masked by clearing the EE bit to zero in the MSR?",
        "Options": [
            "a) synchronous imprecise",
            "b) synchronous precise",
            "c) asynchronous imprecise",
            "d) asynchronous precise"
        ],
        "Answer": "Answer: d\nExplanation: The asynchronous precise type exceptions can be masked by clearing the EE bits in the MSR. This bit is automatically cleared to zero in the MSR in order to prevent this interrupt causing an exception while other exceptions are being processed."
    },
    {
        "id": 572,
        "Question": "Which of the following can be done to ensure that all interrupts are recognised?",
        "Options": [
            "a) reset pin",
            "b) external ready pin",
            "c) handshaking",
            "d) acknowledgment"
        ],
        "Answer": "Answer: c\nExplanation: The exception handler performs some kind of handshaking to ensure that all the interrupts are recognised."
    },
    {
        "id": 573,
        "Question": "How many types of exceptions are associated with the asynchronous imprecise?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: Two types of exceptions are associated with the asynchronous imprecise. These are system reset and machine checks."
    },
    {
        "id": 574,
        "Question": "How is the internal registers and memories are reset?",
        "Options": [
            "a) system reset",
            "b) memory reset",
            "c) peripheral reset",
            "d) software reset"
        ],
        "Answer": "Answer: a\nExplanation: By doing the system reset, all the current processing are stopped and the internal registers and the memories are reset."
    },
    {
        "id": 575,
        "Question": "How is the machine check exception is taken in an asynchronous imprecise?",
        "Options": [
            "a) ME bit",
            "b) EE bit",
            "c) FE0",
            "d) FE1"
        ],
        "Answer": "Answer: a\nExplanation: The machine check exception is taken only if the ME bit of the MSR is set. If it is cleared, the processor will enter into a check stop state."
    },
    {
        "id": 576,
        "Question": "Which of the following are the exceptions associated with the asynchronous imprecise?",
        "Options": [
            "a) decrementer interrupt",
            "b) machine check",
            "c) instruction dependent",
            "d) external interrupt"
        ],
        "Answer": "Answer: b\nExplanation: The machine check and the system reset are two types of exceptions which are associated with the asynchronous imprecise."
    },
    {
        "id": 577,
        "Question": "Which of the following possesses an additional priority?",
        "Options": [
            "a) asynchronous precise",
            "b) asynchronous imprecise",
            "c) synchronous precise",
            "d) synchronous imprecise"
        ],
        "Answer": "Answer: c\nExplanation: The synchronous precise exceptions provide additional priority because it is possible for an instruction to generate more than one exception."
    },
    {
        "id": 578,
        "Question": "Which of the following has more priority?",
        "Options": [
            "a) system reset",
            "b) machine check",
            "c) external interrupt",
            "d) decrementer interrupt"
        ],
        "Answer": "Answer: a\nExplanation: The system reset has the first priority then comes the machine reset, next priority moves for the instruction dependent, and the next priority is an external interrupt, and last priority level goes for the decrementer interrupt."
    },
    {
        "id": 579,
        "Question": "Which bit controls the external interrupts and the decrementer exceptions?",
        "Options": [
            "a) FE1",
            "b) FE0",
            "c) EE",
            "d) ME"
        ],
        "Answer": "Answer: c\nExplanation: The EE bit in the MSR controls the external interrupts and the decrementer exceptions."
    },
    {
        "id": 580,
        "Question": "Which bit controls the machine check exceptions?",
        "Options": [
            "a) ME",
            "b) FE0",
            "c) FE1",
            "d) EE"
        ],
        "Answer": "Answer: a\nExplanation: The ME bit in the MSR controls the machine check interrupts."
    },
    {
        "id": 581,
        "Question": "Which bits control the floating point exceptions?",
        "Options": [
            "a) EE",
            "b) FE0",
            "c) FE1",
            "d) both FE1 and FE2"
        ],
        "Answer": "Answer: d\nExplanation:  The FE0 and FE1 control the floating point exceptions."
    },
    {
        "id": 582,
        "Question": "Which of the following is a 16 kbyte block?",
        "Options": [
            "a) register",
            "b) vector table",
            "c) buffer",
            "d) lookaside buffer"
        ],
        "Answer": "Answer: b\nExplanation: The vector table is a 16 kbyte block which is divided into 256 byte divisions in which each division is allocated for particular exceptions and it also contains the handler routine associated with the exceptions."
    },
    {
        "id": 583,
        "Question": "Which processors use fast interrupts?",
        "Options": [
            "a) DSP processor",
            "b) RISC processor",
            "c) CISC processor",
            "d) Harvard processor"
        ],
        "Answer": "Answer: a\nExplanation: The fast interrupts are used in the DSP processors or in microcontrollers in which a small routine is executed without saving the context of the processor."
    },
    {
        "id": 584,
        "Question": "Which interrupts generate fast interrupt exception?",
        "Options": [
            "a) internal interrupt",
            "b) external interrupt",
            "c) software interrupt",
            "d) hardware interrupt"
        ],
        "Answer": "Answer: b\nExplanation: The external interrupts generates the fast interrupt routine exception in which the external interrupt is synchronised with the processor clock."
    },
    {
        "id": 585,
        "Question": "What is the disadvantage of the fast interrupts?",
        "Options": [
            "a) stack frame",
            "b) delay",
            "c) size of routine",
            "d) low speed"
        ],
        "Answer": "Answer: c\nExplanation: The disadvantages associated with the fast interrupt is the size of routine which can be executed and the resources allocated. In this technique, it allocates a couple of address registers for the fast interrupt routine."
    },
    {
        "id": 586,
        "Question": "Which of the following does not have a stack frame building?",
        "Options": [
            "a) hardware interrupt",
            "b) software interrupt",
            "c) non-maskable interrupt",
            "d) fast interrupt"
        ],
        "Answer": "Answer: d\nExplanation: The fast interrupt does not have stack frame building and it does not possess any such delays. This can be considered as the advantage of the fast interrupts."
    },
    {
        "id": 587,
        "Question": "What is programmed to generate a two instruction fast interrupt?",
        "Options": [
            "a) software",
            "b) application",
            "c) timer",
            "d) sensor"
        ],
        "Answer": "Answer: c\nExplanation: The SCI timer generates the two instruction fast interrupt. This increment the register R1."
    },
    {
        "id": 588,
        "Question": "Which of the following can auto increment the register R1?",
        "Options": [
            "a) SCI timer",
            "b) interrupt",
            "c) software interrupt",
            "d) non-maskable interrupt"
        ],
        "Answer": "Answer: a\nExplanation: The SCI timer is used to generate the two instruction fast interrupt that can increment the register R1 which acts as a simple counter."
    },
    {
        "id": 589,
        "Question": "Which of the following forces a standard service routine?",
        "Options": [
            "a) READY interrupt",
            "b) IRQA interrupt",
            "c) NMI",
            "d) software interrupt"
        ],
        "Answer": "Answer: b\nExplanation:  The SCI timer is used to generate the two instruction fast interrupt which increments the register R1 that acts as a simple counter which times the period between the events. The events itself generates an IRQA interrupt, that forces the service routine."
    },
    {
        "id": 590,
        "Question": "Which of the following can be used as a reset button?",
        "Options": [
            "a) NMI",
            "b) internal interrupt",
            "c) external interrupt",
            "d) software interrupt"
        ],
        "Answer": "Answer: a\nExplanation: The non-maskable interrupt is used to generate an interrupt to try and recover control and therefore, the NMI can be used as a reset button."
    },
    {
        "id": 591,
        "Question": "Which of the following is connected to a fault detection circuit?",
        "Options": [
            "a) internal interrupt",
            "b) external interrupt",
            "c) NMI",
            "d) software interrupt"
        ],
        "Answer": "Answer: c\nExplanation: The non-maskable interrupt is used to generate an interrupt which can be connected to a fault detection circuit like watchdog timer or parity checker."
    },
    {
        "id": 592,
        "Question": "Which of the following provides a buffer between the user and the low-level interfaces to the hardware?",
        "Options": [
            "a) operating system",
            "b) kernel",
            "c) software",
            "d) hardware"
        ],
        "Answer": "Answer: a\nExplanation: The operating system is software which provides a buffer between the low-level interfaces to the hardware within the system and the user."
    },
    {
        "id": 593,
        "Question": "Which of the following enables the user to utilise the system efficiently?",
        "Options": [
            "a) kernel",
            "b) operating system",
            "c) software",
            "d) hardware"
        ],
        "Answer": "Answer: b\nExplanation: The operating system is software that enables the users to utilise the system effectively."
    },
    {
        "id": 594,
        "Question": "Which of the following can make the application program hardware independent?",
        "Options": [
            "a) software",
            "b) application manager",
            "c) operating system",
            "d) kernel"
        ],
        "Answer": "Answer: c\nExplanation: The operating system allows the software to be moved from one system to another and therefore, it can make the application program hardware independent."
    },
    {
        "id": 595,
        "Question": " Which of the following speed up the testing process?",
        "Options": [
            "a) kernel",
            "b) software",
            "c) application manager",
            "d) program debugging tools"
        ],
        "Answer": "Answer: d\nExplanation: The program debugging tools can speed up the testing process which can make the processor faster."
    },
    {
        "id": 596,
        "Question": "Which of the following includes its own I/O routine?",
        "Options": [
            "a) hardware",
            "b) kernel",
            "c) operating system",
            "d) application manager"
        ],
        "Answer": "Answer: c\nExplanation: An operating system is a software which includes its own I/o routine in order to drive the serial ports and the parallel ports."
    },
    {
        "id": 597,
        "Question": "Which forms the heart of the operating system?",
        "Options": [
            "a) kernel",
            "b) applications",
            "c) hardware",
            "d) operating system"
        ],
        "Answer": "Answer: a\nExplanation: The kernel is the heart of the operating system. This can control the hardware and can deal with the interrupts, I/O systems, memory etc."
    },
    {
        "id": 598,
        "Question": "Which of the following locates a parameter block by using an address pointer?",
        "Options": [
            "a) OS",
            "b) kernel",
            "c) system",
            "d) memory"
        ],
        "Answer": "Answer: b\nExplanation:  The kernel is the heart of the operating system which can control the hardware and can deal with the interrupts, I/O systems, memory etc. It can also locate the parameter block by using an address pointer which is stored in the predetermined address register."
    },
    {
        "id": 599,
        "Question": "Which of the following are not dependent on the actual hardware performing the physical task?",
        "Options": [
            "a) applications",
            "b) hardware",
            "c) registers",
            "d) parameter block"
        ],
        "Answer": "Answer: d\nExplanation: The kernel can locate the parameter block by using an address pointer which is stored in the predetermined address register. These parameter blocks are standard throughout the operating system, that is, they are not dependent on the actual hardware performing the physical task."
    },
    {
        "id": 600,
        "Question": "Which of the following bus can easily upgrade the system hardware?",
        "Options": [
            "a) control bus",
            "b) data bus",
            "c) VMEbus",
            "d) bus interface unit"
        ],
        "Answer": "Answer: c\nExplanation: The software can be easily moved from one system to another which is more important for designing embedded systems, especially for those which use an industry standard bus such as VMEbus, in which the system hardware can be expanded or upgraded."
    },
    {
        "id": 601,
        "Question": "Which of the following is the first widely used operating system?",
        "Options": [
            "a) MS-DOS",
            "b) windows XP",
            "c) android",
            "d) CP/M"
        ],
        "Answer": "Answer:d\nExplanation: The first widely used operating system is the CP/M which is developed for Intel 8080 and the 8”floppy disk system."
    },
    {
        "id": 602,
        "Question": "Which of the following is an example of a single task operating system?",
        "Options": [
            "a) android",
            "b) windows",
            "c) IOS",
            "d) CP/M"
        ],
        "Answer": "Answer: d\nExplanation: The CP/M is a single task operating system, that is, only one task or an application can be executed at a time."
    },
    {
        "id": 603,
        "Question": "Which of the following becomes a limiting factor while an application program has to be complete?",
        "Options": [
            "a) memory",
            "b) peripheral",
            "c) input",
            "d) output"
        ],
        "Answer": "Answer: a\nExplanation: The application program has to complete and the memory becomes a limiting factor, which can be solved by using program overlays."
    },
    {
        "id": 604,
        "Question": "Which of the following cannot carry implicit information?",
        "Options": [
            "a) semaphore",
            "b) message passing",
            "c) threads",
            "d) process"
        ],
        "Answer": "Answer: a\nExplanation: The kernel in the real-time operating system which deals with the flag but cannot carry implicit information are called semaphores or events."
    },
    {
        "id": 605,
        "Question": "Which of the following works by dividing the processor’s time?",
        "Options": [
            "a) single task operating system",
            "b) multitask operating system",
            "c) kernel",
            "d) applications"
        ],
        "Answer": "Answer: b\nExplanation: The multitasking operating system works by dividing the processor’s time into different discrete time slots, that is, each application requires a defined number of time slots to complete its execution."
    },
    {
        "id": 606,
        "Question": "Which of the following decides which task can have the next time slot?",
        "Options": [
            "a) single task operating system",
            "b) applications",
            "c) kernel",
            "d) software"
        ],
        "Answer": "Answer: c\nExplanation: The operating system kernel decides which task can have the next time slot. So instead of the task executing continuously until completion, the execution of the processor is interleaved with the other tasks."
    },
    {
        "id": 607,
        "Question": "Which of the following controls the time slicing mechanism in a multitasking operating system?",
        "Options": [
            "a) kernel",
            "b) single tasking kernel",
            "c) multitasking kernel",
            "d) application manager"
        ],
        "Answer": "Answer: c\nExplanation: The multitasking operating systems are associated with the multitasking kernel which controls the time slicing mechanism."
    },
    {
        "id": 608,
        "Question": "Which of the following provides a time period for the context switch?",
        "Options": [
            "a) timer",
            "b) counter",
            "c) time slice",
            "d) time machine"
        ],
        "Answer": "Answer: c\nExplanation: The time period required for each task for execution before it is stopped and replaced during a context switch is known as the time slice."
    },
    {
        "id": 609,
        "Question": "Which of the following can periodically trigger the context switch?",
        "Options": [
            "a) software interrupt",
            "b) hardware interrupt",
            "c) peripheral",
            "d) memory"
        ],
        "Answer": "Answer: b\nExplanation: The multitasking operating systems are associated with the multitasking kernel which controls the time slicing mechanism. The time period required for each task for execution before it is stopped and replaced during a context switch is known as the time slice. These are periodically triggered by a hardware interrupt from the system timer."
    },
    {
        "id": 610,
        "Question": "Which interrupt provides system clock in the context switching?",
        "Options": [
            "a) software interrupt",
            "b) hardware interrupt",
            "c) peripheral",
            "d) memory"
        ],
        "Answer": "Answer: b\nExplanation: The multitasking operating systems deals with the multitasking kernel which controls the time slicing mechanism and the time period required for each task for execution before it is stopped and replaced during a context switch is known as the time slice which are periodically triggered by a hardware interrupt from the system timer. This hardware interrupt provides the system clock in which several interrupts are executed and counted before a context switch is performed."
    },
    {
        "id": 611,
        "Question": "The special tale in the multitasking operating system is also known as",
        "Options": [
            "a) task control block",
            "b) task access block",
            "c) task address block",
            "d) task allocating block"
        ],
        "Answer": "Answer: a\nExplanation: When a context switch is performed, the current program or task is interrupted, so the processor’s registers are saved in a special table which is known as task control block."
    },
    {
        "id": 612,
        "Question": "Which of the following stores all the task information that the system requires?",
        "Options": [
            "a) task access block",
            "b) register",
            "c) accumulator",
            "d) task control block"
        ],
        "Answer": "Answer: d\nExplanation: The task control block stores all the task information that the system requires and this is done when the context switch is performed so that the currently running program is interrupted."
    },
    {
        "id": 613,
        "Question": "Which of the following contains all the task and their status?",
        "Options": [
            "a) register",
            "b) ready list",
            "c) access list",
            "d) task list"
        ],
        "Answer": "Answer: b\nExplanation: The ‘ready’ list possesses all the information regarding a task, that is, all the task and its corresponding status which is used by the scheduler to decide which task should execute in the next time slice."
    },
    {
        "id": 614,
        "Question": "Which determines the sequence and the associated task’s priority?",
        "Options": [
            "a) scheduling algorithm",
            "b) ready list",
            "c) task control block",
            "d) application register"
        ],
        "Answer": "Answer: a\nExplanation: The scheduling algorithm determines the sequence and an associated task’s priority. It also determines the present status of the task."
    },
    {
        "id": 615,
        "Question": "Which can control memory usage?",
        "Options": [
            "a) operating system",
            "b) applications",
            "c) hardware",
            "d) kernel"
        ],
        "Answer": "Answer:d\nExplanation: The kernel can control the memory usage and it can also prevent the tasks from corrupting each other."
    },
    {
        "id": 616,
        "Question": "Which can control the memory sharing between the tasks?",
        "Options": [
            "a) kernel",
            "b) application",
            "c) software",
            "d) OS"
        ],
        "Answer": "Answer: a\nExplanation: The kernel can control memory sharing between tasks which allow sharing common program modules."
    },
    {
        "id": 617,
        "Question": "Which of the following can implement the message passing and control?",
        "Options": [
            "a) application software",
            "b) operating system",
            "c) software",
            "d) kernel"
        ],
        "Answer": "Answer: d\nExplanation: The kernel can implement the message passing and control which acts as a message passer and controller between the tasks."
    },
    {
        "id": 618,
        "Question": "How many types of messages are associated with the real-time operating system?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: There are two basic types of messages associated with the real-time operating system. These are semaphores and messages."
    },
    {
        "id": 619,
        "Question": "Which of the following can carry information and control task?",
        "Options": [
            "a) semaphore",
            "b) messages",
            "c) flags",
            "d) address message"
        ],
        "Answer": "Answer: b\nExplanation: The messages can carry information and it can also control the task regarding the real-time operating systems. These are also known as events."
    },
    {
        "id": 620,
        "Question": "Which task swapping method does not require the time critical operations?",
        "Options": [
            "a) time slice",
            "b) pre-emption",
            "c) cooperative multitasking",
            "d) schedule algorithm"
        ],
        "Answer": "Answer: a\nExplanation: Time-critical operations are not essential in the time slice mechanism. Time slice mechanism describes the task switching in a particular time slot."
    },
    {
        "id": 621,
        "Question": "Which task swap method works in a regular periodic point?",
        "Options": [
            "a) pre-emption",
            "b) time slice",
            "c) schedule algorithm",
            "d) cooperative multitasking"
        ],
        "Answer": "Answer: b\nExplanation: The time slicing works by switching task in regular periodic points in time, that is, any task that needs to run next will have to wait until the current time slice is completed."
    },
    {
        "id": 622,
        "Question": "Which of the following determines the next task in the time slice method of task swapping?",
        "Options": [
            "a) scheduling program",
            "b) scheduling application",
            "c) scheduling algorithm",
            "d) scheduling task"
        ],
        "Answer": "Answer: c\nExplanation: The time slice mechanism can also be used as a scheduling method in which the task to run next is determined by the scheduling algorithm."
    },
    {
        "id": 623,
        "Question": "Which of the following can be used to distribute the time slice across all the task?",
        "Options": [
            "a) timer",
            "b) counter",
            "c) round-robin",
            "d) task slicing"
        ],
        "Answer": "Answer: c\nExplanation: The time slice based system uses fairness scheduler or round robin to distribute the time slices across all the tasks that need to run in a particular time slot."
    },
    {
        "id": 624,
        "Question": "What do a time slice period plus a context switch time of the processor determines?",
        "Options": [
            "a) scheduling task",
            "b) scheduling algorithm",
            "c) context task",
            "d) context switch time"
        ],
        "Answer": "Answer: d\nExplanation: The context switch time of the processor along with the time slice period determines the context switch time of the system which is an important factor in system response, that is, the time period can be reduced to improve the context switching of the system which will increase the number of task switches."
    },
    {
        "id": 625,
        "Question": "Which can increase the number of task switches?",
        "Options": [
            "a) time period",
            "b) frequency",
            "c) time rate",
            "d) number of cycles"
        ],
        "Answer": "Answer: a\nExplanation: The time period can be reduced to improve the context switching of the system which will increase the number of task switches."
    },
    {
        "id": 626,
        "Question": "Which mechanism is used behind the Windows 3.1?",
        "Options": [
            "a) time slice",
            "b) pre-emption",
            "c) cooperative multitasking",
            "d) scheduling algorithm"
        ],
        "Answer": "Answer: c\nExplanation: The cooperative multitasking mechanism is used the Windows 3.1 but it is not applicable to the real-time operating systems."
    },
    {
        "id": 627,
        "Question": "Which of the following provides an illusion of multitasking?",
        "Options": [
            "a) single task operating system",
            "b) multitasking operating system",
            "c) cooperative multitasking",
            "d) pre-emption"
        ],
        "Answer": "Answer: c\nExplanation: The cooperative multitasking co-operates between them which provides the illusion of multitasking. This is done by periodically executing the tasks."
    },
    {
        "id": 628,
        "Question": "Which task method follows a currently running task to be stopped by a higher priority task?",
        "Options": [
            "a) scheduling algorithm",
            "b) time slice",
            "c) cooperative multitasking",
            "d) pre-emption"
        ],
        "Answer": "Answer: d\nExplanation: The pre-emption is an alternative method of the time slice where the currently running task can be stopped or preempted or switched out by a higher priority active task."
    },
    {
        "id": 629,
        "Question": "Which of the following requires programming within the application?",
        "Options": [
            "a) time slice",
            "b) scheduling algorithm",
            "c) pre-emption",
            "d) cooperative multitasking"
        ],
        "Answer": "Answer: d\nExplanation: The cooperative multitasking requires programming within the application and the system can be destroyed by a single program which hogs all the processing power. Therefore, it is not applicable in the real-time operating system."
    },
    {
        "id": 630,
        "Question": "What does RMS stand for?",
        "Options": [
            "a) rate monotonic scheduling",
            "b) rate machine scheduling",
            "c) rate monotonic software",
            "d) rate machine software"
        ],
        "Answer": "Answer: a\nExplanation: The rate monotonic scheduling is a method that is used to assign priority for a pre-emptive system such that the correct execution can be guaranteed."
    },
    {
        "id": 631,
        "Question": "Which of the following task swapping method is a better choice in the embedded systems design?",
        "Options": [
            "a) RMS",
            "b) pre-emptive",
            "c) cooperative multitasking",
            "d) time slice"
        ],
        "Answer": "Answer: b\nExplanation: The pre-emptive method of task swapping is the first choice for embedded system design because of its better system response."
    },
    {
        "id": 632,
        "Question": "Which of the following allows a lower priority task to run despite the higher priority task is active and waiting to preempt?",
        "Options": [
            "a) message queue",
            "b) message passing",
            "c) semaphore",
            "d) priority inversion"
        ],
        "Answer": "Answer: d\nExplanation: The priority inversion mechanism where the lower priority task can continue to run despite there being a higher priority task active and waiting to preempt."
    },
    {
        "id": 633,
        "Question": "What happens to the interrupts in an interrupt service routine?",
        "Options": [
            "a) disable interrupt",
            "b) enable interrupts",
            "c) remains unchanged",
            "d) ready state"
        ],
        "Answer": "Answer: a\nExplanation: In the interrupt service routine, all the other interrupts are disabled till the routine completes which can cause a problem if another interrupt is received and held pending. This can result in priority inversion."
    },
    {
        "id": 634,
        "Question": "Which of the following is a part of RTOS kernel?",
        "Options": [
            "a) memory",
            "b) input",
            "c) ISR",
            "d) register"
        ],
        "Answer": "Answer: c\nExplanation: The ISR can send the message for the tasks and it is a part of RTOS kernel."
    },
    {
        "id": 635,
        "Question": "Which of the following is an industrial interconnection bus?",
        "Options": [
            "a) bus interface unit",
            "b) data bus",
            "c) address bus",
            "d) VMEbus"
        ],
        "Answer": "Answer: d\nExplanation: The VMEbus is an interconnection bus which is used in the industrial control and many other real-time applications."
    },
    {
        "id": 636,
        "Question": "Which of the following supports seven interrupt priority level?",
        "Options": [
            "a) kernel",
            "b) operating system",
            "c) VMEbus",
            "d) data bus"
        ],
        "Answer": "Answer: c\nExplanation: The VMEbus supports seven interrupt priority level which allows the prioritisation of the resources."
    },
    {
        "id": 637,
        "Question": "What type of interrupt handling is seen in multiprocessor applications?",
        "Options": [
            "a) centralised interrupt",
            "b) handled by one MASTER",
            "c) distributed handling",
            "d) shared handling"
        ],
        "Answer": "Answer: c\nExplanation: The multiprocessor applications allows distributed handling in which the direct communication with the individual masters is possible."
    },
    {
        "id": 638,
        "Question": "Which of the following is an asynchronous bus?",
        "Options": [
            "a) VMEbus",
            "b) timer",
            "c) data bus",
            "d) address bus"
        ],
        "Answer": "Answer: a\nExplanation: The VMEbus is based on Eurocard sizes and is asynchronous which is similar to the MC68000."
    },
    {
        "id": 639,
        "Question": "Which of the following is not a priority based?",
        "Options": [
            "a) priority inversion",
            "b) message passing",
            "c) fairness system",
            "d) message queuing"
        ],
        "Answer": "Answer: c\nExplanation: The fairness system allows the system which requires different characteristics from those originally provided and the system response that is not a priority based. The fairness system is not a priority based on where the bus access is distributed across the requesting processors."
    },
    {
        "id": 640,
        "Question": "Which of the following can be used to refer to entities within the RTOS?",
        "Options": [
            "a) threads",
            "b) kernels",
            "c) system",
            "d) applications"
        ],
        "Answer": "Answer: a\nExplanation: The threads and processes can be used to refer to entities within the RTOS. They provide an interchangeable replacement for the task. They have a slight difference in their function. A process is a program in execution and it has its own address space whereas threads have a shared address space. The task can be defined as a set of instructions which can be loaded into the memory."
    },
    {
        "id": 641,
        "Question": "Which of the following defines the set of instructions loaded into the memory?",
        "Options": [
            "a) process",
            "b) task",
            "c) thread",
            "d) system hardware"
        ],
        "Answer": "Answer: b\nExplanation: The task can be defined by the set of instructions which is loaded into the memory and it can split into two or more tasks."
    },
    {
        "id": 642,
        "Question": "Which of the following uses its own address space?",
        "Options": [
            "a) thread",
            "b) process",
            "c) task",
            "d) kernel"
        ],
        "Answer": "Answer: a\nExplanation: Threads uses shared memory space and it uses the memory space of the process."
    },
    {
        "id": 643,
        "Question": "Which of the following does not uses a shared memory?",
        "Options": [
            "a) process",
            "b) thread",
            "c) task",
            "d) kernel"
        ],
        "Answer": "Answer: a\nExplanation: The program in execution is known as the process. The process does not share the memory space but the threads have a shared memory address. When the CPU switches from process to another, the current information is stored in the process descriptor."
    },
    {
        "id": 644,
        "Question": "Which of the following can own and control the resources?",
        "Options": [
            "a) thread",
            "b) task",
            "c) system",
            "d) peripheral"
        ],
        "Answer": "Answer: b\nExplanation: The task and process have several characteristics and one such is that the task or process can own or control resources and it has threads of execution which are the paths through the code."
    },
    {
        "id": 645,
        "Question": "Which can be supported if the task or process maintains a separate data area for each thread?",
        "Options": [
            "a) single thread system",
            "b) mono thread system",
            "c) multiple threads",
            "d) dual threads"
        ],
        "Answer": "Answer: c\nExplanation: The multiple threads can be supported only if the process or task can maintain separate data areas for each thread."
    },
    {
        "id": 646,
        "Question": "Which of the following possesses threads of execution?",
        "Options": [
            "a) process",
            "b) thread",
            "c) kernel",
            "d) operating system"
        ],
        "Answer": "Answer: a\nExplanation: The process has threads of execution which are the paths through the code."
    },
    {
        "id": 647,
        "Question": "Which of the following is inherited from the parent task?",
        "Options": [
            "a) task",
            "b) process",
            "c) thread",
            "d) kernel"
        ],
        "Answer": "Answer: c\nExplanation: The threads are a part of the process, that is, it uses a shared memory of the process and therefore said that its resources are inherited from the parent process or task."
    },
    {
        "id": 648,
        "Question": "Which term is used to encompass more than a simple context switch?",
        "Options": [
            "a) process",
            "b) single thread system",
            "c) thread",
            "d) multithread"
        ],
        "Answer": "Answer: a\nExplanation: The process includes the additional information which is used to encompass more than a simple context switch. This is similar to the task switching, that is why it is said that process and task are interchangeable."
    },
    {
        "id": 649,
        "Question": "Which can be considered as the lower level in the multitasking operating system?",
        "Options": [
            "a) process",
            "b) task",
            "c) threads",
            "d) multi threads"
        ],
        "Answer": "Answer: c\nExplanation: In the multitasking operating system, the process and tasks form the higher level whereas the thread is the lower level. But in a simple operating system, there is no difference between the context switch of thread and the process."
    },
    {
        "id": 650,
        "Question": "Which of the following kernel supports the MC68000 family?",
        "Options": [
            "a) pSOS+",
            "b) pSOS+kernel",
            "c) pNA+ network manager",
            "d) pSOS multiprocessor kernel"
        ],
        "Answer": "Answer: a\nExplanation: The pSOS+ kernel supports many processor families like Intel 80×86, M88000, MC68000 and i960 processors. The kernel is small in size and has a 15-20 Kbytes RAM."
    },
    {
        "id": 651,
        "Question": "What is the worst case figure for interrupt latency for an MC68020 running at 25MHz?",
        "Options": [
            "a) 19 microseconds",
            "b) 6 microseconds",
            "c) 20 microseconds",
            "d) 8 microseconds"
        ],
        "Answer": "Answer: b\nExplanation: The worst case figure for the interrupt latency for an MC68020 which runs at 25MHz is 6 microseconds and the context switch for the same is 19 microseconds."
    },
    {
        "id": 652,
        "Question": "Which of the following is the multiprocessing version of the kernel?",
        "Options": [
            "a) pSOS+",
            "b) pSOS+ kernel",
            "c) pSOS multiprocessor kernel",
            "d) pSOS"
        ],
        "Answer": "Answer: c\nExplanation: The pSOS+ is a multitasking real-time kernel of the operating system and pSOS+m or the pSOS+ multiprocessor kernel is the multiprocessing version of the kernel. It is virtually same as the single processor version except the ability to send and receiving system objects from the processors within the system."
    },
    {
        "id": 653,
        "Question": "Which of the following is a compiler independent run-time environment for C applications?",
        "Options": [
            "a) pSOS multiprocessor kernel",
            "b) pSOS",
            "c) pSOS+",
            "d) pREC+ runtime support"
        ],
        "Answer": "Answer: d\nExplanation: The pREC+ is a compiler independent runtime environment for the C program applications."
    },
    {
        "id": 654,
        "Question": "Which kernel provides 88 functions that can be called from the C programs?",
        "Options": [
            "a) pSOS multiprocessor kernel",
            "b) pSOS",
            "c) pSOS+",
            "d) pREC+ runtime support"
        ],
        "Answer": "Answer: d\nExplanation:  The pREC+ is compatible with the ANSI X3J11 and can provide the 88 functions that can be called from the C programs."
    },
    {
        "id": 655,
        "Question": "Which of the following is not a standalone product?",
        "Options": [
            "a) pREC+ runtime support",
            "b) pSOS+m",
            "c) pSOS+",
            "d) pSOS+ kernel"
        ],
        "Answer": "Answer: a\nExplanation: The pREC+ is not a standalone product it uses pSOS+m or pSOS+ for the input/output devices and task functions and calls the PHILE+ for the file and disk I/O."
    },
    {
        "id": 656,
        "Question": "Which kernel allows the multiple tasks which use the same routine?",
        "Options": [
            "a) pREC+ runtime support",
            "b) pSOS+m",
            "c) pSOS+",
            "d) pSOS+ kernel"
        ],
        "Answer": "Answer: a\nExplanation: The pREC+ runtime support kernel’s routines are reentrant that allows the multiple tasks to use the same routine simultaneously."
    },
    {
        "id": 657,
        "Question": "Which provides the TCP/IP communication over the ethernet and FDDI?",
        "Options": [
            "a) pSOS+m",
            "b) pSOS+ kernel",
            "c) pNA+ network manager",
            "d) pSOS+"
        ],
        "Answer": "Answer: c\nExplanation: A pNA+ network manager is a networking option which can provide the TCP/IP communication over a large variety of media such as the FDDI and the ethernet."
    },
    {
        "id": 658,
        "Question": "Which can provide efficient downloading and debugging communication between the host and target system?",
        "Options": [
            "a) pSOS+",
            "b) pSOS+ kernel",
            "c) pHILE+ file system",
            "d) pNA+ network manager"
        ],
        "Answer": "Answer: d\nExplanation: The pNA+ network manager can provide efficient downloading and debugging communication between the host and target system."
    },
    {
        "id": 659,
        "Question": "Which of the following is a system level debugger which provides the low-level debugging facilities and the system debugging?",
        "Options": [
            "a) pROBE+ system level debugger",
            "b)  pNA+ network manager",
            "c) pHILE+ file system",
            "d) pNA+ network manager"
        ],
        "Answer": "Answer: a\nExplanation: The pROBE+ system level debugger which can provide the system debugging and the low level debugging. "
    },
    {
        "id": 660,
        "Question": "How is the pROBE+ system level debugger communicate with the outside world?",
        "Options": [
            "a) peripheral output",
            "b) serial port",
            "c) LCD display",
            "d) LED"
        ],
        "Answer": "Answer: b\nExplanation: The pROBE+ system level debugger can communicate with the outside world through the serial port  or by installing pNA+, a TCP/IP link can be used instead."
    },
    {
        "id": 661,
        "Question": "Which of the following is a complementary product to pROBE+ system level debugger?",
        "Options": [
            "a) pSOS+ kernel",
            "b) pSOS+",
            "c) XRAY+ source level debugger",
            "d) pSOS+m"
        ],
        "Answer": "Answer: c\nExplanation: The XRAY+ source level debugger is a complementary product to pROBE+ system level debugger as it can use the debugger information and combine with the C source and other functions on the host that can provide an integrated debugging."
    },
    {
        "id": 662,
        "Question": "Which of the following supports the MS-DOS file?",
        "Options": [
            "a) pNA+ network manager",
            "b) pSOS+ kernel",
            "c) pSOS+ m",
            "d) pHILE+ file system"
        ],
        "Answer": "Answer: d\nExplanation: The pHILE+ file system supports the MS-DOS file structure and the product can provide input and output file."
    },
    {
        "id": 663,
        "Question": "Who developed the OS-9?",
        "Options": [
            "a) Microwave",
            "b) Microwave and Motorola",
            "c) Motorola and IBM",
            "d) Microwave and IBM"
        ],
        "Answer": "Answer: b\nExplanation: The OS-9 is developed by Motorola and Microwave as a real-time operating system. The operating system is developed for MC6809 which is an 8-bit processor."
    },
    {
        "id": 664,
        "Question": "Who had developed VRTX-32?",
        "Options": [
            "a) Microtec Research",
            "b) Microwave",
            "c) Motorola",
            "d) IBM"
        ],
        "Answer": "Answer: a\nExplanation: The VRTX-32 is developed by Microtec Research which is a high-performance real-time kernel."
    },
    {
        "id": 665,
        "Question": "Which provides the library interface to allow C programs to call standard I/O functions?",
        "Options": [
            "a) RTL",
            "b) TNX",
            "c) IFX",
            "d) MPV"
        ],
        "Answer": "Answer: a\nExplanation: The RTL is run-time library support for Microtec and the Sun compilers and can provide the library interface to allow the C programs to call the standard I/O functions."
    },
    {
        "id": 666,
        "Question": " Which of the following unit protects the memory?",
        "Options": [
            "a) bus interface unit",
            "b) execution unit",
            "c) memory management unit",
            "d) peripheral unit"
        ],
        "Answer": "Answer: c\nExplanation: The resources have to be protected in an embedded system and the most important resource to be protected is the memory which is protected by the memory management unit through different programming."
    },
    {
        "id": 667,
        "Question": "Which unit protects the hardware?",
        "Options": [
            "a) MMU",
            "b) hardware unit",
            "c) bus interface unit",
            "d) execution unit"
        ],
        "Answer": "Answer: a\nExplanation: The hardware part is protected by the memory management unit. The memory part is also protected by the memory management unit. The hardware such as the input-output devices are protected and is prevented from the direct access."
    },
    {
        "id": 668,
        "Question": "Which mechanism can control the access?",
        "Options": [
            "a) in-situ",
            "b) spin-lock",
            "c) ex-situ",
            "d) both in-situ and ex-situ"
        ],
        "Answer": "Answer: b\nExplanation:  Both the memory and the hardware part are protected by the memory management unit and the hardware such as the input-output devices are protected, These are prevented from the direct access. These accesses are made through a device driver and this device driver can control the serial port. Such a mechanism is called spin-lock mechanism which provides the control access."
    },
    {
        "id": 669,
        "Question": "Which of the following is very resilient to the system crashes?",
        "Options": [
            "a) Windows 3.1",
            "b) MS-DOS",
            "c) Windows NT",
            "d) kernel"
        ],
        "Answer": "Answer: c\nExplanation: The Windows NT is very resilient to the system crashes and the system will continue while the processes can crash. This is because of the user mode and the kernel mode which is coupled with the resource protection. This resilience is a big advantage over the MS-DOS and Windows 3.1."
    },
    {
        "id": 670,
        "Question": "Which of the following are coupled in the Windows NT for the resource protection?",
        "Options": [
            "a) kernel mode and user mode",
            "b) user mode and protected mode",
            "c) protected mode and real mode",
            "d) virtual mode and kernel mode"
        ],
        "Answer": "Answer: a\nExplanation:  The user mode and the kernel mode are coupled with the resource protection and this resilience in Windows NT is a big advantage over the MS-DOS and the Windows 3.1."
    },
    {
        "id": 671,
        "Question": "Which of the following support multi-threaded software?",
        "Options": [
            "a) Windows NT",
            "b) thread",
            "c) process",
            "d) task"
        ],
        "Answer": "Answer: a\nExplanation: The Windows NT supports multi-threaded software in which the processes can support several independent paths or threads."
    },
    {
        "id": 672,
        "Question": "Which provides a 4 Gbyte virtual address space?",
        "Options": [
            "a) Windows 3.1",
            "b) MS-DOS",
            "c) pSOS+",
            "d) Windows NT"
        ],
        "Answer": "Answer: d\nExplanation: The virtual address spacing in the Windows NT is somewhat different from the MS-DOS and the Windows 3.1. The Windows NT provides 4 Gbytes virtual address space for each process and that is linearly addressed using 32-bit address values."
    },
    {
        "id": 673,
        "Question": "Which applications can be used with the Windows NT?",
        "Options": [
            "a) WIN16",
            "b) WIN32",
            "c) WIN4",
            "d) WIN24"
        ],
        "Answer": "Answer: b\nExplanation: The WIN32 is also known as 32-bit or even native. It is used for the Windows NT applications which uses the same instruction set as that of the Windows NT and therefore do not need to emulate a different architecture."
    },
    {
        "id": 674,
        "Question": " Which of the following has the same instruction set as that of the Windows NT?",
        "Options": [
            "a) WIN32",
            "b) WIN4",
            "c) WIN24",
            "d) WIN16"
        ],
        "Answer": "Answer: a\nExplanation: WIN32  is used for the Windows NT applications and is also known as even native which uses the same instruction set as that of the Windows NT and therefore do not need to emulate a different architecture."
    },
    {
        "id": 675,
        "Question": "Which can provide more memory than physical memory?",
        "Options": [
            "a) real memory",
            "b) physical address",
            "c) virtual memory",
            "d) segmented address"
        ],
        "Answer": "Answer: c\nExplanation: The physical memory can provide more memory than the physical memory within the system. Such memories are divided into segments and pages."
    },
    {
        "id": 676,
        "Question": "Which of the following uses a swap file to provide the virtual memory?",
        "Options": [
            "a) windows NT",
            "b) kernel",
            "c) memory",
            "d) memory management unit"
        ],
        "Answer": "Answer: a\nExplanation: The Windows NT use a swap file for providing a virtual memory environment. This file is dynamic and varies with the amount of memory that all the software including the device driver, operating systems and so on."
    },
    {
        "id": 677,
        "Question": "What is the size of the swap file in Windows 3.1?",
        "Options": [
            "a) 25 Mbytes",
            "b) 30 Mbytes",
            "c) 50 Mbytes",
            "d) 100 Mbytes"
        ],
        "Answer": "Answer: b\nExplanation: The Windows 3.1 have a swap file of size 25 Mbytes."
    },
    {
        "id": 678,
        "Question": "What is the nature of the swap file in the Windows NT?",
        "Options": [
            "a) static",
            "b) dynamic",
            "c) linear",
            "d) non-linear"
        ],
        "Answer": "Answer: b\nExplanation: The swap file used in the Windows NT is dynamic and it varies with the amount of memory that all the software including the device driver, operating systems and so on."
    },
    {
        "id": 679,
        "Question": "What limits the amount of virtual memory in Windows 3.1?",
        "Options": [
            "a) size of the swap file",
            "b) nature of swap file",
            "c) static file",
            "d) dynamic file"
        ],
        "Answer": "Answer: a\nExplanation: The swap file of Windows 3.1 have a size of 25 Mbytes and thus limits the amount of virtual memory that it can support."
    },
    {
        "id": 680,
        "Question": "Which of the following control and supervises the memory requirements of an operating system?",
        "Options": [
            "a) processor",
            "b) physical memory manager",
            "c) virtual memory manager",
            "d) ram"
        ],
        "Answer": "Answer: c\nExplanation: The virtual memory manager can control and supervises the memory requirements of the operating system."
    },
    {
        "id": 681,
        "Question": "What is the size of the linear address in the virtual memory manager?",
        "Options": [
            "a) 2 Gbytes",
            "b) 12 Gbytes",
            "c) 4 Gbytes",
            "d) 16 Gbytes"
        ],
        "Answer": "Answer: c\nExplanation: The virtual memory manager can allocate a linear address space of size 4 Gbytes to each process which is unique and cannot be accessed by the other processes."
    },
    {
        "id": 682,
        "Question": "How many modes are used to isolate the kernel and the other components of the operating system?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: There are two modes that are used for isolating the kernel and the other components of the operating system from any process and user applications that are running. These are kernel mode and the user mode."
    },
    {
        "id": 683,
        "Question": "Which are the two modes used in the isolation of the kernel and the user?",
        "Options": [
            "a) real mode and virtual mode",
            "b) real mode and user mode",
            "c) user mode and kernel mode",
            "d) kernel mode and real mode"
        ],
        "Answer": "Answer: c\nExplanation: The two modes are kernel mode and the user mode which are used for isolating the kernel and the other components of the operating system from any process and user applications that are running."
    },
    {
        "id": 684,
        "Question": "Which of the following must be used to isolate the access in the user mode?",
        "Options": [
            "a) device driver",
            "b) software driver",
            "c) on-chip memory",
            "d) peripherals"
        ],
        "Answer": "Answer: a\nExplanation: The device driver is used to control and isolate the access when it is in user mode. This is used to ensure that no conflict is caused."
    },
    {
        "id": 685,
        "Question": "Which mode uses 16 higher real-time class priority levels?",
        "Options": [
            "a) real mode",
            "b) user mode",
            "c) kernel mode",
            "d) protected mode"
        ],
        "Answer": "Answer: c\nExplanation: The kernel mode processes use the 16 higher real-time class priority levels and the operating system processes will take the preference over the user applications."
    },
    {
        "id": 686,
        "Question": "Which filesystem is used in the Windows 95?",
        "Options": [
            "a) FAT",
            "b) HPFS",
            "c) VFAT",
            "d) NTFS"
        ],
        "Answer": "Answer: c\nExplanation: The VFAT is used in the Windows 95 and it also supports long file names."
    },
    {
        "id": 687,
        "Question": "What does HPFS stand for?",
        "Options": [
            "a) high performance file system",
            "b) high periodic file system",
            "c) high peripheral file system",
            "d) horse power file system"
        ],
        "Answer": "Answer: a\nExplanation: The high performance file system is an alternative file system which possess 254 characters. It is used by the OS/2 and also writes caching to disk technique that stores data temporarily and write it to the disk."
    },
    {
        "id": 688,
        "Question": "Which filing system is used by the Windows NT?",
        "Options": [
            "a) FAT",
            "b) VFAT",
            "c) HPFS",
            "d) NTFS"
        ],
        "Answer": "Answer: d\nExplanation: The NT filing system or NTFS is used by the Windows NT, that is its own filing system which conforms to various security operations and allows system administrators to restrict access to files."
    },
    {
        "id": 689,
        "Question": "Which filesystem is used by the OS/2?",
        "Options": [
            "a) FAT",
            "b) VFAT",
            "c) HPFS",
            "d) NTFS"
        ],
        "Answer": "Answer: c\nExplanation: The high performance file system is an alternative file system which possess 254 characters. It is used by the OS/2 and also writes caching to disk technique that stores data temporarily and write it to the disk."
    },
    {
        "id": 690,
        "Question": "What do HAL stand for?",
        "Options": [
            "a) hardware abstraction layer",
            "b) hardware address layer",
            "c) hardware access layer",
            "d) hardware address lead"
        ],
        "Answer": "Answer: a\nExplanation: The HAL is the hardware abstraction layer. This provides the portability across the multiprocessor and different platforms."
    },
    {
        "id": 691,
        "Question": "Which of the following can provide portability across different processor-based platforms?",
        "Options": [
            "a) File system",
            "b) HAL",
            "c) NTFS",
            "d) FAT"
        ],
        "Answer": "Answer: b\nExplanation: The HAL or hardware abstraction layer is designed to provide portability across the different platform and different multiprocessor or single processor."
    },
    {
        "id": 692,
        "Question": "Which of the following defines the virtual hardware that the kernel uses?",
        "Options": [
            "a) HAL",
            "b) NTFS",
            "c) FAT",
            "d) VFAT"
        ],
        "Answer": "Answer: a\nExplanation: The HAL or hardware abstraction layer defines virtual hardware which the kernel uses when it needs to access the processor or hardware resources."
    },
    {
        "id": 693,
        "Question": "Which of the following provides a link between the user processes and threads and the hardware?",
        "Options": [
            "a) I/O driver",
            "b) File system",
            "c) Memory",
            "d) LPC"
        ],
        "Answer": "Answer: a\nExplanation: The I/O driver is also a part of the kernel. These can provide a link between the threads and the processes and the hardware. The Windows NT driver is not compatible with the MS-DOS and Windows 3.1 drivers."
    },
    {
        "id": 694,
        "Question": "What does LPC stand for?",
        "Options": [
            "a) local procedure call",
            "b) local program call",
            "c) local program code",
            "d) local procedure code"
        ],
        "Answer": "Answer: a\nExplanation: The LPC is defined as the local procedure call which is responsible for coordinating the system calls from the WIN32 subsystem and an application."
    },
    {
        "id": 695,
        "Question": "Which of the following is responsible for coordinating the system call within an application and the WIN32 subsystem?",
        "Options": [
            "a) kernel",
            "b) file system",
            "c) LPC",
            "d) network support"
        ],
        "Answer": "Answer: c\nExplanation: The local procedure call is responsible for coordinating the system calls from the WIN32 subsystem and an application. Depending upon the type of the system call, the application will be routed directly with the LPC without going through the WIN32 subsystem."
    },
    {
        "id": 696,
        "Question": "Which of the following is responsible for ensuring correct operation of all processes which are running within the system?",
        "Options": [
            "a) kernel",
            "b) file system",
            "c) lpc",
            "d) user mode"
        ],
        "Answer": "Answer: a\nExplanation: The kernel is responsible for ensuring the correct operation of all process which are running within the system. It also provides the synchronisation and the scheduling that the system needs."
    },
    {
        "id": 697,
        "Question": "How many level priority scheme does the scheduling used in the kernel?",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 32",
            "d) 64"
        ],
        "Answer": "Answer: c\nExplanation: The scheduling support in the kernel support 32 level priority scheme and it can be used to schedule threads rather than processes."
    },
    {
        "id": 698,
        "Question": "Which procedure in the kernel allows the thread to wait until a specific resource is available?",
        "Options": [
            "a) synchronisation",
            "b) scheduling",
            "c) scheduling and synchronisation",
            "d) lpc"
        ],
        "Answer": "Answer: a\nExplanation: The synchronisation procedure will allow the thread to wait until a specific resource such as semaphore, object etc are available."
    },
    {
        "id": 699,
        "Question": "Which of the following can preempt the current thread and reschedule the high priority thread in the kernel?",
        "Options": [
            "a) interrupt",
            "b) lpc",
            "c) file system",
            "d) memory"
        ],
        "Answer": "Answer: a\nExplanation: The interrupts and the similar events such as exceptions can pass through the kernel which can preempt the current thread and the can reschedule the high priority thread to process."
    },
    {
        "id": 700,
        "Question": "How many file system does the Windows NT support?",
        "Options": [
            "a) 4",
            "b) 5",
            "c) 3",
            "d) 2"
        ],
        "Answer": "Answer: c\nExplanation: The Windows NT support three file system and these coexist with each other even though there are some restrictions."
    },
    {
        "id": 701,
        "Question": "What does FAT stand for?",
        "Options": [
            "a) file address table",
            "b) file access table",
            "c) file arbitrary table",
            "d) file allocation table"
        ],
        "Answer": "Answer: d\nExplanation: The FAT or file allocation table is a kind of file system which is used by the Windows 3.1 and the MS-DOS."
    },
    {
        "id": 702,
        "Question": "Who started Linux first as a personal project?",
        "Options": [
            "a) Linus Torvalds",
            "b) Ken Thompson",
            "c) Dennis Ritchie",
            "d) John Dell"
        ],
        "Answer": "Answer: a\nExplanation: The Linux was taken as a personal project by Linus Torvalds at the University of Helsinki in Finland that is similar to UNIX as an operating system."
    },
    {
        "id": 703,
        "Question": "Which of the following is similar to UNIX OS?",
        "Options": [
            "a) Windows NT",
            "b) MS-DOS",
            "c) Linux",
            "d) Windows 3.1"
        ],
        "Answer": "Answer: c\nExplanation: The Linux is similar to UNIX operating system but it is entirely different for the Windows NT, MS-DOS and the Windows 3.1"
    },
    {
        "id": 704,
        "Question": "Who had first described UNIX in an article?",
        "Options": [
            "a) Ken Thompson",
            "b) Dennis Ritchie and Ken Thompson",
            "c) Dennis Ritchie",
            "d) Linus Torvalds"
        ],
        "Answer": "Answer: b\nExplanation: The UNIX was first described by Dennis Ritchie and Ken Thompson of Bell Research Labs in 1974 through an article."
    },
    {
        "id": 705,
        "Question": "What does MULTICS stand for?",
        "Options": [
            "a) multiplexed information and computing service",
            "b) multiplexed information and code service",
            "c) multiplexed inter-access code service",
            "d) multiplexed inter-code sensor"
        ],
        "Answer": "Answer: a\nExplanation: MULTICS is a multiplexed information and computing service which generate software that would allow a large number of users for accessing the computer simultaneously."
    },
    {
        "id": 706,
        "Question": "Which of the following is the first version of the UNIX operating system?",
        "Options": [
            "a) PDP-2",
            "b) Linux",
            "c) MS-DOS",
            "d) PDP-7"
        ],
        "Answer": "Answer: d\nExplanation: The PDP-7 processor is the first version of the UNIX which has a new filing system and new utilities."
    },
    {
        "id": 707,
        "Question": "Which of the following is a UNIX clone?",
        "Options": [
            "a) XENIX",
            "b) Windows 3.1",
            "c) Windows NT",
            "d) Linux"
        ],
        "Answer": "Answer: a\nExplanation: The XENIX is a UNIX clone developed by the Motorola in the year 2979 and is ported to many processors."
    },
    {
        "id": 708,
        "Question": "Which of the following is an alternate source of UNIX?",
        "Options": [
            "a) MS-DOS",
            "b) Windows 3.1",
            "c) Windows NT",
            "d) Linux"
        ],
        "Answer": "Answer: a\nExplanation: With the many disadvantages of the UNIX operating system, Linux was used as an alternative source. The UNIX operating system was more expensive operating system and most of the hardware was specific to the manufacturer, which restricted the use of UNIX and developed for an alternative one, the Linux."
    },
    {
        "id": 709,
        "Question": "Which of the following are grouped into directories and subdirectories?",
        "Options": [
            "a) register",
            "b) memory",
            "c) files",
            "d) routines"
        ],
        "Answer": "Answer: c\nExplanation: The files are grouped into directories and subdirectories. This file system contains all the data files, commands, programs and special files which allow the access to the physical computer system. The file system of the Linux operating system is similar to the UNIX operating system."
    },
    {
        "id": 710,
        "Question": "Which character is known as a root directory?",
        "Options": [
            "a) ^",
            "b) &",
            "c) &&",
            "d) /"
        ],
        "Answer": "Answer: d\nExplanation: The character / is used at the beginning of the file name or the path name which is used as the starting point and is known as the root directory or root."
    },
    {
        "id": 711,
        "Question": "How many types of Linux files are typically used?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: c\nExplanation: There are four types of Linux files. These are regular, special, directories and named pipes."
    },
    {
        "id": 712,
        "Question": "Which filesystem of Linux has mass storage devices?",
        "Options": [
            "a) physical file system",
            "b) temporary file system",
            "c) ram",
            "d) register"
        ],
        "Answer": "Answer: a\nExplanation: The physical file system has mass storage devices such as hard disks and floppy which are allocated to parts of the logical file system."
    },
    {
        "id": 713,
        "Question": "Which file type of Linux has no restriction on size and can have any kind of data?",
        "Options": [
            "a) special",
            "b) regular",
            "c) directories",
            "d) named pipes"
        ],
        "Answer": "Answer: b\nExplanation: There are four types of Linux files. These are regular, special, directories and named pipes in which the regular file type can have any kind of data and does not have restrictions in size, the special file type represent certain terminals such as physical I/O device, the directories can hold lists of files, and the named pipes are similar to regular files but restricted in size."
    },
    {
        "id": 714,
        "Question": "Which file type of Linux is similar to the regular file type?",
        "Options": [
            "a) named pipe",
            "b) directories",
            "c) regular file",
            "d) special file"
        ],
        "Answer": "Answer: a\nExplanation: Among the Linux files, the regular file type is similar to the named pipe but these are restricted in size. On the other hand, the regular file does not have restrictions."
    },
    {
        "id": 715,
        "Question": "Which file type of the Linux hold lists of files rather than the actual data?",
        "Options": [
            "a) regular",
            "b) special",
            "c) directories",
            "d) named pipes"
        ],
        "Answer": "Answer: c\nExplanation: The directories can hold lists of files other than the actual data, but the other file type does not have this characteristic."
    },
    {
        "id": 716,
        "Question": "Which filesystem of the Linux can be implemented on a system with two hard disks?",
        "Options": [
            "a) logical file system",
            "b) physical file system",
            "c) special file type system",
            "d) regular file type system"
        ],
        "Answer": "Answer: a\nExplanation: The physical file system is allocated to the parts of the logical file system. The logical file system can be implemented on a system with two hard disks by the allocation of the bin directory under the hard disk 1 and the file subsystem under the hard disk 2."
    },
    {
        "id": 717,
        "Question": "Which directory is allocated on the hard disk 1 of the physical storage in a Linux operating system?",
        "Options": [
            "a) term",
            "b) dev",
            "c) etc",
            "d) bin"
        ],
        "Answer": "Answer: d\nExplanation: The bin directory is on the hard disk 1 of the physical storage whereas the term, dev, etc is on the hard disk 1 of the physical logical file system."
    },
    {
        "id": 718,
        "Question": "Which process defines the allocation of the mass storage to the logical file system?",
        "Options": [
            "a) mounting",
            "b) de-allocation",
            "c) demounting",
            "d) unmounting"
        ],
        "Answer": "Answer: a\nExplanation: The allocation of the mass storage to the logical file system is known as the mounting and its reverse operation, deallocation of the mass storage is known as unmounting."
    },
    {
        "id": 719,
        "Question": "Which commands can be used to access the removable media?",
        "Options": [
            "a) system calls",
            "b) loop instruction",
            "c) mount and unmount command",
            "d) procedure commands"
        ],
        "Answer": "Answer: c\nExplanation: The commands such as mount and unmount commands are used to access the removable media like the floppy disks, through the logical file system."
    },
    {
        "id": 720,
        "Question": "Which target directory is used in the file system of the Linux operating system?",
        "Options": [
            "a) /mnt",
            "b) /etc",
            "c) /term",
            "d) /bin"
        ],
        "Answer": "Answer: a\nExplanation: The /mnt is the target directory used in the file system of the Linux operating system but the special file names can vary from system to system."
    },
    {
        "id": 721,
        "Question": "Identify the standard software components that can be reused?",
        "Options": [
            "a) application manager",
            "b) operating system",
            "c) application software",
            "d) memory"
        ],
        "Answer": "Answer: b\nExplanation: There are certain software components that can be reused in an embedded system design. These are the operating systems, real-time databases and some other forms of middleware."
    },
    {
        "id": 722,
        "Question": "What does WCTE stand for?",
        "Options": [
            "a) wait case execution time",
            "b) wait case encoder time",
            "c) worst case execution time",
            "d) worst code execution time"
        ],
        "Answer": "Answer: c\nExplanation: The WCTE is the worst case execution time which is an upper bound on the execution times of task. It can be computed for certain programs like while loops, programs without recursion, iteration count etc."
    },
    {
        "id": 723,
        "Question": "For which of the following WCET can be computed?",
        "Options": [
            "a) C program",
            "b) assembly language",
            "c) VHDL",
            "d) program without recursion"
        ],
        "Answer": "Answer: d\nExplanation: The WCET computing is a difficult task for assembly language and for computing WCTE for any high-level language without the knowledge of the generated assembly code is impossible."
    },
    {
        "id": 724,
        "Question": "The WCET of which component can be computed if the task is mapped to hardware?",
        "Options": [
            "a) hardware",
            "b) task",
            "c) both task and hardware",
            "d) application manager"
        ],
        "Answer": "Answer: a\nExplanation: The worst case execution time of the hardware can be computed if the task is mapped to the hardware which in turn requires the synthesis of the hardware."
    },
    {
        "id": 725,
        "Question": "Which estimation approach is used by Jha and Dutt for hardware?",
        "Options": [
            "a) accurate cost and performance value",
            "b) estimated cost and performance value",
            "c) performance value",
            "d) accurate cost"
        ],
        "Answer": "Answer: b\nExplanation: There are different estimation techniques used. One such is the estimated cost and performance value which is proposed by Jha and Dutt for hardware. The accurate cost and performance value is proposed by Jain et al for software."
    },
    {
        "id": 726,
        "Question": "Which estimate approach is more precise?",
        "Options": [
            "a) estimated cost and performance value",
            "b) accurate cost and performance value",
            "c) performance value and execution time",
            "d) estimated cost"
        ],
        "Answer": "Answer: b\nExplanation: The accurate cost and performance value is possible if interfaces to software synthesis tools and hardware synthesis tools exist and is more precise than any other methods."
    },
    {
        "id": 727,
        "Question": "Which estimate approach takes more time to consume?",
        "Options": [
            "a) accurate value",
            "b) estimated value",
            "c) accurate cost and performance value",
            "d) estimated cost and performance value"
        ],
        "Answer": "Answer: c\nExplanation: The accurate cost and the performance value method is time-consuming but the other estimating approaches are less time consuming."
    },
    {
        "id": 728,
        "Question": "Which estimation technique can be used if interfaces to software synthesis tools and hardware synthesis tools exist?",
        "Options": [
            "a) performance value",
            "b) estimated cost",
            "c) estimated cost and performance value",
            "d) accurate cost and performance value"
        ],
        "Answer": "Answer: d\nExplanation: The accurate cost and performance value is possible if interfaces to software synthesis tools and hardware synthesis tools exist."
    },
    {
        "id": 729,
        "Question": "Which of the following is the base for scheduling algorithm?",
        "Options": [
            "a) WCET",
            "b) time",
            "c) execution time",
            "d) address accessing time"
        ],
        "Answer": "Answer: a\nExplanation: The base for scheduling algorithm is the WCET, worst case execution time which is a bound on the execution time of tasks. Such computing is undecidable in the general case, so it is decidable for certain programs only such as programs without recursion, iteration count, while loops etc."
    },
    {
        "id": 730,
        "Question": "Which classification is based on the extension to standard operating systems?",
        "Options": [
            "a) software and hardware deadline",
            "b) aperiodic deadline",
            "c) periodic deadline",
            "d) static and dynamic deadline"
        ],
        "Answer": "Answer: a\nExplanation: The real-time scheduling can be classified into various criteria. The fundamental classification is the software and hardware deadline which is based on the extension to standard operating systems."
    },
    {
        "id": 731,
        "Question": "Which of the following defines the task which must be executed at every defined unit of time?",
        "Options": [
            "a) aperiodic task",
            "b) periodic task",
            "c) job",
            "d) process"
        ],
        "Answer": "Answer: b\nExplanation: The periodic task is the one which must be executed in a defined unit of time say ‘p’ where p is called the period."
    },
    {
        "id": 732,
        "Question": "Which of the task are not periodic?",
        "Options": [
            "a) periodic task",
            "b) unpredictable task",
            "c) aperiodic task",
            "d) job"
        ],
        "Answer": "Answer: c\nExplanation: The aperiodic task is the one in which the task is not periodic but the periodic task is the one in which are the task are periodic. Each execution of a periodic task is known as the job."
    },
    {
        "id": 733,
        "Question": "Which of the following is an aperiodic task requesting the processor at unpredictable times?",
        "Options": [
            "a) job",
            "b) aperiodic task",
            "c) sporadic",
            "d) periodic task"
        ],
        "Answer": "Answer: c\nExplanation: The aperiodic tasks request the processor at unpredictable times if and only if there is a minimum separation between the times at which they request the processor which is called sporadic."
    },
    {
        "id": 734,
        "Question": "Which of the scheduling algorithm are based on the assumption that tasks are executed until they are done?",
        "Options": [
            "a) periodic task",
            "b) aperiodic task",
            "c) non-preemptive scheduling",
            "d) preemptive scheduling"
        ],
        "Answer": "Answer: c\nExplanation: The nonpreemptive scheduling is based on the assumptions that the tasks are executed until the task is done whereas the preemptive scheduling is used if the task has long execution times or for a short response time."
    },
    {
        "id": 735,
        "Question": "Which of the following schedulers take decisions at run-time?",
        "Options": [
            "a) preemptive scheduler",
            "b) non preemptive scheduler",
            "c) dynamic scheduler",
            "d) static scheduler"
        ],
        "Answer": "Answer: c\nExplanation: The dynamic schedulers take decisions at run-time and they are quite flexible but generate overhead at run-time whereas static scheduler is the ones in which the scheduler take their designs at the design time."
    },
    {
        "id": 736,
        "Question": "Which scheduler takes their designs at design time?",
        "Options": [
            "a) preemptive scheduler",
            "b) non preemptive scheduler",
            "c) dynamic scheduler",
            "d) static scheduler"
        ],
        "Answer": "Answer: d\nExplanation: The static scheduler take their designs at the design time and it also generates tables of start times which are forwarded to a simple dispatcher but the dynamic scheduler takes a decision at the run-time."
    },
    {
        "id": 737,
        "Question": "Which scheduler generates tables and forward to the dispatcher?",
        "Options": [
            "a) static scheduler",
            "b) dynamic scheduler",
            "c) aperiodic scheduler",
            "d) preemptive scheduler"
        ],
        "Answer": "Answer: a\nExplanation: The static scheduler generates tables of start times which are forwarded to a simple dispatcher and it can be controlled by a timer which makes the dispatcher analyze the table."
    },
    {
        "id": 738,
        "Question": "Which of the following systems are entirely controlled by the timer?",
        "Options": [
            "a) voltage triggered",
            "b) time triggered",
            "c) aperiodic task scheduler",
            "d) periodic task scheduler"
        ],
        "Answer": "Answer: b\nExplanation: The systems which are entirely controlled by a timer are known as entirely time-triggered systems. A temporal control structure is associated with the entirely time-triggered system which is encoded in a TDL, task descriptor list."
    },
    {
        "id": 739,
        "Question": "What does TDL stand for?",
        "Options": [
            "a) task descriptor list",
            "b) task design list",
            "c) temporal descriptor list",
            "d) temporal design list"
        ],
        "Answer": "Answer: a\nExplanation: TDL is a task descriptor list which contains the cyclic schedule for all activities of the node and the temporal control structure is encoded by the task descriptor table."
    },
    {
        "id": 740,
        "Question": "Which scheduling algorithm can be used in mixed software/hardware systems?",
        "Options": [
            "a) simple algorithm",
            "b) complex algorithm",
            "c) uniprocessor algorithm",
            "d) multiprocessor algorithm"
        ],
        "Answer": "Answer: b\nExplanation: The complex algorithm is used in mixed software/hardware systems. It can be used to handle multiple processors."
    },
    {
        "id": 741,
        "Question": "Which algorithm can distinguish homogeneous multiprocessor system and heterogeneous multiprocessor system?",
        "Options": [
            "a) complex algorithm",
            "b) simple algorithm",
            "c) scheduler algorithm",
            "d) preemptive algorithm"
        ],
        "Answer": "Answer: a\nExplanation: The simple algorithm can be used in handling single processors and the complex algorithm is used in mixed both in software and the hardware systems. It can also be used to distinguish homogeneous multiprocessor system and heterogeneous multiprocessor systems. The complex algorithm can be used to handle multiple processors whereas."
    },
    {
        "id": 742,
        "Question": "Which of the following scheduling test can be used to show that no scheduling exist?",
        "Options": [
            "a) sufficient test",
            "b) necessary test",
            "c) complex test",
            "d) simple test"
        ],
        "Answer": "Answer: b\nExplanation: The necessary and sufficient conditions are used in the schedulability test. For necessary condition, the test is based only on the necessary conditions and it also can be used to show that no schedule exists. The sufficient condition indicates that no schedule exists even if there exists one."
    },
    {
        "id": 743,
        "Question": "Which scheduling test is used to indicate that no scheduling exist even if there exist one?",
        "Options": [
            "a) complex test",
            "b) simple test",
            "c) sufficient test",
            "d) necessary test"
        ],
        "Answer": "Answer: c\nExplanation: The sufficient condition indicates that no schedule exists even if there exist one and the necessary condition indicates that no schedule exists even if a schedule exists."
    },
    {
        "id": 744,
        "Question": "Which algorithm can be used to schedule tasks at run-time?",
        "Options": [
            "a) online scheduler",
            "b) offline scheduler",
            "c) multiprocessor scheduler",
            "d) uniprocessor scheduler"
        ],
        "Answer": "Answer: a\nExplanation: The online scheduling algorithm schedule tasks at run-time which is based on the information regarding the task whereas offline algorithms schedule tasks take a priori knowledge about the execution times, arrival times and deadlines into account."
    },
    {
        "id": 745,
        "Question": " Which algorithm is based on Jackson’s rule?",
        "Options": [
            "a) EDD",
            "b) LL",
            "c) EDF",
            "d) LST"
        ],
        "Answer": "Answer: a\nExplanation: The EDD or earliest due date is based on Jackson’s rule. The Jackson’s rule states that for a given a set of n independent tasks, any algorithm that executes the tasks in the order of nondecreasing deadlines is optimal with respect to reducing the maximum lateness. EDF is the earliest deadline first, LL is the least laxity and the LST is the least slack time first."
    },
    {
        "id": 746,
        "Question": "What does EDD stand for?",
        "Options": [
            "a) earliest device date",
            "b) earliest due date",
            "c) earliest device deadline",
            "d) earliest deadline device"
        ],
        "Answer": "Answer: b\nExplanation: The earliest due date requires all tasks to be sorted by their deadlines and it is based on Jackson’s rule. If the deadlines are known, EDD algorithm can be used."
    },
    {
        "id": 747,
        "Question": "Which of the following can be implemented as static scheduling algorithm?",
        "Options": [
            "a) EDF",
            "b) LL",
            "c) EDD",
            "d) LST"
        ],
        "Answer": "Answer: c\nExplanation: The EDD can be implemented as static scheduling algorithm if the deadlines are known in advance and it follows Jackson’s rule."
    },
    {
        "id": 748,
        "Question": "What does EDF stand for?",
        "Options": [
            "a) earliest deadline fix",
            "b) earliest due fix",
            "c) earliest due first",
            "d) earliest deadline first"
        ],
        "Answer": "Answer: d\nExplanation: The EDF stands for earliest deadline first. This algorithm is optimal with respect to minimizing the maximum lateness and is implemented as dynamic scheduling algorithm for a set of n independent tasks with arbitrary arrival times, any algorithm that at any instant executes the task with the earliest absolute deadline among all the ready tasks is optimal with respect to minimizing the maximum lateness."
    },
    {
        "id": 749,
        "Question": "Which algorithm is dynamic scheduling algorithm?",
        "Options": [
            "a) LL",
            "b) LST",
            "c) EDF",
            "d) EDD"
        ],
        "Answer": "Answer: c\nExplanation: The EDF or earliest deadline first can be implemented as a dynamic scheduling algorithm."
    },
    {
        "id": 750,
        "Question": "In which scheduling, the task priorities are a monotonically decreasing function of laxity?",
        "Options": [
            "a) LL",
            "b) EDD",
            "c) EFD",
            "d) LST"
        ],
        "Answer": "Answer: a\nExplanation: In the least laxity algorithm, the laxity can be changed dynamically which shows that the task priorities are a monotonically decreasing function of laxity."
    },
    {
        "id": 751,
        "Question": "Which scheduling algorithm is an optimal scheduling policy for mono-processor system?",
        "Options": [
            "a) preemptive algorithm",
            "b) LST",
            "c) EDD",
            "d) LL"
        ],
        "Answer": "Answer: d\nExplanation: The least laxity algorithm is a dynamic scheduling algorithm and hence it can be implemented as an optimal scheduling policy for the mono-processor system. The LL scheduling algorithm is also preemptive scheduling."
    },
    {
        "id": 752,
        "Question": "Which scheduling algorithm cannot be used with a standard OS providing fixed priorities?",
        "Options": [
            "a) LL",
            "b) LST",
            "c) EDD",
            "d) EFD"
        ],
        "Answer": "Answer: a\nExplanation: The least laxity algorithm cannot be used with a standard OS providing fixed priorities because of its dynamic property."
    },
    {
        "id": 753,
        "Question": "Who proposed the LDF algorithm?",
        "Options": [
            "a) Bayes",
            "b) Nyquist",
            "c) Lawler",
            "d) Stankovic"
        ],
        "Answer": "Answer: c\nExplanation: The latest deadline first or LDF is proposed by Lawler which performs a topological sort. It is based on the total order compatible with the partial order with respect to the task graph."
    },
    {
        "id": 754,
        "Question": "What does LDF stand for?",
        "Options": [
            "a) last deadline first",
            "b) least deadline first",
            "c) list deadline first",
            "d) latest deadline first"
        ],
        "Answer": "Answer: d\nExplanation: The LDF or latest deadline first is a scheduling algorithm which is proposed by Lawler."
    },
    {
        "id": 755,
        "Question": "Which algorithm is non-preemptive and can be used with a mono processor?",
        "Options": [
            "a) LDF",
            "b) pre-emptive",
            "c) aperiodic",
            "d) LL"
        ],
        "Answer": "Answer: a\nExplanation: The latest deadline first or LDF is a non-preemptive scheduling algorithm and can be used with a mono processor whereas LL or least laxity is a preemptive scheduling algorithm."
    },
    {
        "id": 756,
        "Question": "Which algorithm requires the periodic checks of the laxity?",
        "Options": [
            "a) LST",
            "b) LL",
            "c) EDD",
            "d) EFD"
        ],
        "Answer": "Answer: b\nExplanation: The LL scheduling algorithm requires the knowledge of the execution times and the periodic check of the laxity."
    },
    {
        "id": 757,
        "Question": "Who developed the heuristic algorithm?",
        "Options": [
            "a) Stankovic and Ramamritham",
            "b) Stankovic and Lawler",
            "c) Lawler",
            "d) Stankovic"
        ],
        "Answer": "Answer: a\nExplanation: The heuristic algorithm is developed by Stankovic and Ramamritham in 1991."
    },
    {
        "id": 758,
        "Question": "Which algorithm can be used if the preemptive is not allowed?",
        "Options": [
            "a) heuristic algorithm",
            "b) LL",
            "c) EDD",
            "d) LST"
        ],
        "Answer": "Answer: a\nExplanation: The heuristic algorithm was proposed by Stankovic and Ramamritham in 1991 can be used if the preemption is not allowed."
    },
    {
        "id": 759,
        "Question": "Deadline interval – execution time =",
        "Options": [
            "a) laxity",
            "b) execution time",
            "c) deadline interval",
            "d) period"
        ],
        "Answer": "Answer: a\nExplanation: The laxity is defined as the deadline interval minus the execution time. It is also known as the slack."
    },
    {
        "id": 760,
        "Question": "The execution of the task is known as",
        "Options": [
            "a) process",
            "b) job",
            "c) task",
            "d) thread"
        ],
        "Answer": "Answer: b\nExplanation: The execution of the task is known as the job. The time for both the execution of the task and the corresponding job is same."
    },
    {
        "id": 761,
        "Question": "Which scheduling algorithm is can be used for an independent periodic process?",
        "Options": [
            "a) EDD",
            "b) LL",
            "c) LST",
            "d) RMS"
        ],
        "Answer": "Answer: d\nExplanation: The RMS os rate monotonic scheduling is periodic scheduling algorithm but EDD, LL, and LST are aperiodic scheduling algorithm."
    },
    {
        "id": 762,
        "Question": "What is the relationship between the priority of task and their period in RMS?",
        "Options": [
            "a) decreases",
            "b) increases",
            "c) remains unchanged",
            "d) linear"
        ],
        "Answer": "Answer: a\nExplanation: The priority of the task decreases monotonically with respect to their period in the rate monotonic scheduling, that is, the task with the long period will get a low priority but task with the short period will get a high priority."
    },
    {
        "id": 763,
        "Question": "Which of the following uses a preemptive periodic scheduling algorithm?",
        "Options": [
            "a) Pre-emptive scheduling",
            "b) RMS",
            "c) LL",
            "d) LST"
        ],
        "Answer": "Answer: b\nExplanation: The rate monotonic scheduling is a periodic scheduler algorithm which follows a preemptive algorithm. LL is also preemptive scheduling but it is aperiodic scheduling algorithm."
    },
    {
        "id": 764,
        "Question": "Which of the following is based on static priorities?",
        "Options": [
            "a) Periodic EDF",
            "b) RMS",
            "c) LL",
            "d) Aperiodic EDF"
        ],
        "Answer": "Answer: b\nExplanation: The rate monotonic scheduling is a periodic scheduler algorithm which follows a preemptive algorithm and have static priorities. EDF and LL have dynamic priorities."
    },
    {
        "id": 765,
        "Question": "How many assumptions have to meet for a rate monotonic scheduling?",
        "Options": [
            "a) 3",
            "b) 4",
            "c) 5",
            "d) 6"
        ],
        "Answer": "Answer: d\nExplanation: The rate monotonic scheduling has to meet six assumptions. These are: All the tasks should be periodic,  all the tasks must be independent, the deadline should be equal to the period for all tasks, the execution time must be constant, the time required for the context switching must be negligible, it should hold the accumulation utilization equation."
    },
    {
        "id": 766,
        "Question": "Which of the following can be applied to periodic scheduling?",
        "Options": [
            "a) EDF",
            "b) LL",
            "c) LST",
            "d) EDD"
        ],
        "Answer": "Answer: a\nExplanation: The earliest deadline first can be applied both to the periodic and aperiodic scheduling algorithm. But LL, LST, and EDD are aperiodic scheduling. It is not applicable to the periodic scheduling."
    },
    {
        "id": 767,
        "Question": "Which of the following periodic scheduling is dynamic?",
        "Options": [
            "a) RMS",
            "b) EDF",
            "c) LST",
            "d) LL"
        ],
        "Answer": "Answer: b\nExplanation: The EDF or the earliest deadline first is a periodic scheduling algorithm which is dynamic but RMS or rate monotonic scheduling is the periodic algorithm which is static. The LL and LST are aperiodic scheduling algorithm."
    },
    {
        "id": 768,
        "Question": "Which of the following do the sporadic events are connected?",
        "Options": [
            "a) Interrupts",
            "b) NMI",
            "c) Software interrupt",
            "d) Timer"
        ],
        "Answer": "Answer: a\nExplanation: The sporadic events are connected to the interrupts thereby execute them immediately as possible since the interrupt priority is the highest in the system."
    },
    {
        "id": 769,
        "Question": "Which of the following can execute quickly, if the interrupt priority is higher in the system?",
        "Options": [
            "a) EDD",
            "b) Sporadic event",
            "c) LL",
            "d) Aperiodic scheduling"
        ],
        "Answer": "Answer: b\nExplanation:  The sporadic events are connected to the interrupts and execute them immediately because the interrupt priority is the highest priority level in the system."
    },
    {
        "id": 770,
        "Question": "Which of the following are used to execute at regular intervals and check for ready sporadic tasks?",
        "Options": [
            "a) sporadic task server",
            "b) sporadic task client",
            "c) sporadic event application",
            "d) sporadic register"
        ],
        "Answer": "Answer: a\nExplanation: The special sporadic task servers are used that execute at regular intervals and check for ready sporadic tasks which improve the predictability of the whole system."
    },
    {
        "id": 771,
        "Question": "How is a sporadic task can turn into a periodic task?",
        "Options": [
            "a) scheduling algorithm",
            "b) sporadic task event",
            "c) sporadic register",
            "d) sporadic task server"
        ],
        "Answer": "Answer: d\nExplanation: The special sporadic task servers execute at regular intervals and check for ready sporadic tasks and by this, sporadic tasks are essentially turned into periodic tasks which can improve the predictability of the whole system."
    },
    {
        "id": 772,
        "Question": "Which of the following is more difficult than the scheduling independent task?",
        "Options": [
            "a) scheduling algorithm",
            "b) scheduling independent task",
            "c) scheduling dependent task",
            "d) aperiodic scheduling algorithm"
        ],
        "Answer": "Answer: c\nExplanation: The scheduling dependent task is more difficult than the independent scheduling task. The problem of deciding whether or not a schedule exists for a given set of dependent tasks and a given deadline is NP-complete."
    },
    {
        "id": 773,
        "Question": "Which scheduling is the basis for a number of formal proofs of schedulability?",
        "Options": [
            "a) LL",
            "b) RMS",
            "c) LST",
            "d) EDD"
        ],
        "Answer": "Answer: b\nExplanation: The rate monotonic scheduling which is an independent scheduling algorithm form the basis for a number of formal proofs of schedulability."
    },
    {
        "id": 774,
        "Question": "Which of the following is independent scheduling?",
        "Options": [
            "a) LL",
            "b) LST",
            "c) EDD",
            "d) RMS"
        ],
        "Answer": "Answer: d\nExplanation: The RMS or rate monotonic scheduling is the independent scheduling algorithm which is included in the assumptions of RMS, that is, all tasks should be independent."
    },
    {
        "id": 775,
        "Question": "Which allows the parallel development of the hardware and software in the simulation?",
        "Options": [
            "a) high-level language simulation",
            "b) low-level language simulation",
            "c) cpu simulator",
            "d) onboard simulator"
        ],
        "Answer": "Answer: a\nExplanation: The high-level language simulation allows parallel development of the software and the hardware and when two parts are integrated, that will work. It can simulate I/O using the keyboard as the inputs or task which passes input data for other modules."
    },
    {
        "id": 776,
        "Question": "Which of the following are used to test the software?",
        "Options": [
            "a) data entity",
            "b) data entry",
            "c) data table",
            "d) data book"
        ],
        "Answer": "Answer: c\nExplanation: In the high-level language simulation, many techniques are used to simulate the system and one such is the data table which contains the data sequences which are used to test the software."
    },
    {
        "id": 777,
        "Question": "Which allows the UNIX software to be ported using a simple recompilation?",
        "Options": [
            "a) pSOS+",
            "b) UNIX compatible library",
            "c) pSOS+m",
            "d) pOS+kernel"
        ],
        "Answer": "Answer: b\nExplanation: The most of the operating system support or provide the UNIX-compatible library which supports the UNIX software to be ported using a simple recompilation."
    },
    {
        "id": 778,
        "Question": "Which of the following can simulate the processor, memory, and peripherals?",
        "Options": [
            "a) input simulator",
            "b) peripheral simulator",
            "c) memory simulator",
            "d) cpu simulator"
        ],
        "Answer": "Answer: d\nExplanation: The CPU simulator can simulate the memory, processor, and the peripherals and allow the low-level assembler code and the small HLL programs to be tested without the actual hardware."
    },
    {
        "id": 779,
        "Question": "How many categories are there for the low-level simulation?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: There are two categories for the low-level simulation. The first category simulates the memory system, programming model and can offer simple debugging tools whereas the second category simulation provides timing information based on the number of clocks."
    },
    {
        "id": 780,
        "Question": "Which of the following can simulate the LCD controllers and parallel ports?",
        "Options": [
            "a) memory simulator",
            "b) sds",
            "c) input simulator",
            "d) output tools"
        ],
        "Answer": "Answer: b\nExplanation: There are certain tools which provide powerful tools for simulation and one such is the SDS which can simulate the processor, memory systems, integrated processor, onboard peripherals such as LCD controllers and parallel ports."
    },
    {
        "id": 781,
        "Question": "Which of the following provides a low-level method of debugging software?",
        "Options": [
            "a) high-level simulator",
            "b) low-level simulator",
            "c) onboard debugger",
            "d) cpu simulator"
        ],
        "Answer": "Answer: c\nExplanation: The onboard debugger provides a very low-level method of simulating or debugging the software. It usually handles EPROMs which are plugged into the board or a set of application codes by providing a serial connection to communicate with the PC or workstation."
    },
    {
        "id": 782,
        "Question": "Which of the following has the ability to download code using a serial port?",
        "Options": [
            "a) cpu simulator",
            "b) high-level language simulator",
            "c) onboard debugger",
            "d) low-level language simulator"
        ],
        "Answer": "Answer: c\nExplanation: The onboard debugger has the ability to download code from a floppy disk or by using a serial port."
    },
    {
        "id": 783,
        "Question": "What does the processor fetch from the EPROM if the board is powered?",
        "Options": [
            "a) reset vector",
            "b) ready vector",
            "c) start vector",
            "d) acknowledge vector"
        ],
        "Answer": "Answer: a\nExplanation: The processor fetches its reset vector from the table which is stored in the EPROM when the board is powered and then starts the initialize the board."
    },
    {
        "id": 784,
        "Question": "Which of the following device can transfer the vector table from the EPROM?",
        "Options": [
            "a) ROM",
            "b) RAM",
            "c) CPU",
            "d) peripheral"
        ],
        "Answer": "Answer: b\nExplanation: When the board gets powered up, the reset vector from the table stored in the EPROM makes the initialisation of the board and is transferred to the RAM from the EPROM through the hardware where the EPROM memory address is temporarily altered."
    },
    {
        "id": 785,
        "Question": "Which of the following is used to determine the number of memory access in an onboard debugger?",
        "Options": [
            "a) timer",
            "b) counter",
            "c) input",
            "d) memory"
        ],
        "Answer": "Answer: b\nExplanation: The counter is used to determine a preset number of memory accesses, which is assumed that the table has been transferred by the debugger and the EPROM address can be safely be changed."
    },
    {
        "id": 786,
        "Question": "Which of the following has the ability to use the high-level language functions, instructions instead of the normal address?",
        "Options": [
            "a) task level debugging",
            "b) low level debugging",
            "c) onboard debugging",
            "d) symbolic debugging"
        ],
        "Answer": "Answer: d\nExplanation: The symbolic debugging has the ability to use high-level language functions, instructions and the variables instead of the normal addresses and their contents."
    },
    {
        "id": 787,
        "Question": "Which of the following debugger works at the operating system level?",
        "Options": [
            "a) task level debugging",
            "b) low level debugging",
            "c) onboard debugging",
            "d) symbolic debugging"
        ],
        "Answer": "Answer: a\nExplanation: The task level debugging has the ability to works at the operating level or at the particular tasks whereas the low-level debugger cannot set for particular task functions or operations, it can only set a breakpoint at the start of the routine which sends a message."
    },
    {
        "id": 788,
        "Question": "Which of the following has a single set of compiler and the debugger tools?",
        "Options": [
            "a) Xray",
            "b) onboard debugger",
            "c) emulation",
            "d) high-level simulator"
        ],
        "Answer": "Answer: a\nExplanation: The Xray debugging technique is a product from the Microtec which is having a complete set of compiler and debugger tools which will work with the simulator, debugger, emulator and the onboard debugger."
    },
    {
        "id": 789,
        "Question": "Who developed the Xray product?",
        "Options": [
            "a) IBM",
            "b) Intel",
            "c) Microtec",
            "d) Motorola"
        ],
        "Answer": "Answer: c\nExplanation: The Xray which is a product from the Microtec is having a complete set of compiler and debugger tools."
    },
    {
        "id": 790,
        "Question": "Which part of the Xray can interface with a simulator?",
        "Options": [
            "a) emulator",
            "b) debugger",
            "c) simulator",
            "d) onboard debugger"
        ],
        "Answer": "Answer: b\nExplanation: The Xray consists of the consistent debugger which can interface the emulator, simulator, task level debugger or onboard debugger."
    },
    {
        "id": 791,
        "Question": "Which can provide the consistent interface to the Xray?",
        "Options": [
            "a) emulator",
            "b) simulator",
            "c) memory simulator",
            "d) debugger system"
        ],
        "Answer": "Answer: d\nExplanation: The Xray consists of the debugger which interfaces with the emulator, simulator, onboard debugger that provides the consistent interface to the Xray product. This can improve the overall productivity of the product since it does not require any relearning."
    },
    {
        "id": 792,
        "Question": "Which of the following can access the information directly in the Xray?",
        "Options": [
            "a) emulator",
            "b) debugger",
            "c) simulator",
            "d) hardware"
        ],
        "Answer": "Answer: c\nExplanation: The Xray obtain its debugging information from a variety of sources and how it access these sources. The simulator can access direct information but the emulator can access the information via a serial line or via the ethernet or directly across a shared memory interface."
    },
    {
        "id": 793,
        "Question": "Which of the following access the information through the ethernet in a Xray?",
        "Options": [
            "a) simulator",
            "b) debugger",
            "c) onboard  debugger",
            "d) emulator"
        ],
        "Answer": "Answer: d\nExplanation: The Xray obtain its debugging information from a variety of sources. The emulator can access the information via a serial line or via the ethernet or directly across a shared memory interface and the simulator can access the direct information."
    },
    {
        "id": 794,
        "Question": "Which tools help the Xray allows the software to be developed on the host system?",
        "Options": [
            "a) compiler tool",
            "b) simulator tool",
            "c) debugger tool",
            "d) emulator tool"
        ],
        "Answer": "Answer: a\nExplanation: The compiler tools allow the software to be developed on the host system and this system does not have to use the same processor as the target."
    },
    {
        "id": 795,
        "Question": "Which of the following is ideal for debugging codes at an early stage?",
        "Options": [
            "a) compiler",
            "b) debugger",
            "c) simulator",
            "d) emulator"
        ],
        "Answer": "Answer: c\nExplanation: There are a variety of ways for executing the codes. The simulator provides an ideal way for debugging the codes at an early stage, that is before the hardware is available and it can allow the software to proceed in parallel with the hardware."
    },
    {
        "id": 796,
        "Question": "How can we extend the power of Xray?",
        "Options": [
            "a) Xray interface",
            "b) Xray memory",
            "c) Xray input",
            "d) Xray peripheral"
        ],
        "Answer": "Answer: a\nExplanation: The power of the Xray product can be extended by the Xray interface method from the operating system debugger."
    },
    {
        "id": 797,
        "Question": "Which of the following uses the Xray interface method to provide the debugging interface?",
        "Options": [
            "a) pSOS+m",
            "b) pSOS",
            "c) pSOS+",
            "d) NAP"
        ],
        "Answer": "Answer: c\nExplanation: The pSOS+ uses the Xray interface method to provide the debugging interfaces which can extend the power of the Xray."
    },
    {
        "id": 798,
        "Question": "How is the processor enter into a BDM state?",
        "Options": [
            "a) BDM signal",
            "b) Start signal",
            "c) BDM acknowledge signal",
            "d) Start signal of the processor"
        ],
        "Answer": "Answer: a\nExplanation: The assertion of the BDM signal or by executing the special BDM instruction, the processor enter into the BDM state and when the processor enters into the BDM mode, low-level microcode takes the processor which allows the breakpoint to be set, registers to be accessed and so on."
    },
    {
        "id": 799,
        "Question": "What does ICE stand for?",
        "Options": [
            "a) in-circuit emulation",
            "b) in-code EPROM",
            "c) in-circuit EPOM",
            "d) in-code emulation"
        ],
        "Answer": "Answer: a\nExplanation: The ICE or in-circuit emulation is one the traditional method used to emulate the processor in the embedded system so that the software can be downloaded and can be debugged in situ in the end application."
    },
    {
        "id": 800,
        "Question": "Which of the following is a traditional method for emulating the processor?",
        "Options": [
            "a) SDS",
            "b) ICE",
            "c) CPU simulator",
            "d) Low-level language simulator"
        ],
        "Answer": "Answer: b\nExplanation: The SDS is one of the simulation tool used in the embedded systems. CPU simulator and the low-level simulator are the other kinds of the simulator used in the embedded system design."
    },
    {
        "id": 801,
        "Question": "Which of the following does not have the ability to get hundred individual signal cables into the probe in the emulation technique?",
        "Options": [
            "a) OnCE",
            "b) BDM",
            "c) ICE",
            "d) JTAG"
        ],
        "Answer": "Answer: c\nExplanation: The in-circuit emulation does not have the ability to get a hundred individual signal cables into the probe. This problem comes under the physical limitation of the probe, that is as the density of the processor increases the available sockets which provide good electrical contacts is becoming harder which causes a restriction to the probe."
    },
    {
        "id": 802,
        "Question": "What does JTAG stand for?",
        "Options": [
            "a) joint tag address group",
            "b) joint test address group",
            "c) joint test access group",
            "d) joint test action group"
        ],
        "Answer": "Answer: d\nExplanation: The JTAG is a joint test action group which is an electronics industry association which developed the interfacing port that is standardised for testing the devices."
    },
    {
        "id": 803,
        "Question": "Which of the following allows access to all the hardware within the system?",
        "Options": [
            "a) debugger",
            "b) JTAG",
            "c) onboard debugger",
            "d) simulator"
        ],
        "Answer": "Answer: b\nExplanation: The JTAG can access all the hardware within the system. They provide a way of taking over the pins of a device and allows the different bit patterns to be imposed on the pins which allow other circuits to be tested with the imposed pins."
    },
    {
        "id": 804,
        "Question": "Which of the following works by using a serial port?",
        "Options": [
            "a) Simulator",
            "b) JTAG",
            "c) BDM",
            "d) OnCE"
        ],
        "Answer": "Answer: b\nExplanation: The JTAG works by using a serial port and clocking data into a shift register and the output of the shift register drives the pins under the control of the port."
    },
    {
        "id": 805,
        "Question": "What is meant by OnCE?",
        "Options": [
            "a) on-chip emulation",
            "b) off-chip emulation",
            "c) one-chip emulation",
            "d) once-chip emulation"
        ],
        "Answer": "Answer: a\nExplanation: The OnCE is an on-chip emulation which is a debugging facility used in the digital signal processor chips."
    },
    {
        "id": 806,
        "Question": "Which debugging facility is used in the Motorola’s DSP 56x0x family?",
        "Options": [
            "a) JTAG",
            "b) ICE",
            "c) OnCE",
            "d) BDM"
        ],
        "Answer": "Answer: c\nExplanation: The on-chip emulation provides a debugging facility in the DSP chips. The OnCE is developed for Motorola’s DSP 56x0x family."
    },
    {
        "id": 807,
        "Question": "Which facility provides the provision of the debug ports in the ICE technique?",
        "Options": [
            "a) simulator",
            "b) emulator",
            "c) debug support",
            "d) jtag"
        ],
        "Answer": "Answer: c\nExplanation: The debugging support to the processor enables the processor to be a single stepped and breakpoint under remote control from a host or the workstation. This facility can provide the provision of the debug ports."
    },
    {
        "id": 808,
        "Question": "How the additional registers are accessed in the OnCE?",
        "Options": [
            "a) parallel port",
            "b) serial port",
            "c) jtag",
            "d) address register"
        ],
        "Answer": "Answer: b\nExplanation: The on-chip emulation can access additional registers by using a special serial port within the device that provides control over the processor and access to its internal registers."
    },
    {
        "id": 809,
        "Question": "Which of the following emulators can provide its own in circuit emulation facility?",
        "Options": [
            "a) Simulator",
            "b) Debugger",
            "c) SDS",
            "d) OnCE"
        ],
        "Answer": "Answer: d\nExplanation: Every system can provide its own in circuit emulation facilities by hooking the port to an interface port in a workstation or in the PC while connecting the OnCE port to an external connector."
    },
    {
        "id": 810,
        "Question": "What does BDM stand for?",
        "Options": [
            "a) background debug mode",
            "b) basic debug mode",
            "c) basic debug microcode",
            "d) background decode mode"
        ],
        "Answer": "Answer: a\nExplanation: The BDM or background debug mode is similar to the on-chip emulator with a slight difference. BDM is provided on the Motorola MC683xx series of processors and for the 8-bit microcontroller like MC68HC12 etc."
    },
    {
        "id": 811,
        "Question": "Which emulator is used in MC68HC12?",
        "Options": [
            "a) JTAG",
            "b) BDM",
            "c) On-CE",
            "d) SDS"
        ],
        "Answer": "Answer: b\nExplanation: The BDM or the background debug mode is provided on the Motorola MC683xx series of processors and for several 8-bit microcontrollers. One such microcontroller is the MC68HC12."
    },
    {
        "id": 812,
        "Question": "Which of the following takes the processor, when the processor enters the BDM mode?",
        "Options": [
            "a) address code",
            "b) high-level microcode",
            "c) low-level microcode",
            "d) data code"
        ],
        "Answer": "Answer: c\nExplanation: When the processor enters into the BDM mode, low-level microcode takes the processor which allows the breakpoint to be set, registers to be accessed and so on."
    },
    {
        "id": 813,
        "Question": "Which of the following has the additional circuitry which supports the background debug mode?",
        "Options": [
            "a) memory",
            "b) input",
            "c) peripheral",
            "d) processor"
        ],
        "Answer": "Answer: d\nExplanation: The processor has the additional circuitry which can provide special support for the background debug mode and is under the control of the remote system connected to its BDM port."
    },
    {
        "id": 814,
        "Question": "Which of these is an area for temporary memory storage?",
        "Options": [
            "a) buffer",
            "b) register",
            "c) table",
            "d) flag"
        ],
        "Answer": "Answer: a\nExplanation: The buffer is an area that is used to store data temporarily which can be used to compensate the timing problems."
    },
    {
        "id": 815,
        "Question": "Which of the following can be used as a collection point of data?",
        "Options": [
            "a) register",
            "b) buffer",
            "c) flag register",
            "d) accumulator"
        ],
        "Answer": "Answer: b\nExplanation: The buffer can be used as a collection point for data, that is all the important information can be collected and organised before processing."
    },
    {
        "id": 816,
        "Question": "Which device can compensate for the timing problems between the software?",
        "Options": [
            "a) index",
            "b) register",
            "c) buffer",
            "d) memory"
        ],
        "Answer": "Answer: c\nExplanation: The buffer is used to store data temporarily which can be used to compensate the timing problems between the software and it can also be used as a collection point for data, that is all the important information can be collected and organised before processing."
    },
    {
        "id": 817,
        "Question": "What do a buffer consist of?",
        "Options": [
            "a) memory and register",
            "b) memory and peripheral",
            "c) memory and flag register",
            "d) memory and pointer"
        ],
        "Answer": "Answer: d\nExplanation: The buffer consists of a pointer and memory which can be used to locate the next piece of data to be removed or accessed from the buffer."
    },
    {
        "id": 818,
        "Question": "Which of the following is a condition for buffer overrun?",
        "Options": [
            "a) cannot accept data",
            "b) cannot receive data",
            "c) cannot provide data",
            "d) can provide data"
        ],
        "Answer": "Answer: a\nExplanation: The buffer involves two conditions. These are the buffer overrun condition and the buffer underrun condition. If the buffer cannot accept any more data, it is said to be buffer overrun."
    },
    {
        "id": 819,
        "Question": "What is the state of the buffer if it asked for data and cannot provide it?",
        "Options": [
            "a) overrun",
            "b) underrun",
            "c) remains unchanged",
            "d) beyond overrun"
        ],
        "Answer": "Answer: b\nExplanation: The buffer is said to be overrun if the buffer cannot accept any more data and said to be underrun if it asked for data but not able to provide it."
    },
    {
        "id": 820,
        "Question": "Which of the following can remove data from the buffer?",
        "Options": [
            "a) memory",
            "b) ram",
            "c) pointer",
            "d) slack"
        ],
        "Answer": "Answer: c\nExplanation: The data can be removed from the buffer using a pointer. The pointer locates the next value and can move the data from the buffer and is moved to the next location by incrementing its value by the number of words or bytes."
    },
    {
        "id": 821,
        "Question": "How many bits does a 32-bit processor can access?",
        "Options": [
            "a) 32-bit char",
            "b) 32-bit word",
            "c) 32-bit double",
            "d) 32-bit double word"
        ],
        "Answer": "Answer: b\nExplanation: The 32-bit processor can access 32-bit word and hence the pointer is incremented by one."
    },
    {
        "id": 822,
        "Question": "What occurs first if data is stored in the buffer?",
        "Options": [
            "a) speed increases",
            "b) linear shoot",
            "c) overshoot",
            "d) delay"
        ],
        "Answer": "Answer: d\nExplanation: When the data is stored in the buffer, at first there will be a delay and the subsequent data is received from the buffer. This delay is known as buffer latency."
    },
    {
        "id": 823,
        "Question": "Which of the following defines the earliest information that is passed through the buffer?",
        "Options": [
            "a) buffer latency",
            "b) memory",
            "c) pointer",
            "d) peripheral"
        ],
        "Answer": "Answer: a\nExplanation: The buffer latency determines the earliest information that passes through the buffer and any response to that information will be delayed by the buffer latency irrespective of how fast the processor is."
    },
    {
        "id": 824,
        "Question": "Which of the following possesses a problem for data streams on the real-time operating system?",
        "Options": [
            "a) pointer",
            "b) memory",
            "c) latency",
            "d) processor"
        ],
        "Answer": "Answer: c\nExplanation: The latency will be a problem for the real-time operating system such as the digital audio system which must have a consistent and regular stream of data."
    },
    {
        "id": 825,
        "Question": "Which of the following determines the time to take a simple sample?",
        "Options": [
            "a) buffer",
            "b) latency",
            "c) pointer",
            "d) memory"
        ],
        "Answer": "Answer: b\nExplanation: The sampling is performed on a regular basis in which the filtering takes less time than the interval between the sample and this does not need a buffering and it will have very low latency. Each sample is received, processed and stored and the latency is the time take a single sample."
    },
    {
        "id": 826,
        "Question": "How is a stack created?",
        "Options": [
            "a) slack and pointer",
            "b) stack and memory",
            "c) memory and a pointer",
            "d) memory and a register"
        ],
        "Answer": "Answer: d\nExplanation: The slack is created in the same way as the buffer does, that is by using a memory and a pointer. The control associated with the buffer or memory is a register which acts as an address pointer."
    },
    {
        "id": 827,
        "Question": "Which of the following acts as an address pointer?",
        "Options": [
            "a) memory",
            "b) pointer",
            "c) stack",
            "d) register"
        ],
        "Answer": "Answer: d\nExplanation: The control associated with the buffer or memory is a register which acts as an address pointer."
    },
    {
        "id": 828,
        "Question": "Which of the following possesses an issue while concerning the memory size of the buffer?",
        "Options": [
            "a) digital signal processor",
            "b) microprocessor",
            "c) memory",
            "d) pointer"
        ],
        "Answer": "Answer: a\nExplanation: The digital signal processor with on-chip memory and the microcontroller possesses an issue on concerning the memory size of the buffer with small amounts of RAM. But with the large system, this is not a major issue."
    },
    {
        "id": 829,
        "Question": "Which of the buffers has a single piece of linear contiguous memory?",
        "Options": [
            "a) circular buffer",
            "b) linear buffer",
            "c) directional buffer",
            "d) double buffer"
        ],
        "Answer": "Answer: b\nExplanation: The linear buffer is contiguous memory which is a single piece memory that is controlled by the pointers whose address increments linearly."
    },
    {
        "id": 830,
        "Question": "Which buffer will lose data when it is full?",
        "Options": [
            "a) linear buffer",
            "b) circular buffer",
            "c) directional buffer",
            "d) double buffer"
        ],
        "Answer": "Answer: a\nExplanation: The linear buffer has a single piece of contiguous memory which is controlled by the pointers whose address increments linearly and it will lose data when it is full and fail to provide data when it is empty."
    },
    {
        "id": 831,
        "Question": "Which of the following buffers loses the incoming data when it is full?",
        "Options": [
            "a) circular buffer",
            "b) double buffer",
            "c) linear buffer",
            "d) directional buffer"
        ],
        "Answer": "Answer: c\nExplanation: The linear buffer will lose the incoming data when full such that the data it contains become older, which is known as the overrun condition."
    },
    {
        "id": 832,
        "Question": "Which state of the linear buffer will provide old data, when it is empty?",
        "Options": [
            "a) overrun",
            "b) critical timing",
            "c) peak overshoot",
            "d) underrun"
        ],
        "Answer": "Answer: d\nExplanation: In the linear buffer, when it is empty it will provide the old data, usually the last entry so that the processor will continue to process the incorrect data potentially, and this condition is known as underrun."
    },
    {
        "id": 833,
        "Question": "Which state of the linear buffer loses its incoming data when full?",
        "Options": [
            "a) underrun",
            "b) overrun",
            "c) critical time",
            "d) pointer"
        ],
        "Answer": "Answer: b\nExplanation: In the overrun condition, the linear buffer will lose the incoming data when the buffer is filled and the data it contains become older."
    },
    {
        "id": 834,
        "Question": "Which technique can solve the errors in the linear buffer?",
        "Options": [
            "a) low water mark",
            "b) high water mark",
            "c) low and high water mark",
            "d) pointer"
        ],
        "Answer": "Answer: c\nExplanation: The errors in the linear buffering include the loss of data especially during the regular sampling which can be avoided by the pointers that are checked against certain values and this result is used for fetching more data. These points are known as the low water mark and the high water mark."
    },
    {
        "id": 835,
        "Question": "Which of the following is similar to the high and low water marks at the coast?",
        "Options": [
            "a) minimum and maximum water level",
            "b) low and high water mark",
            "c) small and big water mark",
            "d) medium and high water mark"
        ],
        "Answer": "Answer: b\nExplanation: There are some errors in the linear buffering which includes the loss of data especially in the regular sampling. This can be avoided by the pointers that are checked against certain values and the result is used to fetch more data. These points are known as the low water mark and the high water mark. It is named so because it is similar to the high and low water marks seen at the coast which indicates the maximum and minimum levels that the tidal water will fall and rise."
    },
    {
        "id": 836,
        "Question": "Which of the following determines the number of entries in the buffer?",
        "Options": [
            "a) low water mark",
            "b) high water mark",
            "c) low and high water mark",
            "d) small and big water mark"
        ],
        "Answer": "Answer: a\nExplanation: The number of entries below the low water mark determines the number of entries the buffer has and the amount of time which is available to fill the buffer before empties and the condition is known as underrun."
    },
    {
        "id": 837,
        "Question": "Which of the following determines the number of empty entries?",
        "Options": [
            "a) low water tank",
            "b) high water tank",
            "c) small water tank",
            "d) big water tank"
        ],
        "Answer": "Answer: b\nExplanation: The high water tank measures the number of empty entries, that is the number of empty entries above the high water tank determines the length of time which is available to stop the filling of the buffer and it can prevent the data loss through overrunning."
    },
    {
        "id": 838,
        "Question": "In which case, the buffer is used by two software task?",
        "Options": [
            "a) single buffer",
            "b) linear buffer",
            "c) double buffer",
            "d) directional buffer"
        ],
        "Answer": "Answer: a\nExplanation: In the single buffer, the buffer is used by two software tasks to insert or extract information. The problem with this buffer is that the water level is above or below, and the free space that is used to fill the buffer does not lie in the correct location."
    },
    {
        "id": 839,
        "Question": "Which buffer is important for the signal data?",
        "Options": [
            "a) double buffer",
            "b) single buffer",
            "c) linear buffer",
            "d) directional buffer"
        ],
        "Answer": "Answer: d\nExplanation: The directional buffer is used for the signal data or for the data which is sampled periodically. The data must be kept in the same order in order to preserve it in chronological order."
    },
    {
        "id": 840,
        "Question": "Which of the following uses two buffers?",
        "Options": [
            "a) linear buffer",
            "b) single buffer",
            "c) double buffer",
            "d) directional buffer"
        ],
        "Answer": "Answer: c\nExplanation: The double buffer uses buffers as its name suggest, one buffer is for filling and the other buffer is for extraction."
    },
    {
        "id": 841,
        "Question": "Which of the following uses a single low water tank and a next data pointer?",
        "Options": [
            "a) single buffer",
            "b) double buffer",
            "c) directional buffer",
            "d) linear buffer"
        ],
        "Answer": "Answer: a\nExplanation: The single buffer uses a single low water tank and a next data pointer. The next data pointer is used for accessing the next entry that should be extracted."
    },
    {
        "id": 842,
        "Question": "Which of the following allows the multiple tasks to process data simultaneously?",
        "Options": [
            "a) single buffer",
            "b) double buffer",
            "c) buffer exchange",
            "d) directional buffer"
        ],
        "Answer": "Answer: c\nExplanation: The buffer exchange allows the multiple tasks to process simultaneously without having to have control structures to supervise access and it is also used to simplify the control code."
    },
    {
        "id": 843,
        "Question": "Which buffering mechanism is common to the SPOX operating system?",
        "Options": [
            "a) buffer exchange",
            "b) single buffer",
            "c) linear buffer",
            "d) directional buffer"
        ],
        "Answer": "Answer: a\nExplanation: The buffer exchange can support the SPOX operating system which is used for the digital signal processors and it is easy to implement."
    },
    {
        "id": 844,
        "Question": "Which buffers exchange the empty buffers for full ones?",
        "Options": [
            "a) single buffer",
            "b) buffer exchange",
            "c) directional buffer",
            "d) double buffer"
        ],
        "Answer": "Answer: b\nExplanation: The buffer exchange can be used for exchanging the empty buffers with the full ones. It will have more than two buffers."
    },
    {
        "id": 845,
        "Question": "Which process takes place when the buffer is empty?",
        "Options": [
            "a) read",
            "b) write",
            "c) read and write",
            "d) memory access"
        ],
        "Answer": "Answer: a\nExplanation: The buffer exchange will contain the data in case of the writing process but the buffer will be emptied in the case of the read cycle."
    },
    {
        "id": 846,
        "Question": "Which process takes place when the buffer contains data?",
        "Options": [
            "a) read",
            "b) read and write",
            "c) acknowledge",
            "d) write"
        ],
        "Answer": "Answer: d\nExplanation: The buffer will be emptied in the case of the readin process and it will contain the data in case of the writing process."
    },
    {
        "id": 847,
        "Question": "Which of the following does not need to have a semaphore?",
        "Options": [
            "a) double buffer",
            "b) single buffer",
            "c) buffer exchange",
            "d) directional buffer"
        ],
        "Answer": "Answer: c\nExplanation: There are many advantages over the buffer exchange. One such is that it will not have a semaphore to control any shared memory or buffers."
    },
    {
        "id": 848,
        "Question": "Which buffer can assimilate a large amount of data before processing?",
        "Options": [
            "a) single buffer",
            "b) double buffer",
            "c) multiple buffers",
            "d) directional buffer"
        ],
        "Answer": "Answer: c\nExplanation: The requesting task can use multiple buffers which can assimilate large amounts of data before processing. This can be considered one of the advantages of the buffer exchange."
    },
    {
        "id": 849,
        "Question": "Which can reduce the latency?",
        "Options": [
            "a) partial filling",
            "b) complete filling",
            "c) no filling",
            "d) multiple buffers"
        ],
        "Answer": "Answer: a\nExplanation: The latency is introduced because of the size of the buffer. The partial filling of data can be used to reduce the latency but it requires some additional control signal. "
    },
    {
        "id": 850,
        "Question": "Which of the following can indicate when the buffer is full or ready for collection?",
        "Options": [
            "a) intra-task communication",
            "b) inter-task communication",
            "c) memory task communication",
            "d) peripheral task communication"
        ],
        "Answer": "Answer: b\nExplanation: The level of the inter-task communication can indicate the buffer status, that is whether it is full or ready for collection."
    },
    {
        "id": 851,
        "Question": "What solution can be done for the inefficiency in the memory usage of small data?",
        "Options": [
            "a) same size buffer",
            "b) single buffer",
            "c) variable size buffer",
            "d) directional buffer"
        ],
        "Answer": "Answer: c\nExplanation: The buffer exchange becomes inefficient while concerning the memory usage for small and the simple data. In order to solve this problem, variable size buffers can be used but this requires a more complex operation to handle the length of the valid data."
    },
    {
        "id": 852,
        "Question": "Which processor has a different segment buffer?",
        "Options": [
            "a) 8051",
            "b) 8086",
            "c) ARM",
            "d) MC68HC11"
        ],
        "Answer": "Answer: b\nExplanation: The 8086 has a segmented architecture where the buffers are having a different segment. In such processors, the device drive is running in the supervisor mode, requesting task in the user mode and so on."
    },
    {
        "id": 853,
        "Question": "Which of the following can combine buffers in a regular and methodical way using pointers?",
        "Options": [
            "a) buffer exchange",
            "b) directional buffer",
            "c) linked lists",
            "d) double buffer"
        ],
        "Answer": "Answer: c\nExplanation: The linked lists are the way of combining buffers in a methodical way and regular method by using the pointers to point the next entry in the list. This can be maintained by adding an entry to the which contains the address of the next buffer."
    },
    {
        "id": 854,
        "Question": "Which entry will have a special value in the linked list?",
        "Options": [
            "a) first entry",
            "b) last entry",
            "c) second entry",
            "d) second last entry"
        ],
        "Answer": "Answer: b\nExplanation: The last entry will have a special value that indicates that the entry is the last one but the first entry uses the pointer entry to locate the position."
    },
    {
        "id": 855,
        "Question": "Which entry can use the pointer in the linked list?",
        "Options": [
            "a) first entry",
            "b) last entry",
            "c) second entry",
            "d) third entry"
        ],
        "Answer": "Answer: a\nExplanation: The first entry of the single linked list will use the pointer entry to point the location of the second entry and so on. The last entry will have a special value that indicates that the entry is the last one."
    },
    {
        "id": 856,
        "Question": "How a buffer memory allocate its memory through the linker?",
        "Options": [
            "a) statically",
            "b) dynamically",
            "c) linearly",
            "d) non-linearly"
        ],
        "Answer": "Answer: a\nExplanation: The buffer memory can be allocated mainly in two ways, statically and dynamically. Statically, the memory is allocated through the linker and dynamically it can allocate memory during runtime by calling an operating system."
    },
    {
        "id": 857,
        "Question": "How did a buffer memory allocate in the runtime?",
        "Options": [
            "a) linearly",
            "b) non-linearly",
            "c) statically",
            "d) dynamically"
        ],
        "Answer": "Answer: d\nExplanation: The buffer memory allocation is done in two ways, statically and dynamically. Dynamically, it can allocate memory during runtime by calling an operating system."
    },
    {
        "id": 858,
        "Question": "Which allocation requires the memory to be defined before building the application?",
        "Options": [
            "a) dynamic allocation",
            "b) static allocation",
            "c) linear allocation",
            "d) straight allocation"
        ],
        "Answer": "Answer: b\nExplanation: The static allocation requires the memory to be defined before building the application and allocates the memory through the special directives at the assembler level."
    },
    {
        "id": 859,
        "Question": "What factor depends on the allocation of buffer memory?",
        "Options": [
            "a) nature",
            "b) size",
            "c) variable type and definition",
            "d) variable size and type"
        ],
        "Answer": "Answer: c\nExplanation: The amount of allocated buffer memory depends on the variable type and the definition, the strings and the character arrays are the most commonly used types."
    },
    {
        "id": 860,
        "Question": "Which are the system calls which are used by the UNIX operating system?",
        "Options": [
            "a) malloc()",
            "b) unmalloc()",
            "c) malloc() and unmalloc()",
            "d) proc() and return"
        ],
        "Answer": "Answer: c\nExplanation: The malloc() and the unmalloc() are the system calls which is used by the UNIX operating system which allocates the memory dynamically and returns it."
    },
    {
        "id": 861,
        "Question": "Which is the counterpart of the malloc()?",
        "Options": [
            "a) unmalloc()",
            "b) proc()",
            "c) struc()",
            "d) return()"
        ],
        "Answer": "Answer: a\nExplanation: The malloc() and unmalloc() are the system calls in which the unmalloc() is the counterpart of the malloc()."
    },
    {
        "id": 862,
        "Question": "How is the UNIX operating system allocates its memory?",
        "Options": [
            "a) statically",
            "b) linearly",
            "c) non linearly",
            "d) dynamically"
        ],
        "Answer": "Answer: d\nExplanation: The malloc() and the unmalloc() are the system calls which is used by the UNIX operating system which allocates the memory dynamically and returns it."
    },
    {
        "id": 863,
        "Question": "Which term is used to describe a bug within the memory system?",
        "Options": [
            "a) memory leakage",
            "b) buffer memory",
            "c) system call",
            "d) register leakage"
        ],
        "Answer": "Answer: a\nExplanation: The memory leakage is used to describe the bug within the memory system."
    },
    {
        "id": 864,
        "Question": "What are the common errors that are seen in memory leakage?",
        "Options": [
            "a) memory size",
            "b) memory type",
            "c) stack frame error",
            "d) stack register"
        ],
        "Answer": "Answer: c\nExplanation: The stack frame errors are the common errors which are seen in the memory leakage and it is caused by the stack overflowing of its allocated memory space and the system call function failure."
    },
    {
        "id": 865,
        "Question": "How the stack frame errors are caused?",
        "Options": [
            "a) stack overflow",
            "b) underrun",
            "c) overrun",
            "d) timing"
        ],
        "Answer": "Answer: a\nExplanation: There are certain common errors called the stack frame errors which are responsible for the memory leakage and it is due to the stack overflowing of its allocated memory space and the system call function failure."
    },
    {
        "id": 866,
        "Question": "Which of the following clean up the stack?",
        "Options": [
            "a) interrupt handler",
            "b) processor",
            "c) exception handler",
            "d) memory handler"
        ],
        "Answer": "Answer: c\nExplanation: The exception handler cleans up the stack memory before returning to the previous executing software thread or the generic handler."
    },
    {
        "id": 867,
        "Question": "Which of the following stores the context of the exception?",
        "Options": [
            "a) stack",
            "b) register",
            "c) ROM",
            "d) RAM"
        ],
        "Answer": "Answer: a\nExplanation: The exception handler is the one which clean up the stack memory before returning to the previous executing software thread and the ROM stores the context of exception in the stack automatically or as a part of the exception routine."
    },
    {
        "id": 868,
        "Question": "Which of the following contains the return information of the stack?",
        "Options": [
            "a) table",
            "b) vector",
            "c) frame",
            "d) block"
        ],
        "Answer": "Answer: c\nExplanation: The stack contains certain frames which are used to store the return information of the stack and thus the frame need to be removed by adjusting the stack pointer accordingly. Normally this is done to avoid the memory leakage."
    },
    {
        "id": 869,
        "Question": "Which of the following allows the reuse of the software and the hardware components?",
        "Options": [
            "a) platform based design",
            "b) memory design",
            "c) peripheral design",
            "d) input design"
        ],
        "Answer": "Answer: a\nExplanation: The platform design allows the reuse of the software and the hardware components in order to cope with the increasing complexity in the design of embedded systems."
    },
    {
        "id": 870,
        "Question": "Which of the following is the design in which both the hardware and software are considered during the design?",
        "Options": [
            "a) platform based design",
            "b) memory based design",
            "c) software/hardware codesign",
            "d) peripheral design"
        ],
        "Answer": "Answer: c\nExplanation: The software/hardware codesign is the one which having both hardware and software design concerns. This will help in the right combination of the hardware and the software for the efficient product."
    },
    {
        "id": 871,
        "Question": "What does API stand for?",
        "Options": [
            "a) address programming interface",
            "b) application programming interface",
            "c) accessing peripheral through interface",
            "d) address programming interface"
        ],
        "Answer": "Answer: b\nExplanation: The platform-based design helps in the reuse of both the hardware and the software components. The application programming interface helps in extending the platform towards software applications."
    },
    {
        "id": 872,
        "Question": "Which activity is concerned with identifying the task at the final embedded systems?",
        "Options": [
            "a) high-level transformation",
            "b) compilation",
            "c) scheduling",
            "d) task-level concurrency management"
        ],
        "Answer": "Answer: d\nExplanation: There are many design activities associated with the platforms in the embedded system and one such is the task-level concurrency management which helps in identifying the task that needed to be present in the final embedded systems."
    },
    {
        "id": 873,
        "Question": "In which design activity, the loops are interchangeable?",
        "Options": [
            "a) compilation",
            "b) scheduling",
            "c) high-level transformation",
            "d) hardware/software partitioning"
        ],
        "Answer": "Answer: c\nExplanation: The high-level transformation is responsible for the high optimizing transformations, that is, the loops can be interchanged so that the accesses to array components become more local."
    },
    {
        "id": 874,
        "Question": "Which design activity helps in the transformation of the floating point arithmetic to fixed point arithmetic?",
        "Options": [
            "a) high-level transformation",
            "b) scheduling",
            "c) compilation",
            "d) task-level concurrency management"
        ],
        "Answer": "Answer: a\nExplanation: The high-level transformation are responsible for the high optimizing transformations, that is, for the loop interchanging and the transformation of the floating point arithmetic to the fixed point arithmetic can be done by the high-level transformation."
    },
    {
        "id": 875,
        "Question": "Which design activity is in charge of mapping operations to hardware?",
        "Options": [
            "a) scheduling",
            "b) high-level transformation",
            "c) hardware/software partitioning",
            "d) compilation"
        ],
        "Answer": "Answer: c\nExplanation: The hardware/software partitioning is the activity which is in charge of mapping operations to the software or to the hardware."
    },
    {
        "id": 876,
        "Question": "Which of the following is approximated during hardware/software partitioning, during task-level concurrency management?",
        "Options": [
            "a) scheduling",
            "b) compilation",
            "c) task-level concurrency management",
            "d) high-level transformation"
        ],
        "Answer": "Answer: a\nExplanation: The scheduling is performed in several contexts. It should be approximated with the other design activities like the compilation, hardware/software partitioning, and task-level concurrency management. The scheduling should be precise for the final code."
    },
    {
        "id": 877,
        "Question": "Which of the following is a process of analyzing the set of possible designs?",
        "Options": [
            "a) design space exploration",
            "b) scheduling",
            "c) compilation",
            "d) hardware/software partitioning"
        ],
        "Answer": "Answer: a\nExplanation: The design space exploration is the process of analyzing the set of designs and the design which meet the specification is selected."
    },
    {
        "id": 878,
        "Question": "Which of the following is a meet-in-the-middle approach?",
        "Options": [
            "a) peripheral based design",
            "b) platform based design",
            "c) memory based design",
            "d) processor design"
        ],
        "Answer": "Answer: b\nExplanation: The platform is an abstraction layer which covers many possible refinements to a lower level and is mainly follows a meet-in-the-middle approach."
    },
    {
        "id": 879,
        "Question": "What does FRIDGE stand for?",
        "Options": [
            "a) fixed-point programming design environment",
            "b) floating-point programming design environment",
            "c) fixed-point programming decoding",
            "d) floating-point programming decoding"
        ],
        "Answer": "Answer: a\nExplanation: Certain tools are available which are developed for the optimization programmes and one such tool is the FRIDGE or fixed-point programming design environment, commercially made by Synopsys System Studio."
    },
    {
        "id": 880,
        "Question": "Which of the following tool can replace the floating point arithmetic to fixed point arithmetic?",
        "Options": [
            "a) SDS",
            "b) FAT",
            "c) VFAT",
            "d) FRIDGE"
        ],
        "Answer": "Answer: d\nExplanation:  There are certain tools available which are developed for the optimization programmes and one such tool is the FRIDGE or fixed-point programming design environment, commercially made available by Synopsys System Studio. This tool can is used in the transformation program, that is the conversion of floating point arithmetic to the fixed point arithmetic. This is widely used in signal processing."
    },
    {
        "id": 881,
        "Question": "Which programming algorithm is used in the starting process of the FRIDGE?",
        "Options": [
            "a) C++",
            "b) JAVA",
            "c) C",
            "d) BASIC"
        ],
        "Answer": "Answer: c\nExplanation: The FRIDGE tool uses C programming algorithm in the initial stage and is converted to a fixed-C algorithm which extends C by two extends."
    },
    {
        "id": 882,
        "Question": "In which loop transformation, a single loop is split into two?",
        "Options": [
            "a) loop tiling",
            "b) loop fusion",
            "c) loop permutation",
            "d) loop unrolling"
        ],
        "Answer": "Answer: b\nExplanation: Many loop transformation are done for the optimization of the program and one such loop transformation is the loop fusion in which a single loop is split and the loop fission includes the merging of the two separate loops."
    },
    {
        "id": 883,
        "Question": "Which loop transformations have several instances of the loop body?",
        "Options": [
            "a) loop fusion",
            "b) loop unrolling",
            "c) loop fission",
            "d) loop tiling"
        ],
        "Answer": "Answer: b\nExplanation: The loop unrolling is a standard transformation which creates several instances of the loop body and the number of copies of the loop is known as the unrolling factor."
    },
    {
        "id": 884,
        "Question": "The number of copies of a loop is called as",
        "Options": [
            "a) rolling factor",
            "b) loop factor",
            "c) unrolling factor",
            "d) loop size"
        ],
        "Answer": "Answer: c\nExplanation: The number of copies of the loop is known as the unrolling factor and it is a standard transformation that produces instances of the loop body."
    },
    {
        "id": 885,
        "Question": "Which of the following can reduce the loop overhead and thus increase the speed?",
        "Options": [
            "a) loop unrolling",
            "b) loop tiling",
            "c) loop permutation",
            "d) loop fusion"
        ],
        "Answer": "Answer: a\nExplanation: The loop unrolling can reduce the loop overhead, that is the fewer branches per execution of the loop body, which in turn increases the speed but is only restricted to loops with a constant number of iteration. The unrolling can increase the code size."
    },
    {
        "id": 886,
        "Question": "Which loop transformation can increase the code size?",
        "Options": [
            "a) loop permutation",
            "b) loop fusion",
            "c) loop fission",
            "d) loop unrolling"
        ],
        "Answer": "Answer: d\nExplanation: The loop unrolling can decrease the loop overhead, the fewer branches per execution of the loop body and this can increase the speed but is only restricted to loops with a constant number of iteration and thus the loop unrolling can increase the code size."
    },
    {
        "id": 887,
        "Question": "Which memories are faster in nature?",
        "Options": [
            "a) RAM",
            "b) ROM",
            "c) Scratch pad memories",
            "d) EEPROM"
        ],
        "Answer": "Answer: c\nExplanation: As the memory size decreases, it is faster in operation, that is the smaller memories are faster than the larger memories. The small memories are caches and the scratch pad memories."
    },
    {
        "id": 888,
        "Question": "Which loop transformation reduces the energy consumption of the memory systems?",
        "Options": [
            "a) loop permutation",
            "b) loop tiling",
            "c) loop fission",
            "d) loop fusion"
        ],
        "Answer": "Answer: b\nExplanation: The loop tiling can reduce the energy the consumption of the memory systems."
    },
    {
        "id": 889,
        "Question": "What does COOL stand for?",
        "Options": [
            "a) coprocessor tool",
            "b) codesign tool",
            "c) code tool",
            "d) code control"
        ],
        "Answer": "Answer: b\nExplanation: The COOL is the codesign tool which is one of the optimisation technique for partitioning the software and the hardware."
    },
    {
        "id": 890,
        "Question": "How many inputs part does COOL have?",
        "Options": [
            "a) 2",
            "b) 4",
            "c) 5",
            "d) 3"
        ],
        "Answer": "Answer: d\nExplanation: The codesign tool consists of three input parts. These are target technology, design constraints and the behaviour and each input follows different functions. The target technology comprises the information about the different hardware platform components available within the system, design constraints are the second part of the input which contains the design constraints, and the behaviour part is the third input which describes the required overall behaviour."
    },
    {
        "id": 891,
        "Question": "Which part of the COOL input comprises information about the available hardware platform components?",
        "Options": [
            "a) target technology",
            "b) design constraints",
            "c) both behaviour and design constraints",
            "d) behaviour"
        ],
        "Answer": "Answer: a\nExplanation: The codesign tool consists of three input parts which are described as target technology, design constraints and the behavior. Each input does different functions. The target technology comprises information about the different hardware platform components available within the system."
    },
    {
        "id": 892,
        "Question": "What does the second part of the COOL input comprise?",
        "Options": [
            "a) behaviour and target technology",
            "b) design constraints",
            "c) behaviour",
            "d) target technology"
        ],
        "Answer": "Answer: b\nExplanation: The second part of the COOL input comprises of the design constraints such as the latency, maximum memory size, required throughput or maximum area for application-specific hardware."
    },
    {
        "id": 893,
        "Question": "What does the third part of the COOL input comprise?",
        "Options": [
            "a) design constraints and target technology",
            "b) design constraints",
            "c) behaviour",
            "d) target technology"
        ],
        "Answer": "Answer: c\nExplanation: The codesign tool consists of three input parts and the third part of the COOL input describes the overall behaviour of the system. The hierarchical task graphs are used for this."
    },
    {
        "id": 894,
        "Question": "How many edges does the COOL use?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: The codesign tool has 2 edges. These are timing edges and the communication edges. The timing edge provides the timing constraints whereas the communication edge contains the information about the amount of information to be exchanged."
    },
    {
        "id": 895,
        "Question": "Which edge provides the timing constraints?",
        "Options": [
            "a) timing edge",
            "b) communication edge",
            "c) timing edge and communication edge",
            "d) special edge"
        ],
        "Answer": "Answer: a\nExplanation: The codesign tool has 2 edges. They are timing edges and the communication edges. The timing edge provides the timing constraints."
    },
    {
        "id": 896,
        "Question": "Which edge of the COOL contains information about the amount of information to be exchanged?",
        "Options": [
            "a) regular edge",
            "b) timing edge",
            "c) communication edge",
            "d) special edge"
        ],
        "Answer": "Answer: c\nExplanation: The codesign tool has 2 edges and these are timing edges and the communication edges. The communication edge contains information about the amount of information to be exchanged."
    },
    {
        "id": 897,
        "Question": "What does Index set KH denotes?",
        "Options": [
            "a) processor",
            "b) hardware components",
            "c) task graph nodes",
            "d) task graph node type"
        ],
        "Answer": "Answer: b\nExplanation: There is a certain index set which is used in the IP or the integer programming model. The KH denotes the hardware component types."
    },
    {
        "id": 898,
        "Question": "What does Index set L denotes?",
        "Options": [
            "a) processor",
            "b) task graph node",
            "c) task graph node type",
            "d) hardware components"
        ],
        "Answer": "Answer: c\nExplanation: The index set is used in the IP or the integer programming model. The Index set KP denotes the processor, I denote the task graph nodes and the L denotes the task graph node type."
    },
    {
        "id": 899,
        "Question": "Which of the following helps in reducing the energy consumption of the embedded system?",
        "Options": [
            "a) compilers",
            "b) simulator",
            "c) debugger",
            "d) emulator"
        ],
        "Answer": "Answer: a\nExplanation: The compilers can reduce the energy consumption of the embedded system and the compilers performing the energy optimizations are available."
    },
    {
        "id": 900,
        "Question": "Which of the following help to meet and prove real-time constraints?",
        "Options": [
            "a) simulator",
            "b) debugger",
            "c) emulator",
            "d) compiler"
        ],
        "Answer": "Answer: d\nExplanation: There are several reasons for designing the optimization and compilers and one such is that it could help to meet and prove the real-time constraints."
    },
    {
        "id": 901,
        "Question": "Which of the following is an important ingredient of all power optimization?",
        "Options": [
            "a) energy model",
            "b) power model",
            "c) watt model",
            "d) power compiler"
        ],
        "Answer": "Answer: b\nExplanation: Saving energy can be done at any stage of the embedded system development. The high-level optimization techniques can reduce power consumption and similarly compiler optimization also can reduce the power consumption and the most important thing in power optimization are the power model."
    },
    {
        "id": 902,
        "Question": "Who proposed the first power model?",
        "Options": [
            "a) Jacome",
            "b) Russell",
            "c) Tiwari",
            "d) Russell and Jacome"
        ],
        "Answer": "Answer: c\nExplanation: Tiwari proposed the first power model in the year 1974. The model includes the so-called bases and the inter-instruction instructions. Base costs of the instruction correspond to the energy consumed per instruction execution when an infinite sequence of that instruction is executed. Inter instruction costs model the additional energy consumed by the processor if instructions change."
    },
    {
        "id": 903,
        "Question": "Who proposed the third power model?",
        "Options": [
            "a) Tiwari",
            "b) Russell",
            "c) Jacome",
            "d) Russell and Jacome"
        ],
        "Answer": "Answer: d\nExplanation: The third model was proposed by Russell and Jacome in the year 1998."
    },
    {
        "id": 904,
        "Question": "Which compiler is based on the precise measurements of two fixed configurations?",
        "Options": [
            "a) first power model",
            "b) second power model",
            "c) third power model",
            "d) fourth power model"
        ],
        "Answer": "Answer: c\nExplanation: The third model was proposed by Russell and Jacome in the year 1998 and is based on the precise measurements of the two fixed configurations."
    },
    {
        "id": 905,
        "Question": "What does SPM stand for?",
        "Options": [
            "a) scratch pad memories",
            "b) sensor parity machine",
            "c) scratch pad machine",
            "d) sensor parity memories"
        ],
        "Answer": "Answer: a\nExplanation: The smaller memories provide faster access and consume less energy per access and SPM or scratch pad memories is a kind of small memory which access fastly and consume less energy per access and it can be exploited by the compiler."
    },
    {
        "id": 906,
        "Question": "Which model is based on precise measurements using real hardware?",
        "Options": [
            "a) encc energy-aware compiler",
            "b) first power model",
            "c) third power model",
            "d) second power model"
        ],
        "Answer": "Answer: a\nExplanation: The encc-energy aware compiler uses the energy model by Steinke et al. it is based on the precise measurements of the real hardware. The power consumption of the memory, as well as the processor, is included in this model."
    },
    {
        "id": 907,
        "Question": "What is the solution to the knapsack problem?",
        "Options": [
            "a) many-to-many mapping",
            "b) one-to-many mapping",
            "c) many-to-one mapping",
            "d) one-to-one mapping"
        ],
        "Answer": "Answer: d\nExplanation: The knapsack problem is associated with the size constraints, that is the size of the scratch pad memories. This problem can be solved by one-to-one mapping which was presented in an integer programming model by Steinke et al."
    },
    {
        "id": 908,
        "Question": "How can one compute the power consumption of the cache?",
        "Options": [
            "a) Lee power model",
            "b) First power model",
            "c) Third power model",
            "d) CACTI"
        ],
        "Answer": "Answer: d\nExplanation: The CACTI can compute the power consumption of the cache which is proposed by Wilton and Jouppi in the year 1996."
    },
    {
        "id": 909,
        "Question": "Which of the following function can interpret data in the C language?",
        "Options": [
            "a) printf",
            "b) scanf",
            "c) proc",
            "d) file"
        ],
        "Answer": "Answer: b\nExplanation: The scanf and printf are the well-known functions in the C language which is used to interpret data and print data respectively."
    },
    {
        "id": 910,
        "Question": "What is the first stage of the compilation process?",
        "Options": [
            "a) pre-processing",
            "b) post-processing",
            "c) compilation",
            "d) linking"
        ],
        "Answer": "Answer: a\nExplanation: The pre-processing involves the first stage of the compilation process in which the include files are added. This file defines the standard functions, constants etc and the output is fed to the compiler."
    },
    {
        "id": 911,
        "Question": "Which of the following produces an assembler file in the compilation process?",
        "Options": [
            "a) pre-processor",
            "b) assembler",
            "c) compiler",
            "d) post-processing"
        ],
        "Answer": "Answer: c\nExplanation: The output of the pre-processor is given to the compiler in which it produces an assembler file from the instruction codes of the processor."
    },
    {
        "id": 912,
        "Question": "Which file is converted to an object file?",
        "Options": [
            "a) hex file",
            "b) decoded file",
            "c) coded file",
            "d) assembly file"
        ],
        "Answer": "Answer: d\nExplanation: The output of the pre-processor is given to the compiler which produces an assembler file from the instruction codes of the processor and this possesses libraries. The assembly file is then converted into the object file and this contains the hexadecimal coding."
    },
    {
        "id": 913,
        "Question": "Which of the following contains the hexadecimal coding?",
        "Options": [
            "a) object file",
            "b) assembly file",
            "c) coded file",
            "d) decoded file"
        ],
        "Answer": "Answer: a\nExplanation: The output of the pre-processor is given to the compiler which produces an assembler file from the instruction codes of the processor and this possesses libraries and then these assembly file is converted into the object file and this possesses the coding of hexadecimal."
    },
    {
        "id": 914,
        "Question": "Which of the following processes the source code before it goes to the compiler?",
        "Options": [
            "a) compiler",
            "b) simulator",
            "c) pre-processor",
            "d) emulator"
        ],
        "Answer": "Answer: c\nExplanation: The pre-processor is responsible for processing the source code before it goes to the compiler and this in turn allows the programmer to define variable types, constants, and much other information."
    },
    {
        "id": 915,
        "Question": "Which of the following allows the programmer to define constants?",
        "Options": [
            "a) pre-processor",
            "b) compiler",
            "c) emulator",
            "d) debugger"
        ],
        "Answer": "Answer: a\nExplanation: The pre-processor processes the source code before it goes to the compiler and this allows the programmer to define variable types, constants, and much other information."
    },
    {
        "id": 916,
        "Question": "Which statement replaces all occurrences of the identifier with string?",
        "Options": [
            "a) # define identifier string",
            "b) # include",
            "c) # define MACRO()",
            "d) # ifdef"
        ],
        "Answer": "Answer: a\nExplanation: # define statement can replace all occurrences of the identifier with string. Similarly, it is able to define the constants, which also make the code easier to understand."
    },
    {
        "id": 917,
        "Question": "Which of the following has the include file?",
        "Options": [
            "a) emulator",
            "b) debugger",
            "c) pre-processor",
            "d) simulator"
        ],
        "Answer": "Answer: c\nExplanation: The pre-processor produces the source code before it goes to the compiler and this allows the programmer to define variable types, constants, and much other information. This pre-processor also has to include files and combines them into the program source."
    },
    {
        "id": 918,
        "Question": "Which statement is used to condense the code to improve the eligibility?",
        "Options": [
            "a) # define MACRO()",
            "b) # include",
            "c) if",
            "d) else-if"
        ],
        "Answer": "Answer: a\nExplanation: The # define MACRO() statement is used to condense the code for improving the code eligibility or for space reasons."
    },
    {
        "id": 919,
        "Question": "Which of the following are header files?",
        "Options": [
            "a) #include",
            "b) file",
            "c) struct()",
            "d) proc()"
        ],
        "Answer": "Answer: a\nExplanation: The #include is a header file which defines the standard constants, variable types, and many other functions. This can also include some standard libraries."
    },
    {
        "id": 920,
        "Question": "Which is the standard C compiler used for the UNIX systems?",
        "Options": [
            "a) simulator",
            "b) compiler",
            "c) cc",
            "d) sc"
        ],
        "Answer": "Answer: c\nExplanation: The cc is the standard C compiler used in the UNIX system. Its command lines can be pre-processed, compiled, assembled and linked to create an executable file."
    },
    {
        "id": 921,
        "Question": "Which compiling option is used to compile programs to form part of a library?",
        "Options": [
            "a) -c",
            "b) -p",
            "c) -f",
            "d) -g"
        ],
        "Answer": "Answer: a\nExplanation: There are several options for the compilers. The option -c compiles the linking stage and then leaves the object file. This option is used to compile programs to form a part of the library."
    },
    {
        "id": 922,
        "Question": "Which compiling option can be used for finding which part of the program is consuming most of the processing time?",
        "Options": [
            "a) -f",
            "b) -g",
            "c) -p",
            "d) -c"
        ],
        "Answer": "Answer: c\nExplanation: The -p instructs the compiler to produce codes which count the number of times each routine is called and this is useful for finding the processing time of the programs."
    },
    {
        "id": 923,
        "Question": "Which compiling option can generate symbolic debug information for debuggers?",
        "Options": [
            "a) -c",
            "b) -p",
            "c) -f",
            "d) -g"
        ],
        "Answer": "Answer: d\nExplanation: The -g generates the symbolic debug information for the debuggers. Without this, the debugger cannot print the variable values, it can only work at the assembler level. The symbolic information is passed through the compilation process and stored in the executable file. "
    },
    {
        "id": 924,
        "Question": "Which of the following is also known as loader?",
        "Options": [
            "a) locater",
            "b) linker",
            "c) assembler",
            "d) compiler"
        ],
        "Answer": "Answer: b\nExplanation: The linker is also known as a loader. It can take the object file and searches the library files to find the routine it calls."
    },
    {
        "id": 925,
        "Question": "Which of the following gives the final control to the programmer?",
        "Options": [
            "a) linker",
            "b) compiler",
            "c) locater",
            "d) simulator"
        ],
        "Answer": "Answer: a\nExplanation: The linker can give the final control to the programmer concerning how unresolved references are reconciled, where the sections are located in the memory, which routines are used, and so on."
    },
    {
        "id": 926,
        "Question": "Which command takes the object file and searches library files to find the routine calls?",
        "Options": [
            "a) simulator",
            "b) emulator",
            "c) debugger",
            "d) linker"
        ],
        "Answer": "Answer: d\nExplanation: The linker is also known as a loader. It can take the object file and searches the library files to find the routine it calls. The linker can give the final control to the programmer concerning how unresolved references are reconciled, where the sections are located in the memory, which routines are used, and so on."
    },
    {
        "id": 927,
        "Question": "Which assembler option is used to turn off long or short address optimization?",
        "Options": [
            "a) -n",
            "b) -V",
            "c) -m",
            "d) -o"
        ],
        "Answer": "Answer: a\nExplanation: The option -o puts the assembler into the file obj file, -V can write the assembler’s version number on the standard error output, -m runs the macro preprocessor on the source file and -n turns off the long or short address optimization."
    },
    {
        "id": 928,
        "Question": "Which assembler option runs the m4 macro preprocessor on the source file?",
        "Options": [
            "a) -n",
            "b) -m",
            "c) -V",
            "d) -o"
        ],
        "Answer": "Answer: b\nExplanation: The option -o puts the assembler into the file obj file, -V can write the assembler’s version number on the standard error output, -m runs the macro preprocessor on the source file and -n turns off the long or short address optimization."
    },
    {
        "id": 929,
        "Question": "Which of the following language can describe the hardware?",
        "Options": [
            "a) C",
            "b) C++",
            "c) JAVA",
            "d) VHDL"
        ],
        "Answer": "Answer: d\nExplanation: The VHDL is the hardware description language which describes the hardware whereas the C, C++ and JAVA are software languages."
    },
    {
        "id": 930,
        "Question": "What do VHDL stand for?",
        "Options": [
            "a) Verilog hardware description language",
            "b) VHSIC hardware description language",
            "c) very hardware description language",
            "d) VMEbus description language"
        ],
        "Answer": "Answer: b\nExplanation: VHDL is the VHSIC(very high speed integrated circuit) hardware description language which was developed by three companies, IBM, Intermetrics and Texas Instruments and the first version of the VHDL is established in the year 1984 and later on the VHDL is standardised by the IEEE."
    },
    {
        "id": 931,
        "Question": "What does VHSIC stand for?",
        "Options": [
            "a) very high speed integrated chip",
            "b) very high sensor integrated chip",
            "c) Verilog system integrated chip",
            "d) Verilog speed integrated chip"
        ],
        "Answer": "Answer: a\nExplanation: The VHSIC stands for very high speed integrated chip and VHDL was designed in the context of the VHSIC, developed by the department of defence in the US."
    },
    {
        "id": 932,
        "Question": "Each unit to be modelled in a VHDL design is known as",
        "Options": [
            "a) behavioural model",
            "b) design architecture",
            "c) design entity",
            "d) structural model"
        ],
        "Answer": "Answer: c\nExplanation: Each unit to be modelled in a VHDL design is known as the design entity or the VHDL entity. There are two types of ingredients are used. These are the entity declaration and the architecture declaration."
    },
    {
        "id": 933,
        "Question": "Which of the following are capable of displaying output signal waveforms resulting from stimuli applied to the inputs?",
        "Options": [
            "a) VHDL simulator",
            "b) VHDL emulator",
            "c) VHDL debugger",
            "d) VHDL locater"
        ],
        "Answer": "Answer: a\nExplanation: The VHDL simulator is capable of displaying the output signal waveforms which results from the stimuli or trigger applied to the input."
    },
    {
        "id": 934,
        "Question": "Which of the following describes the connections between the entity port and the local component?",
        "Options": [
            "a) port map",
            "b) one-to-one map",
            "c) many-to-one map",
            "d) one-to-many maps"
        ],
        "Answer": "Answer: a\nExplanation: The port map describes the connection between the entity port and the local component. The component is declared by component declaration and the entity ports are mapped with the port mapping."
    },
    {
        "id": 935,
        "Question": "Who proposed the CSA theory?",
        "Options": [
            "a) Russell",
            "b) Jacome",
            "c) Hayes",
            "d) Ritchie"
        ],
        "Answer": "Answer: c\nExplanation: The CSA theory is proposed by Hayes and this theory is based on the systematic way of building up value sets."
    },
    {
        "id": 936,
        "Question": "Which of the following is a systematic way of building up value sets?",
        "Options": [
            "a) CSA theory",
            "b) Bayes theorem",
            "c) Russell’s power mode;",
            "d) first power model"
        ],
        "Answer": "Answer: a\nExplanation: The CSA theory is proposed by Hayes. The theory is based on the systematic way of building up value sets, that is the electronics design system uses a variety of value sets, like 2, 3 etc. The goal of developing discrete value sets is to avoid the problems of solving network equations."
    },
    {
        "id": 937,
        "Question": "Which of the following is an abstraction of the signal impedance?",
        "Options": [
            "a) level",
            "b) strength",
            "c) size",
            "d) nature"
        ],
        "Answer": "Answer: b\nExplanation: The systems contain electrical signals of different strengths and it needs to compute the strength and the logic level resulting from a connection of two or more sources of electrical signals. The strength is the abstraction of the signal impedance."
    },
    {
        "id": 938,
        "Question": "Which of the following is an abstraction of the signal voltage?",
        "Options": [
            "a) level",
            "b) strength",
            "c) nature",
            "d) size"
        ],
        "Answer": "Answer: a\nExplanation: Most of the systems contain electrical signals of different strengths and levels. The level of the signal is the abstraction of the signal voltage and the strength is the abstraction of the signal impedance."
    },
    {
        "id": 939,
        "Question": "How many kinds of wait statements are available in the VHDL design?",
        "Options": [
            "a) 3",
            "b) 4",
            "c) 5",
            "d) 6"
        ],
        "Answer": "Answer: b\nExplanation: There are four kinds of wait statements. These are wait on, wait for, wait until and wait."
    },
    {
        "id": 940,
        "Question": "Which wait statement does follow a condition?",
        "Options": [
            "a) wait for",
            "b) wait until",
            "c) wait",
            "d) wait on"
        ],
        "Answer": "Answer: b\nExplanation: The wait until follows a condition. The condition may be an arithmetic or logical one and the wait for statement follows time duration, it might be in microseconds or nanoseconds or any other time unit. Similarly, the wait on statement follows a signal list and the wait statement suspends indefinitely."
    },
    {
        "id": 941,
        "Question": "Which wait statement does follow duration?",
        "Options": [
            "a) wait for",
            "b) wait",
            "c) wait until",
            "d) wait on"
        ],
        "Answer": "Answer: a\nExplanation: The wait for statement follows time duration, it might be in microseconds or nanoseconds or any other time unit."
    },
    {
        "id": 942,
        "Question": "Which of the following is a C++ class library?",
        "Options": [
            "a) C++",
            "b) C",
            "c) JAVA",
            "d) SystemC"
        ],
        "Answer": "Answer: d\nExplanation: System C is a C++ class library which helps in solving the behavioural, resolution, simulation time problems."
    },
    {
        "id": 943,
        "Question": "Which model of SystemC uses floating point numbers to denote time?",
        "Options": [
            "a) SystemC 1.0",
            "b) SystemC 2.0",
            "c) SystemC 3.0",
            "d) SystemC 4.0"
        ],
        "Answer": "Answer: a\nExplanation: The SystemC includes several models of the time units. SystemC 1.0 uses floating point numbers which denote time."
    },
    {
        "id": 944,
        "Question": "Which model of SystemC uses the integer number to define time?",
        "Options": [
            "a) SystemC 1.0",
            "b) SystemC 2.0",
            "c) SystemC 3.0",
            "d) SystemC 4.0"
        ],
        "Answer": "Answer: b\nExplanation: The SystemC includes several models of the time. System 2.0 is an integer model to define time and this model also supports physical units such as microseconds, nanoseconds, picoseconds etc."
    },
    {
        "id": 945,
        "Question": "Which model of the SystemC helps in the communication purpose?",
        "Options": [
            "a) SystemC 2.0",
            "b) SystemC 3.0",
            "c) SystemC 1.0",
            "d) SystemC 4.0"
        ],
        "Answer": "Answer: a\nExplanation: The SystemC 2.0 provides the channel port and interface ports for the communication purpose."
    },
    {
        "id": 946,
        "Question": "Which C++ class is similar to the hardware description language like VHDL?",
        "Options": [
            "a) SystemC",
            "b) Verilog",
            "c) C",
            "d) JAVA"
        ],
        "Answer": "Answer: a\nExplanation: The SystemC is a C++ class which is similar to the hardware description languages like VHDL and Verilog. The execution and simulation time in the SystemC is almost similar to the VHDL."
    },
    {
        "id": 947,
        "Question": "What does ESL stand for?",
        "Options": [
            "a) EEPROM system level",
            "b) Electronic-system level",
            "c) Electrical system level",
            "d) Electron system level"
        ],
        "Answer": "Answer: b\nExplanation: The ESL is electronic-system level and the SystemC is associated with the ESL and TLM. The SystemC is also applied to the architectural exploration, performance modelling, software development and so on."
    },
    {
        "id": 948,
        "Question": "What to TLM stand for?",
        "Options": [
            "a) transfer level modelling",
            "b) triode level modelling",
            "c) transaction level modelling",
            "d) transistor level modelling"
        ],
        "Answer": "Answer: c\nExplanation: The TLM is transaction-level modelling and the SystemC is associated with the ESL and TLM."
    },
    {
        "id": 949,
        "Question": "Which of the following is standardised as IEEE 1364?",
        "Options": [
            "a) C",
            "b) C++",
            "c) FORTRAN",
            "d) Verilog"
        ],
        "Answer": "Answer: d\nExplanation: The Verilog is a hardware description language which was developed for modelling hardware and electronic devices. This was later standardised by IEEE standard 1364."
    },
    {
        "id": 950,
        "Question": "Who developed the Verilog?",
        "Options": [
            "a) Moorby",
            "b) Thomas",
            "c) Russell and Ritchie",
            "d) Moorby and Thomson"
        ],
        "Answer": "Answer: d\nExplanation: The Verilog is a hardware description language which was developed by Moorby and Thomson in 1991 and it was standardised as IEEE standard 1364. The Verilog is modelled for the electronics devices."
    },
    {
        "id": 951,
        "Question": "Which versions of the Verilog is known as System Verilog?",
        "Options": [
            "a) Verilog version 3.0",
            "b) Verilog version 1.0",
            "c) Verilog version 1.5",
            "d) Verilog version 4.0"
        ],
        "Answer": "Answer: a\nExplanation: The Verilog versions 3.0 and 3.1 is called as the System Verilog. These include several extensions to the Verilog version 2.0."
    },
    {
        "id": 952,
        "Question": "Which of the following is a Verilog version 1.0?",
        "Options": [
            "a) IEEE standard 1394-1995",
            "b) IEEE standard 1364-1995",
            "c) IEEE standard 1394-2001",
            "d) IEEE standard 1364-2001"
        ],
        "Answer": "Answer: b\nExplanation: The IEEE standard 1364-1995 is the first version of the Verilog and IEEE standard 1394-2001 is the Verilog version 2.0."
    },
    {
        "id": 953,
        "Question": "Which of the following provides multiple-valued logic with eight signal strength?",
        "Options": [
            "a) Verilog",
            "b) VHDL",
            "c) C",
            "d) C++"
        ],
        "Answer": "Answer: a\nExplanation: The Verilog supports the multiple-valued logic with eight different signal strength but Verilog is less flexible compared to the VHDL, that is, it allows the hardware entities to be instantiated in loops which help to build up a structural description."
    },
    {
        "id": 954,
        "Question": "Which of the following is a superset of Verilog?",
        "Options": [
            "a) Verilog",
            "b) VHDL",
            "c) System Verilog",
            "d) System VHDL"
        ],
        "Answer": "Answer: c\nExplanation: The System Verilog is a superset of the Verilog. But later on, System Verilog and Verilog has merged into a new IEEE standard 1800-2009."
    },
    {
        "id": 955,
        "Question": "Which hardware description language is more flexible?",
        "Options": [
            "a) VHDL",
            "b) Verilog",
            "c) C",
            "d) C++"
        ],
        "Answer": "Answer: a\nExplanation: The Verilog is less flexible compared to the VHDL, that is, it allows the hardware entities to be instantiated in loops which help to build up a structural description. But Verilog, on the other hand, focuses more on the built-in features."
    },
    {
        "id": 956,
        "Question": "Which of the following provide more features for transistor-level descriptions?",
        "Options": [
            "a) C++",
            "b) C",
            "c) VHDL",
            "d) Verilog"
        ],
        "Answer": "Answer: d\nExplanation: The Verilog offers more features than the VHDL but VHDL is more flexible compared to the Verilog. The Verilog can provide transistor-level descriptions but the VHDL cannot provide this description."
    },
    {
        "id": 957,
        "Question": "Which hardware description language is popular in the US?",
        "Options": [
            "a) System Verilog",
            "b) System log",
            "c) Verilog",
            "d) VHDL"
        ],
        "Answer": "Answer: c\nExplanation: Verilog and VHDL are almost similar in their characteristics and have a similar number of users. The VHDL is more popular in Europe whereas Verilog is more popular in the US."
    },
    {
        "id": 958,
        "Question": "Which hardware description language is more popular in Europe?",
        "Options": [
            "a) VHDL",
            "b) System log",
            "c) Verilog",
            "d) C"
        ],
        "Answer": "Answer: a\nExplanation: The Verilog and VHDL are hardware description language and these are similar in their characteristics and have a similar number of users. The VHDL is more popular in Europe. The Verilog is more popular in the US."
    },
    {
        "id": 959,
        "Question": "Which of the following is an analogue extension of the VHDL?",
        "Options": [
            "a) VHDL-AMS",
            "b) System VHDL",
            "c) Verilog",
            "d) System Verilog"
        ],
        "Answer": "Answer: a\nExplanation: The VHDL-AMS is the extension of the VHDL and this includes the analogue and mixed behaviour of the signals."
    },
    {
        "id": 960,
        "Question": "Which of the following support the modelling partial differentiation equation?",
        "Options": [
            "a) gate level",
            "b) algorithmic level",
            "c) system level",
            "d) switch level"
        ],
        "Answer": "Answer: c\nExplanation: There are a variety of levels for designing the embedded systems and each level has its own language. The system level is one such kind which has many peculiarities with respect to the other levels. The system model denotes the entire embedded system and includes the mechanical as well as the information processing aspects. This also supports the modelling of the partial differential equations, which is a key requirement in the modelling."
    },
    {
        "id": 961,
        "Question": "Which level simulates the algorithms that are used within the embedded systems?",
        "Options": [
            "a) gate level",
            "b) circuit level",
            "c) switch level",
            "d) algorithmic level"
        ],
        "Answer": "Answer: d\nExplanation: The algorithmic level simulates the algorithm which is used within in the embedded system."
    },
    {
        "id": 962,
        "Question": "Which level model components like ALU, memories registers, muxes and decoders?",
        "Options": [
            "a) switch level",
            "b) register-transfer level",
            "c) gate level",
            "d) circuit level"
        ],
        "Answer": "Answer: b\nExplanation: The register-transfer level modelling models all the components like the arithmetic and logical unit(ALU), memories, registers, muxes, decoders etc and this modelling is always cycled truly."
    },
    {
        "id": 963,
        "Question": "Which of the following is the most frequently used circuit-level model?",
        "Options": [
            "a) SPICE",
            "b) VHDL",
            "c) Verilog",
            "d) System Verilog"
        ],
        "Answer": "Answer: a\nExplanation: The SPICE is simulation program with integrated circuit emphasis, which is a frequently used circuit-level in the early days. It is used to find the behavior and the integrity of the circuit."
    },
    {
        "id": 964,
        "Question": "Which model includes geometric information?",
        "Options": [
            "a) switch-level model",
            "b) layout model",
            "c) gate level model",
            "d) register-transfer level"
        ],
        "Answer": "Answer: b\nExplanation: The layout reflects the actual circuit model. It includes the geometric information and cannot be simulated directly since it does not provide the information regarding the behavior. "
    },
    {
        "id": 965,
        "Question": "Which model cannot simulate directly?",
        "Options": [
            "a) circuit level model",
            "b) switch-level model",
            "c) gate level model",
            "d) layout model"
        ],
        "Answer": "Answer: d\nExplanation: The layout model reflects the actual circuit model and this includes the geometric information and this model cannot be simulated directly because it does not provide the information regarding the behavior."
    },
    {
        "id": 966,
        "Question": "Which of the following models the components like resistors, capacitors etc?",
        "Options": [
            "a) register-transfer level",
            "b) layout model",
            "c) circuit level model",
            "d) switch-level model"
        ],
        "Answer": "Answer: c\nExplanation: The circuit-level model simulation is used for the circuit theory and its components such as the resistors, inductors, capacitors, voltage sources, current sources. This simulation also involves the partial differential equations."
    },
    {
        "id": 967,
        "Question": "Which model uses transistors as their basic components?",
        "Options": [
            "a) switch model",
            "b) gate level",
            "c) circuit level",
            "d) layout model"
        ],
        "Answer": "Answer: a\nExplanation: The switch model can be used in the simulation of the transistors since the transistor is the very basic component in a switch. It is capable of reflecting bidirectional transferring of the information."
    },
    {
        "id": 968,
        "Question": "Which model is used to denote the boolean functions?",
        "Options": [
            "a) switch level",
            "b) gate level model",
            "c) circuit level",
            "d) layout model"
        ],
        "Answer": "Answer: b\nExplanation: The gate level model is used to denote the boolean functions and the simulation only consider the behaviour of the gate."
    },
    {
        "id": 969,
        "Question": "Which model is used for the power estimation?",
        "Options": [
            "a) gate-level model",
            "b) layout model",
            "c) circuit model",
            "d) switch model"
        ],
        "Answer": "Answer: a\nExplanation: The gate level model is used to denote the boolean functions and the simulation only consider the behaviour of the gate. This model is also useful in the power estimation since it provides accurate information about the signal transition probabilities."
    },
    {
        "id": 970,
        "Question": "In which model, the effect of instruction is simulated and their timing is not considered?",
        "Options": [
            "a) gate-level model",
            "b) circuit model",
            "c) coarse-grained model",
            "d) layout model"
        ],
        "Answer": "Answer: c\nExplanation: The coarse-grained model is a kind of the instruction set level modelling in which only the effect of instruction is simulated and the timing is not considered. The information which is provided in the manual is sufficient for this type of modelling."
    },
    {
        "id": 971,
        "Question": "Which models communicate between the components?",
        "Options": [
            "a) transaction level modelling",
            "b) fine-grained modelling",
            "c) coarse-grained modelling",
            "d) circuit level model"
        ],
        "Answer": "Answer: a\nExplanation: The transaction level modelling is a type of instruction set level model. This modelling helps in the modelling of components which is used for the communication purpose. It also models the transaction, such as read and writes cycles."
    },
    {
        "id": 972,
        "Question": "Which of the following has a cycle-true set of simulation?",
        "Options": [
            "a) switch-level model",
            "b) layout model",
            "c) circuit-level",
            "d) fine-grained model"
        ],
        "Answer": "Answer: d\nExplanation: The fine-grained model has the cycle-true instruction set simulation. In this modelling, it is possible to compute the exact number of clock cycles which is required to run an application."
    },
    {
        "id": 973,
        "Question": "Which of the following is a set of specially selected input patterns?",
        "Options": [
            "a) test pattern",
            "b) debugger pattern",
            "c) bit pattern",
            "d) byte pattern"
        ],
        "Answer": "Answer: a\nExplanation: While testing any devices or embedded systems, we apply some selected inputs which is known as the test pattern and observe the output. This output is compared with the expected output. The test patterns are normally applied to the already manufactured systems."
    },
    {
        "id": 974,
        "Question": "Which is applied to a manufactured system?",
        "Options": [
            "a) bit pattern",
            "b) parity pattern",
            "c) test pattern",
            "d) byte pattern"
        ],
        "Answer": "Answer: c\nExplanation: For testing any devices or embedded systems, we use some sort of selected inputs which is known as the test pattern and observe the output and is compared with the expected output. These test patterns are normally applied to the manufactured systems."
    },
    {
        "id": 975,
        "Question": "Which of the following is based on fault models?",
        "Options": [
            "a) alpha-numeric pattern",
            "b) test pattern",
            "c) bit pattern",
            "d) parity pattern"
        ],
        "Answer": "Answer: b\nExplanation: The test pattern generation is normally based on the fault models and this model is also known as the stuck-at model. The test pattern is based on a certain assumption, that is why it is called the stuck-at model."
    },
    {
        "id": 976,
        "Question": "Which is also called stuck-at model?",
        "Options": [
            "a) byte pattern",
            "b) parity pattern",
            "c) bit pattern",
            "d) test pattern"
        ],
        "Answer": "Answer: d\nExplanation: The test pattern generation is basically based on the fault models and this type of model is also known as the stuck-at model. These test patterns are based on a certain assumption, hence it is known as the stuck-at model."
    },
    {
        "id": 977,
        "Question": "How is the quality of the test pattern evaluated?",
        "Options": [
            "a) fault coverage",
            "b) test pattern",
            "c) size of the test pattern",
            "d) number of errors"
        ],
        "Answer": "Answer: a\nExplanation: The quality of the test pattern can be evaluated on the basis of the fault coverage. It is the percentage of potential faults that can be found for a given test pattern set, that is fault coverage equals the number of detectable faults for a given test pattern set divided by the number of faults possible due to the fault model."
    },
    {
        "id": 978,
        "Question": "What is DfT?",
        "Options": [
            "a) discrete Fourier transform",
            "b) discrete for transaction",
            "c) design for testability",
            "d) design Fourier transform"
        ],
        "Answer": "Answer: c\nExplanation: The design of testability or DfT is the process of designing for the better testability."
    },
    {
        "id": 979,
        "Question": "Which of the following is also known as boundary scan?",
        "Options": [
            "a) test pattern",
            "b) JTAG",
            "c) FSM",
            "d) CRC"
        ],
        "Answer": "Answer: b\nExplanation: The JTAG is a technique for connecting scan chains of several chips and is also known as boundary scan."
    },
    {
        "id": 980,
        "Question": "What does BILBO stand for?",
        "Options": [
            "a) built-in logic block observer",
            "b) bounded input bounded output",
            "c) built-in loading block observer",
            "d) built-in local block observer"
        ],
        "Answer": "Answer: a\nExplanation: The BILBO or the built-in logic block observer is proposed as a circuit combining, test response compaction, test pattern generation, and serial input/output capabilities."
    },
    {
        "id": 981,
        "Question": "What is CRC?",
        "Options": [
            "a) code reducing check",
            "b) counter reducing check",
            "c) counting redundancy check",
            "d) cyclic redundancy check"
        ],
        "Answer": "Answer: d\nExplanation: The CRC or the cyclic redundancy check is the error detecting code which is commonly used in the storage device and the digital networks."
    },
    {
        "id": 982,
        "Question": "What is FSM?",
        "Options": [
            "a) Fourier state machine",
            "b) finite state machine",
            "c) fast state machine",
            "d) free state machine"
        ],
        "Answer": "Answer: b\nExplanation: The FSM is the finite state machine. It will be having a finite number of states and is used to design both the sequential logic circuit and the computer programs. It can be used for testing the scan design in the testing techniques."
    },
    {
        "id": 983,
        "Question": "Which of the following have flip-flops which are connected to form shift registers?",
        "Options": [
            "a) scan design",
            "b) test pattern",
            "c) bit pattern",
            "d) CRC"
        ],
        "Answer": "Answer: a\nExplanation: All the flip-flop storing states are connected to form a shift register in the scan design. It is a kind of test path."
    },
    {
        "id": 984,
        "Question": "Which is a top-down method of analyzing risks?",
        "Options": [
            "a) FTA",
            "b) FMEA",
            "c) Hazards",
            "d) Damages"
        ],
        "Answer": "Answer: a\nExplanation: The FTA is Fault tree analysis which is a top-down method of analyzing risks. It starts with damage and comes up with the reasons for the damage. The analysis is done graphically by using gates."
    },
    {
        "id": 985,
        "Question": "What is FTA?",
        "Options": [
            "a) free tree analysis",
            "b) fault tree analysis",
            "c) fault top analysis",
            "d) free top analysis"
        ],
        "Answer": "Answer: b\nExplanation: The FTA is also known as the Fault tree analysis which is a top-down method of analyzing risks. The analysis starts with damage and comes up with the reasons for the damage. The analysis can be checked graphically by using gates."
    },
    {
        "id": 986,
        "Question": "Which gate is used in the geometrical representation, if a single event causes hazards?",
        "Options": [
            "a) AND",
            "b) NOT",
            "c) NAND",
            "d) OR"
        ],
        "Answer": "Answer: d\nExplanation: The fault tree analysis is done graphically by using gates mainly AND gates and OR gates. The OR gate is used to represent the single event which is hazardous. Similarly, AND gates are used in the graphical representation if several events cause hazards."
    },
    {
        "id": 987,
        "Question": "Which analysis uses the graphical representation of hazards?",
        "Options": [
            "a) Power model",
            "b) FTA",
            "c) FMEA",
            "d) First power model"
        ],
        "Answer": "Answer: b\nExplanation: The FTA is done graphically by using gates mainly AND gates and OR gates. The OR gate is used to represent the single event which is hazardous."
    },
    {
        "id": 988,
        "Question": "Which gate is used in the graphical representation, if several events cause hazard?",
        "Options": [
            "a) OR",
            "b) NOT",
            "c) AND",
            "d) NAND"
        ],
        "Answer": "Answer: c\nExplanation: The fault tree analysis is done graphically by using gates. The main gates used are AND gates and OR gates. The AND gates are used in the graphical representation if several events cause hazards."
    },
    {
        "id": 989,
        "Question": "What is FMEA?",
        "Options": [
            "a) fast mode and effect analysis",
            "b) front mode and effect analysis",
            "c) false mode and effect analysis",
            "d) failure mode and effect analysis"
        ],
        "Answer": "Answer: d\nExplanation: The FMEA is the failure mode and the effect analysis, in which the analysis starts at the components and tries to estimate their reliability."
    },
    {
        "id": 990,
        "Question": "Which of the following can compute the exact number of clock cycles required to run an application?",
        "Options": [
            "a) layout model",
            "b) coarse-grained model",
            "c) fine-grained model",
            "d) register-transaction model"
        ],
        "Answer": "Answer: c\nExplanation: The fine-grained model has the cycle-true instruction set simulation. In this modelling, it is possible to compute the exact number of clock cycles which is required to run an application."
    },
    {
        "id": 991,
        "Question": "Which model is capable of reflecting the bidirectional transfer of information?",
        "Options": [
            "a) switch-level model",
            "b) gate level",
            "c) layout model",
            "d) circuit-level model"
        ],
        "Answer": "Answer: a\nExplanation: The switch model can be used in the simulation of the transistors since the transistor is the very basic component in a switch. It is capable of reflecting bidirectional transferring of the information."
    },
    {
        "id": 992,
        "Question": "What is meant by FOL?",
        "Options": [
            "a) free order logic",
            "b) fast order logic",
            "c) false order logic",
            "d) first order logic"
        ],
        "Answer": "Answer: d\nExplanation: Many formal verification techniques are used and these are classified on the basis of the logics employed. The techniques are propositional logic, first order logic, and higher order logic. The FOL is the abbreviated form of the first order logic which includes the quantification."
    },
    {
        "id": 993,
        "Question": "What is HOL?",
        "Options": [
            "a) higher order logic",
            "b) higher order last",
            "c) highly organised logic",
            "d) higher order less"
        ],
        "Answer": "Answer: a\nExplanation: The formal verification techniques are classified on the basis of the logics employed. The techniques are propositional logic, first order logic, and higher order logic. The HOL is the abbreviation of the higher order logic in which the proofs are automated and manually done with some proof support."
    },
    {
        "id": 994,
        "Question": "What is BDD?",
        "Options": [
            "a) boolean decision diagram",
            "b) binary decision diagrams",
            "c) binary decision device",
            "d) binary device diagram"
        ],
        "Answer": "Answer: b\nExplanation: The binary decision diagram is a kind of data structure which is used to represent the Boolean function."
    },
    {
        "id": 995,
        "Question": "Which formal verification technique consists of a Boolean formula?",
        "Options": [
            "a) HOL",
            "b) FOL",
            "c) Propositional logic",
            "d) Both HOL and FOL"
        ],
        "Answer": "Answer: c\nExplanation: The propositional logic technique is having the boolean formulas and the boolean function. The tools used in propositional logic is the tautology checker or the equivalence checker which in turn uses the binary decision diagrams which are also known as BDD."
    },
    {
        "id": 996,
        "Question": "Which of the following is also known as equivalence checker?",
        "Options": [
            "a) BDD",
            "b) FOL",
            "c) Tautology checker",
            "d) HOL"
        ],
        "Answer": "Answer: c\nExplanation: The propositional logic technique consists of the boolean formulas and the boolean function. The tools used in this type of logic is the tautology checker or the equivalence checker which in turn uses the BDD or the binary decision diagrams."
    },
    {
        "id": 997,
        "Question": "Which of the following is possible to locate errors in the specification of the future bus protocol?",
        "Options": [
            "a) EMC",
            "b) HOL",
            "c) BDD",
            "d) FOL"
        ],
        "Answer": "Answer: c\nExplanation: The model checking was developed using the binary decision diagram and the BDD and it was possible to locate errors in the specification of the future bus protocol."
    },
    {
        "id": 998,
        "Question": "Which of the following is a popular system for model checking?",
        "Options": [
            "a) HOL",
            "b) FOL",
            "c) BDD",
            "d) EMC"
        ],
        "Answer": "Answer: d\nExplanation: The EMC-system is developed by Clark and it describes the CTL formulas, which is the computational tree logics."
    },
    {
        "id": 999,
        "Question": "What is CTL?",
        "Options": [
            "a) computational tree logic",
            "b) code tree logic",
            "c) cpu tree logic",
            "d) computer tree logic"
        ],
        "Answer": "Answer: a\nExplanation: The EMC-system is a popular system for model checking which is developed by Clark that describes the CTL formulas, which is also known as computational tree logics. The CTL consist of two parts, a path quantifier, and a state quantifier."
    }
]