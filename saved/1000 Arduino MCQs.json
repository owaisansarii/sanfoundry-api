[
    {
        "id": 1,
        "Question": "What is the operating frequency of the Arduino UNO Board?",
        "Options": [
            "a) 20 MHz",
            "b) 16 Mhz",
            "c) 6 MHz",
            "d) 10 MHz"
        ],
        "Answer": "Answer: b\nExplanation: The Arduino UNO makes use of the ATmega328 Processor which has an operating frequency of 16 MHz and a maximum operating frequency of 20 MHz which is not advisable since the higher the switching speed, the hotter the chip will get and may even lead to physical damage of the board.\n"
    },
    {
        "id": 2,
        "Question": "What is the Maximum Operating Voltage of the Arduino Due?",
        "Options": [
            "a) 20V",
            "b) 19V",
            "c) 5V",
            "d) 3.3V"
        ],
        "Answer": "Answer: d\nExplanation: Most of the Arduino Boards like the Arduino Mega and Uno, have an operating voltage of 5V. However, the Arduino Due, which is supported by the SAM3X8E ARM Cortex-M3 CPU supports a maximum of 3.3V.\n"
    },
    {
        "id": 3,
        "Question": "Analog Pins in the Arduino boards work on the principle of PWM. What is the full form of PWM?",
        "Options": [
            "a) Pin Wide Modulation",
            "b) Pulse Waveform Modulation",
            "c) Pulse Width Modulation",
            "d) Pulse Wave Modulation"
        ],
        "Answer": "Answer: c\nExplanation: Since perfect analog waveforms can’t be achieved on a digital circuit, Pulse Width Modulation is used to create pseudo analog waveforms by varying the “ON” and “OFF” time of a pulse continuously hence creating a series of pulses whose “width” can be modified according to the need of the user. Here “width” refers to the “ON” time of the pulse. Hence the name Pulse Width Modulation.\n"
    },
    {
        "id": 4,
        "Question": "How much Program Memory does the Arduino UNO have?",
        "Options": [
            "a) 24K bytes",
            "b) 256K bytes",
            "c) 32K bytes",
            "d) 2K bytes"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino UNO is powered by the ATmega328 Processor which has a flash memory (A type of memory that is retained by the chip even after the power supply to the chip is cut off) of 32K bytes.\n"
    },
    {
        "id": 5,
        "Question": "Which of the following boards from the Arduino Family is not powered by a variant of the ATmega processors?",
        "Options": [
            "a) Arduino UNO",
            "b) Arduino Nano",
            "c) Arduino Mega",
            "d) Arduino Due"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino Due uses the SAM3X8E ARM Cortex-M3 CPU which is a member of the Atmel ARM-Based Processors which uses the RISC (Reduced instruction Set Computing) Architecture and has a maximum operating frequency of 84MHz.\n"
    },
    {
        "id": 6,
        "Question": "What is the full form of EEPROM?",
        "Options": [
            "a) Electrically Erasable Programmable Read Only Memory",
            "b) Electrically Encoded Programmable Read Only Memory",
            "c) Electronic Embedded Programmable Read Only Memory",
            "d) Encrypted Electronic Programmable Read Only Memory"
        ],
        "Answer": "Answer: a\nExplanation: EEPROM is a type of non-volatile memory which can be programmed and erased by voltage pulses as input. It’s used to handle small amounts of data. Originally EEPROMs supported only small amounts of data handling limited to 1 Byte. But however, nowadays EEPROMs can support page operations of many bytes.\n"
    },
    {
        "id": 7,
        "Question": "What is the full form of SRAM?",
        "Options": [
            "a) Synchronized Random Access Memory",
            "b) Static Random Access Memory",
            "c) Simplified Random Access Memory",
            "d) Segregated Static Random Access Memory"
        ],
        "Answer": "Answer: b\nExplanation: SRAM is a type of volatile memory (volatile as in, it retains the data as long as power is being supplied to it), which is used for faster access of data. It uses bistable latching circuitry to store data bit by bit. Here, a latch is also called a flip flop which basically has two states depending upon the input signal and it is in this way it stores each bit of data.\n"
    },
    {
        "id": 8,
        "Question": "The Arduino Diecimila has 14 Digital I/O Pins of which __ pins can provide PWM output.",
        "Options": [
            "a) 1",
            "b) 4",
            "c) 6",
            "d) 8"
        ],
        "Answer": "Answer: c\nExplanation: On the Arduino Diecimila the pins 3, 5, 6, 9, 10, 11 provide 8-bit PWM output. Here PWM refers to Pulse Width Modulation which the Arduino being a digital circuit, uses to replicate analog waveforms for providing traditional voltage specific control.\n"
    },
    {
        "id": 9,
        "Question": "What is the use of the RESET button on the Arduino UNO?",
        "Options": [
            "a) To restart the code present in the Arduino",
            "b) To restore a previous version of a code",
            "c) To erase the code present in the Arduino",
            "d) To erase the SRAM in Arduino Microcontroller"
        ],
        "Answer": "Answer: a\nExplanation: The external RESET button on then Arduino is used for restarting the Arduino’s bootloader, effectively stopping the execution of the code that was already present on the Arduino and then rerunning it after a few seconds of delay by which point the bootloader is ready. This should be always performed with all external connections to the GPIO pins of the Arduino taken out.\n"
    },
    {
        "id": 10,
        "Question": "What is the use of the Vin pin present on some Arduino Boards?",
        "Options": [
            "a) To provide a 5V output",
            "b) Is used for plugging in 3V supply",
            "c) To power the Arduino Board",
            "d) To ground the Arduino Board"
        ],
        "Answer": "Answer: c\nExplanation: The Vin Pin can be used for accepting a 9V power supply which is usually given through the external Jack. It can also be used for getting a 9V output when the Arduino is powered through the Jack, thus acting as both a power source and a short from the power source both when needed.\n"
    },
    {
        "id": 11,
        "Question": "What does the analogRead() function do physically when invoked in a code?",
        "Options": [
            "a) It accepts a digital Input",
            "b) Reads the raw voltage value",
            "c) Activates the ADC Circuit to read voltage values",
            "d) Activates the DAC Circuit to read voltage values"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino has an onboard ADC (Analog to Digital Convertor) Circuit which when invoked by the analogRead() function, takes the voltage from the pin that is specified by the program and compares them with the threshold value (5V on the Arduino UNO, 7V on the Arduino Mini and Nano, etc.) and then provides a value ranging from 0 to 1023.\n"
    },
    {
        "id": 12,
        "Question": "What is the use for the 2 serial pins on the Arduino Diecimila?",
        "Options": [
            "a) To send and receive GPIO digital signals",
            "b) To receive analog signals",
            "c) To send PWM signals",
            "d) To send and receive Serial TTL signals"
        ],
        "Answer": "Answer: d\nExplanation: There are two pins for sending and receiving the Serial TTL Signals. The TX (for transmission) and the RX (for receiving). In the Arduino Diecimila they are connected to the corresponding pins of the FTDI USB to Serial Chip.\n"
    },
    {
        "id": 13,
        "Question": "The pins SS, SCK, MOSI and MISO on the Arduino belong to the ___ bus.",
        "Options": [
            "a) I2C",
            "b) SPI",
            "c) GPIO",
            "d) Ethernet"
        ],
        "Answer": "Answer: b\nExplanation: The Pins SS (Select Slave), SCK (Serial Clock), MOSI (Master Output Slave Input), and MISO (Master Input Slave Output) belong to the SPI (Serial Peripheral Interface) Bus which is used as a form of wired communication between two or more microcontrollers.\n"
    },
    {
        "id": 14,
        "Question": "What is the full form of the I2C Protocol?",
        "Options": [
            "a) Inter-Integrated Circuit",
            "b) Intra-Integrated Circuit",
            "c) Integrated-Inter Circuit",
            "d) Infinite-Integrated Circuit"
        ],
        "Answer": "Answer: a\nExplanation: The I2C Protocol is used to connect lower speed IC’s to microcontrollers. It was developed by Phillips Semiconductors in 1982.\n"
    },
    {
        "id": 15,
        "Question": "What is the function of the IOREF pin on the Arduino UNO?",
        "Options": [
            "a) To provide a constant 12V DC supply",
            "b) To provide the voltage corresponding to the standard GPIO working voltage of the board",
            "c) To take input voltage and set it as a reference for all GPIO operations",
            "d) To provide ground"
        ],
        "Answer": "Answer: b\nExplanation: The IOREF pin provides the operation voltage reference for the Arduino. Usually on most Arduino Boards that is 5V but on the Diecimila it is 3.3V however. But this pin should not be at any given time connected to a load as power source.\n"
    },
    {
        "id": 16,
        "Question": "What is the function of the AREF pin in the Arduino UNO?",
        "Options": [
            "a) It is used as a reference voltage for all analog voltage calculations in the board",
            "b) It is used as a reference voltage for all digital voltage calculations in the board",
            "c) It is used as a reference voltage for the power source on the board",
            "d) It is used as a reference voltage for the ground pins on the board"
        ],
        "Answer": "Answer: a\nExplanation: The AREF pin is used internally by the board for measuring the analog voltages. By default, if nothing is connected to it then it will give the range for analog voltage calculation as 0-5V. But this pin when connected to a lower voltage say 3V will set the range for voltage calculations from0-3V.\n"
    },
    {
        "id": 17,
        "Question": "What are the functions of the SDA and SCL pins of the Arduino UNO?",
        "Options": [
            "a) They facilitate I2C communications",
            "b) They facilitate SPI Communications",
            "c) They facilitate USB Communications",
            "d) They facilitate Ethernet Communications"
        ],
        "Answer": "Answer: b\nExplanation: The digital pins on the Arduino UNO are in set B and are numbered from 2 to 13, where the pin 13 is connected to the on-board LED. They can receive and sending digital signals which have a range of 0V (Logical 0) to 5V (Logical 1).\n"
    },
    {
        "id": 18,
        "Question": "Why is the Arduino Mega more a viable solution when dealing with complex projects, than the Arduino UNO?",
        "Options": [
            "a) Higher SRAM on the Arduino Mega",
            "b) More number of GPIO pins on the Arduino Mega",
            "c) More flash memory on the Arduino Mega",
            "d) Higher power rating on the Arduino Mega"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino UNO has 14 pins for IO of which 6 support PWM, while the Arduino Mega has 54 pins for IO of which 14 support PWM. Moreover, the Arduino Mega uses the Atmega2560 microcontroller which has an SRAM of 4K bytes and a flash memory of 256K bytes, whereas the Arduino UNO which is supported by the Atmega328P microcontroller has an SRAM of only 2K bytes and a flash memory of a mere 32K bytes.\n"
    },
    {
        "id": 19,
        "Question": "Which Arduino board is famous for integration with fabric-based projects?",
        "Options": [
            "a) The LilyPad",
            "b) The UNO",
            "c) The Mega",
            "d) The Nano"
        ],
        "Answer": "Answer: a\nExplanation: The Arduino LilyPad is specifically designed for being sewn into fabrics for the purpose of e-textile projects. It comes in 2 variants, one powered by the Atmega328V and the Atmega168V. It has a flash memory of 16K bytes and an SRAM of 1K byte.\n"
    },
    {
        "id": 20,
        "Question": "Which Arduino Product is not just a board but also comes preinstalled with wheels and a motor board.",
        "Options": [
            "a) The LilyPad",
            "b) The Robot",
            "c) The Flora",
            "d) The Mega"
        ],
        "Answer": "Answer: b\nExplanation: The Arduino Robot comes with 2 Atmega32u4’s which have a clock speed of 16MHz and an SRAM of 2.5K bytes and a flash memory of 32K bytes. The bottom board is also connected with two wheels and an Infrared Sensor while the top board is connected to an LCD Screen, 4 buttons, a speaker and a compass chip.\n"
    },
    {
        "id": 21,
        "Question": "Which Arduino Board contains an onboard joystick?",
        "Options": [
            "a) Arduino Esplora",
            "b) Arduino Nano",
            "c) Arduino Due",
            "d) Arduino UNO"
        ],
        "Answer": "Answer: a\nExplanation: The Arduino Esplora comes with the Atmega32u4 and is based on the Leonardo Hardware. It comes preinstalled with a lot of things including a joystick, buttons, TFT Connector for attaching to external LCD’s, an RGB LED, etc. Due to its configuration and setup, it is perfect for beginners to use.\n"
    },
    {
        "id": 22,
        "Question": "For projects where a small microcontroller is required, which boards should we use?",
        "Options": [
            "a) Arduino Yun, Leonardo",
            "b) Arduino Esplora, Robot",
            "c) Arduino Due, Mega, Uno",
            "d) Arduino LilyPad, Nano"
        ],
        "Answer": "Answer: d\nExplanation: All the Arduino Boards specified above are small and can be used for projects where a very small board is required to compute a large amount of data. In addition to that, a very common use of these boards can include sending data to other larger boards which have greater capacity and computing power like the Arduino UNO, Mega or the Due.\n"
    },
    {
        "id": 23,
        "Question": "Which Arduino Board comes with a Linux Distribution?",
        "Options": [
            "a) Arduino Nano",
            "b) Arduino Leonardo",
            "c) Arduino Due",
            "d) Arduino Yun"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino Yun comes preinstalled with a Linux Distribution called Linino. It has an Atmega32u4 and a WifiSoC (The Atheros AR9331) which enables it to connect to Wi-Fi. It also has an ethernet port, a microSD Slot, and 20 Digital IO Ports.\n"
    },
    {
        "id": 24,
        "Question": "With the Arduino Mini, in the absence of an inbuilt USB connector on the board. How is one supposed to connect it to the computer?",
        "Options": [
            "a) Ethernet Adapter",
            "b) SPI",
            "c) I2C",
            "d) RS232 to TTL Serial Adapter"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino Mini does not have an inbuilt USB port and so it can be programmed with any USB Serial to TTL adapter. It contains 14 IO pins of which 6 support PWM. It comes in 2 variants, one with the Atmega168 and the other with the Atmega328 which is a much more recent release of this board.\n"
    },
    {
        "id": 25,
        "Question": "Which Arduino Board would one choose if one had to perform network operations in Linux out of the box?",
        "Options": [
            "a) Arduino Diecimila",
            "b) Arduino Yun",
            "c) Arduino Uno",
            "d) Arduino Esplora"
        ],
        "Answer": "Answer: b\nExplanation: The Arduino Yun is the only Arduino Board that has an onboard WifiSoC (The Atheros AR9331). It also features a Linux Distribution named Linino based on OpenWRT and can support network operations based on Linux.\n"
    },
    {
        "id": 26,
        "Question": "Which Arduino Board has an XBee Socket inbuilt?",
        "Options": [
            "a) Arduino Nano",
            "b) Arduino Micro",
            "c) Arduino Uno",
            "d) Arduino Fio"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino Fio has an Atmega32u4 microcontroller and 14 IO pins of which 6 can be used for PWM. It was specifically built for wireless applications and has an XBee socket inbuilt onboard. It can be programmed using an FTDI cable.\n"
    },
    {
        "id": 27,
        "Question": "Which processor supports the Arduino Zero?",
        "Options": [
            "a) Atmega328P",
            "b) Atmega32u4",
            "c) ARM Cortex M0+",
            "d) ARM Cortex M3"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino Zero uses the Atmel Smart SAM D21 MCU featuring the 32-bit ARM Cortex M0+ CPU. It has a flash memory of 256K bytes and an SRAM of 32K bytes.\n"
    },
    {
        "id": 28,
        "Question": "How much flash memory does the Atmega2560 have?",
        "Options": [
            "a) 13K bytes",
            "b) 200K bytes",
            "c) 256K bytes",
            "d) 255K bytes"
        ],
        "Answer": "Answer: c\nExplanation: A flash memory is a type of non-volatile memory, which does not get erased when the power supply is cutoff from the chip. The Atmega2560 has 256K bytes of flash memory.\n"
    },
    {
        "id": 29,
        "Question": "How many timers does the Atmega2560 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 4",
            "d) 6"
        ],
        "Answer": "Answer: d\nExplanation: The Atmega2560 has a total of 6 timers, of which 2 are 8-bit timers and 4 are 16-bit timers. The number of bits here represents the resolution of the timers, I.e. the number of bits each timer can store.\n"
    },
    {
        "id": 30,
        "Question": "How many comparators does the Atmega2560 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: A comparator is basically used for comparing voltages. It takes 2 voltages as input and outputs the higher of the two. The Atmega2560 has 1 such comparator only.\n"
    },
    {
        "id": 31,
        "Question": "There are __ Digital IO and __ Analog IO Pins on the Atmega2560.",
        "Options": [
            "a) 29, 30",
            "b) 54, 16",
            "c) 53, 17",
            "d) 52, 18"
        ],
        "Answer": "Answer: b\nExplanation: The Atmega2560 has 54 Digital IO Pins and 16 Analog Pins, which, on the Arduino Mega are numbered as D0 to D53 and A0 to A15 respectively. From them, pins D2 to D13 support Pulse Width Modulation.\n"
    },
    {
        "id": 32,
        "Question": "Which Arduino Boards use the Atmega2560?",
        "Options": [
            "a) Arduino Mega and Mega ADK",
            "b) Arduino Micro and Due",
            "c) Arduino Uno and Robot",
            "d) Arduino Nano and Fio"
        ],
        "Answer": "Answer: a\nExplanation: Both the Arduino Mega and the Arduino Mega ADK use the Atmega2560, however the only difference between the two boards is that the Arduino Mega ADK was specifically built with Android phones in mind and has a USB to host connector that can plug into your android smartphone.\n"
    },
    {
        "id": 33,
        "Question": "What is the operating voltage of Atmega2560?",
        "Options": [
            "a) 12V to 9V",
            "b) 1.9V to 5V",
            "c) 2V to 12V",
            "d) 1.8V to 5.5V"
        ],
        "Answer": "Answer: d\nExplanation: The operating voltage of the Atmega2560 is 1.8V to 5.5V. Provide any voltage lower than that and the chip will not function. But however, if any voltage higher than the rated voltage is provided there is a chance of damaging the IC physically. So, under no circumstance should this chip be provided a voltage more than the rated voltage.\n"
    },
    {
        "id": 34,
        "Question": "The Atmega2560 is an _________ bit chip.",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 32",
            "d) 64"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega2560 is capable of processing 8 bits of data at a time and hence it has an 8-bit architecture. Other similar 8-bit processors include the Intel 8080 Processor which ran on a similar 8-bit architecture.\n"
    },
    {
        "id": 35,
        "Question": "How many General-Purpose Registers are present in the Atmega2560?",
        "Options": [
            "a) 12",
            "b) 32",
            "c) 64",
            "d) 9"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega2560, like most other chips has an index corner which is used to identify the numbering of the pins when reading the pin configuration of the chip. Almost all chips have a similar index corner without which, numbering of the pins would be very difficult.\n"
    },
    {
        "id": 36,
        "Question": "The Atmega2560 is a _____ SC Microcontroller.",
        "Options": [
            "a) RI",
            "b) CI",
            "c) AI",
            "d) BI"
        ],
        "Answer": "Answer: b\nExplanation: There are 32 General-Purpose Registers in the chip and they are all connected to the ALU (Arithmetic Logical Unit) directly which allow 2 registers to be accessed in one instruction in a clock cycle.\n"
    },
    {
        "id": 37,
        "Question": "How much flash memory does the Atmega328 have?",
        "Options": [
            "a) 13K bytes",
            "b) 32K bytes",
            "c) 256K bytes",
            "d) 16K bytes"
        ],
        "Answer": "Answer: b\nExplanation: A flash memory is a type of non-volatile memory, which does not get erased when the power supply is cutoff from the chip. The Atmega328 has 32K bytes of flash memory.\n"
    },
    {
        "id": 38,
        "Question": "How many timers does the Atmega328 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: The Atmega328 has a total of 3 timers, of which 2 are 8-bit timers and 1 are 16-bit timers. The number of bits here represents the resolution of the timers, I.e. the number of bits each timer can store.\n"
    },
    {
        "id": 39,
        "Question": "How many comparators does the Atmega328 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: A comparator is basically used for comparing voltages. It takes 2 voltages as input and outputs the higher of the two. The Atmega328 has 1 such comparator only.\n"
    },
    {
        "id": 40,
        "Question": "There are __ ADC and __ PWM Pins on the Atmega328.",
        "Options": [
            "a) 9, 7",
            "b) 8, 6",
            "c) 10, 1",
            "d) 5, 18"
        ],
        "Answer": "Answer: b\nExplanation: The Atmega328 has 8 ADC Pins and 6 PWM Pins, which are to be connected to the ADC that’s built in to the Arduino Uno and the PWM pins provide Pulse Width Modulated output since a digital circuit like a microcontroller cannot provide a perfect analog wave.\n"
    },
    {
        "id": 41,
        "Question": "Which Arduino Boards use the Atmega328?",
        "Options": [
            "a) Arduino Uno",
            "b) Arduino Mega",
            "c) Arduino Fio",
            "d) Arduino Due"
        ],
        "Answer": "Answer: a\nExplanation: The Arduino Uno uses the Atmega328. Some other boards that use this microcontroller include the Arduino Nano which is a smaller development board than the Arduino Uno.\n"
    },
    {
        "id": 42,
        "Question": "What is the operating voltage of Atmega328?",
        "Options": [
            "a) 12V to 9V",
            "b) 1.9V to 5V",
            "c) 1.8V to 5.5V",
            "d) 1.1V to 5V"
        ],
        "Answer": "Answer: c\nExplanation: The operating voltage of the Atmega328 is 1.8V to 5.5V. Provide any voltage lower than that and the chip will not function. But however, if any voltage higher than the rated voltage is provided there is a chance of damaging the IC physically. So, under no circumstance should this chip be provided a voltage more than the rated voltage.\n"
    },
    {
        "id": 43,
        "Question": "The Atmega328 is an _________ bit chip.",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 32",
            "d) 64"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega328 is capable of processing 8 bits of data at a time and hence it has an 8-bit architecture. Other similar 8-bit processors include the Intel 8080 Processor which ran on a similar 8-bit architecture.\n"
    },
    {
        "id": 44,
        "Question": "How many General-Purpose Registers are present in the Atmega328?",
        "Options": [
            "a) 12",
            "b) 64",
            "c) 32",
            "d) 9"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega328, like most other chips has an index corner which is used to identify the numbering of the pins when reading the pin configuration of the chip. Almost all chips have a similar index corner without which, numbering of the pins would be very difficult.\n"
    },
    {
        "id": 45,
        "Question": "The Atmega328 is a ___ SC Microcontroller.",
        "Options": [
            "a) RI",
            "b) CI",
            "c) AI",
            "d) BI"
        ],
        "Answer": "Answer: c\nExplanation: There are 32 General-Purpose Registers in the chip and they are all connected to the ALU (Arithmetic Logical Unit) directly which allow 2 registers to be accessed in one instruction in a clock cycle.\n"
    },
    {
        "id": 46,
        "Question": "How much flash memory does the Atmega32U4 have?",
        "Options": [
            "a) 13K bytes",
            "b) 16K bytes",
            "c) 256K bytes",
            "d) 32K bytes"
        ],
        "Answer": "Answer: d\nExplanation: A flash memory is a type of non-volatile memory, which does not get erased when the power supply is cutoff from the chip. The Atmega32U4 has 32K bytes of flash memory.\n"
    },
    {
        "id": 47,
        "Question": "How many timers does the Atmega32U4 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: d\nExplanation: The Atmega32U4 has a total of 4 timers, of which 1 is an 8-bit timer, 2 are 16-bit timers, and 1 is a 10-bit timer. The number of bits here represents the resolution of the timers, I.e. the number of bits each timer can store.\n"
    },
    {
        "id": 48,
        "Question": "How many comparators does the Atmega32U4 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: A comparator is basically used for comparing voltages. It takes 2 voltages as input and outputs the higher of the two. The Atmega32U4 has 1 such comparator only.\n"
    },
    {
        "id": 49,
        "Question": "Does the Atmega32U4 have a way to handle the brown-out condition?",
        "Options": [
            "a) Yes, it does. It has a provision to programmatically change the brown-out threshold for the chip",
            "b) No, it does not. It does not have a provision to programmatically change the brown-out threshold for the chip",
            "c) Yes, it does. But one cannot change the inbuilt brown-out threshold set for the chip during fabrication",
            "d) Yes, it does. But one can only increase the brown-out threshold for the chip, not decrease it"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega32U4 has a provision to change the brown-out threshold. A brown-out condition occurs when there is a dip in supply voltage that’s being fed to the chip. If the chip continues to function at that time, then it would lead to wrong calculations being done, and that is harmful especially in applications for different industries. Hence in that condition, the chip resets the operations and starts over.\n"
    },
    {
        "id": 50,
        "Question": "Which Arduino Boards use the Atmega32U4?",
        "Options": [
            "a) Arduino Micro",
            "b) Arduino Leonardo",
            "c) Arduino Uno",
            "d) None Mega"
        ],
        "Answer": "Answer: b\nExplanation: The Arduino Leonardo uses the Atmega32U4. Some other boards that use this microcontroller include the Arduino Pro Micro, which is a smaller development board than the Arduino Leonardo.\n"
    },
    {
        "id": 51,
        "Question": "What is the operating voltage of Atmega32U4?",
        "Options": [
            "a) 12V to 9V",
            "b) 1.9V to 5V",
            "c) 1.8V to 5.5V",
            "d) 2.7V to 5.5V"
        ],
        "Answer": "Answer: d\nExplanation: The operating voltage of the Atmega32U4 is 2.7V to 5.5V. Provide any voltage lower than that and the chip will not function. But however, if any voltage higher than the rated voltage is provided there is a chance of damaging the IC physically. So, under no circumstance should this chip be provided a voltage more than the rated voltage.\n"
    },
    {
        "id": 52,
        "Question": "The Atmega32U4 is an ____________ bit chip.",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 32",
            "d) 64"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega32U4 is capable of processing 8 bits of data at a time and hence it has an 8-bit architecture. Other similar 8-bit processors include the Intel 8080 Processor which ran on a similar 8-bit architecture.\n"
    },
    {
        "id": 53,
        "Question": "How many General-Purpose Registers are present in the Atmega32U4?",
        "Options": [
            "a) 12",
            "b) 64",
            "c) 32",
            "d) 9"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega32U4, like most other chips has an index corner which is used to identify the numbering of the pins when reading the pin configuration of the chip. Almost all chips have a similar index corner without which, numbering of the pins would be very difficult.\n"
    },
    {
        "id": 54,
        "Question": "The Atmega32U4 is a ________ SC Microcontroller.",
        "Options": [
            "a) RI",
            "b) CI",
            "c) AI",
            "d) BI"
        ],
        "Answer": "Answer: c\nExplanation: There are 32 General-Purpose Registers in the chip and they are all connected to the ALU (Arithmetic Logical Unit) directly which allow 2 registers to be accessed in one instruction in a clock cycle.\n"
    },
    {
        "id": 55,
        "Question": "How much flash memory does the Atmega168 have?",
        "Options": [
            "a) 13K bytes",
            "b) 32K bytes",
            "c) 256K bytes",
            "d) 16K bytes"
        ],
        "Answer": "Answer: d\nExplanation: A flash memory is a type of non-volatile memory, which does not get erased when the power supply is cutoff from the chip. The Atmega168 has 16K bytes of flash memory.\n"
    },
    {
        "id": 56,
        "Question": "How many timers does the Atmega168 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: The Atmega168 has a total of 3 timers, of which 2 are 8-bit timers and 1 is a 16-bit timer. The number of bits here represents the resolution of the timers, I.e. the number of bits each timer can store.\n"
    },
    {
        "id": 57,
        "Question": "How many comparators does the Atmega168 have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: A comparator is basically used for comparing voltages. It takes 2 voltages as input and outputs the higher of the two. The Atmega168 has 1 such comparator only.\n"
    },
    {
        "id": 58,
        "Question": "There are ___ PWM pins and ____ ADC pins on the Atmega168?",
        "Options": [
            "a) 6, 8",
            "b) 2, 9",
            "c) 3, 1",
            "d) 9, 1"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega168 has 8 ADC Pins and 6 PWM Pins. The ADC pins connect to the onboard Analog to Digital Convertor of the Arduino and the PWM pins provide Pulse Width Modulated output since a digital circuit like a microcontroller cannot provide a perfect analog wave.\n"
    },
    {
        "id": 59,
        "Question": "Which Arduino Boards use the Atmega168?",
        "Options": [
            "a) Arduino Due",
            "b) Arduino Nano",
            "c) Arduino Mini",
            "d) Arduino Uno"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino Mini uses the Atmega168. Some other boards that use this microcontroller include the Arduino Diecimila which is a bigger development board than the Arduino Mini and can be used for projects that require a greater number of pins to operate.\n"
    },
    {
        "id": 60,
        "Question": "What is the operating voltage of Atmega168?",
        "Options": [
            "a) 12V to 9V",
            "b) 1.9V to 5V",
            "c) 1.8V to 5.5V",
            "d) 1.1V to 5V"
        ],
        "Answer": "Answer: c\nExplanation: The operating voltage of the Atmega168 is 1.8V to 5.5V. Provide any voltage lower than that and the chip will not function. But however, if any voltage higher than the rated voltage is provided there is a chance of damaging the IC physically. So, under no circumstance should this chip be provided a voltage more than the rated voltage.\n"
    },
    {
        "id": 61,
        "Question": "The Atmega168 is an ________ bit chip.",
        "Options": [
            "a) 8",
            "b) 16",
            "c) 32",
            "d) 64"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega168 is capable of processing 8 bits of data at a time and hence it has an 8-bit architecture. Other similar 8-bit processors include the Intel 8080 Processor which ran on a similar 8-bit architecture.\n"
    },
    {
        "id": 62,
        "Question": "How many General-Purpose Registers are present in the Atmega168?",
        "Options": [
            "a) 12",
            "b) 64",
            "c) 32",
            "d) 9"
        ],
        "Answer": "Answer: a\nExplanation: The Atmega168, like most other chips has an index corner which is used to identify the numbering of the pins when reading the pin configuration of the chip. Almost all chips have a similar index corner without which, numbering of the pins would be very difficult.\n"
    },
    {
        "id": 63,
        "Question": "The Atmega168 is a _____ SC Microcontroller.",
        "Options": [
            "a) RI",
            "b) CI",
            "c) AI",
            "d) BI"
        ],
        "Answer": "Answer: c\nExplanation: There are 32 General-Purpose Registers in the chip, and they are all connected to the ALU (Arithmetic Logical Unit) directly which allow 2 registers to be accessed in one instruction in a clock cycle.\n"
    },
    {
        "id": 64,
        "Question": "What language is a typical Arduino code based on?",
        "Options": [
            "a) C/C++",
            "b) Java",
            "c) Python",
            "d) Assembly Code"
        ],
        "Answer": "Answer: a\nExplanation: The Arduino code is basically a lightly modified version of the C++ programming language. It includes certain functions or modules that are specific to the development of the Arduino platform and was preinstalled in the language by the developers.\n"
    },
    {
        "id": 65,
        "Question": "What language is the Arduino IDE built on?",
        "Options": [
            "a) C/C++",
            "b) Python",
            "c) HTML",
            "d) Java"
        ],
        "Answer": "Answer: b\nExplanation: The Arduino code uses a lot of pre-built libraries that are specific to the Arduino platform and would certainly not work on any other platform. However, one can remove the lines of code containing the prebuilt libraries from their code and use the code to run on any other C++ platform performing other minor modifications to the code, since the original Arduino code is after all based on C++.\n"
    },
    {
        "id": 66,
        "Question": "Is it possible to write code for the Arduino in any other programming language?",
        "Options": [
            "a) Yes, you can write",
            "b) No, it only allows the use of Arduino Code",
            "c) Yes, but you must write the code in C/C++ only",
            "d) Yes, but you must write the code in Python Only"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino code is primarily a subset of the C++ programming language. However, the IDE (Integrated Development Environment) was written in the Java programming language. An IDE is a software that provides primarily a graphical user interface for compiling and maintaining/editing code for a platform.\n"
    },
    {
        "id": 67,
        "Question": "Does the Arduino code get processed by an interpreter or a compiler?",
        "Options": [
            "a) The Arduino code is processed by an interpreter",
            "b) The Arduino code is first compiled to C++ and then processed using an interpreter",
            "c) The Arduino code is processed by a compiler",
            "d) The Arduino code is directly executed by the processor"
        ],
        "Answer": "Answer: b\nExplanation: The Arduino language is a modified version or subset of the C++ programming language. Hence even if the C++ programming language is a general-purpose programming language, due to the inclusion of certain specific libraries in the subset, the Arduino code cannot run on any other embedded system other than another Arduino board, thus making the programming language platform specific.\n"
    },
    {
        "id": 68,
        "Question": "What is the difference between an IDE and a compiler?",
        "Options": [
            "a) The IDE executes the code while the compiler gives a graphical environment for writing the code",
            "b) The compiler executes the code while the IDE gives a graphical environment for writing the code",
            "c) The compiler links the code to the respective files and the IDE takes it from there",
            "d) The compiler and the IDE are the same thing"
        ],
        "Answer": "Answer: a\nExplanation: The Arduino compiler actually translates or in more technical terms ‘compiles’ the code into assembly language which uses the Arduino’s instruction set. Thus, any other language which has a compiler capable of translating or compiling that code into the Arduino’s instruction set in assembly can essentially be used for writing Arduino code.\n"
    },
    {
        "id": 69,
        "Question": "Can external generic C/C++ libraries be imported to the Arduino IDE and used in the code?",
        "Options": [
            "a) Yes, external C/C++ libraries can be used with the Arduino code",
            "b) No, no external libraies can be imported to the Arduino code",
            "c) Yes, but only libraries that are approved by the company can be used",
            "d) Yes, but the libraries must be written in Arduino Code only"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino code is a working subset of the C++ programming language. The C++ programming language is a compiled one, not an interpreted language. The main difference between an interpreter and a compiler is the way that each one of them handles the debugging and execution of the code. A compiler first checks if the code has any syntax errors or not and then proceeds to converting or more appropriately translating the written code into assembly, while the interpreter executes the code line by line irrespective of whether there is any syntax error in the code or not.\n"
    },
    {
        "id": 70,
        "Question": "Is the Arduino code an Object-Oriented programming language or a Procedural programming language?",
        "Options": [
            "a) The Arduino Code follows the Object-Oriented ideology",
            "b) The Arduino Code follows the Top-Down Procedural ideology",
            "c) The Arduino Code follows the Bottom-Up Procedural ideology",
            "d) The Arduino Code follows a custom Procedural Ideology"
        ],
        "Answer": "Answer: b\nExplanation: According to the primary definitions of a compiler and an IDE, the job of debugging and executing a piece of code falls on the compiler, while the job of the IDE is to provide an easy to use environment for writing the code in the first place.\n"
    },
    {
        "id": 71,
        "Question": "Arduino Codes are referred to as ________ in the Arduino IDE.",
        "Options": [
            "a) drawings",
            "b) notes",
            "c) sketches",
            "d) links"
        ],
        "Answer": "Answer: a\nExplanation: Since the Arduino Language is a subset of the C++ programming language, any existing C/C++ library can be used for importing into an Arduino code. There is no restriction on the use of external libraries since most of the Arduino ecosystem is Open-Source.\n"
    },
    {
        "id": 72,
        "Question": "What is the #include Preprocessor Directive used for?",
        "Options": [
            "a) For getting operating system information",
            "b) For performing read/write operations",
            "c) For importing header files or other codes into the existing code",
            "d) For compiling the written code"
        ],
        "Answer": "Answer: c\nExplanation: A preprocessing directive is any line in a code that starts with a ‘#’ symbol. Whenever there is something like this in a C or C++ code, the compiler is forced to execute that before compiling the code. They are mostly used for importing other codes or header files into the existing code base and can be also used for defining constants.\n"
    },
    {
        "id": 73,
        "Question": "2. Check the validity of the two statements derived from the two lines of code supplied below.<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">#include&lt;file.h&gt;\n#include “file.h”</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Statements i, ii and iii are all false",
            "b) Only Statement iii is false",
            "c) Statements ii and iii are true",
            "d) Only statement i is true"
        ],
        "Answer": "Answer: b\nExplanation: When the preprocessor comes across the above situation, if the file name is surrounded by a double quote then it first navigates to the specified folder or directory and then searches for the specified file. If no directory path is specified, then it searches for the file in the same directory where the existing code file is situated.\n"
    },
    {
        "id": 74,
        "Question": "What is the use of #define?",
        "Options": [
            "a) To define macros",
            "b) To define pointer variables",
            "c) To define file names",
            "d) To create variables"
        ],
        "Answer": "Answer: a\nExplanation: The DEFINE directive allows for the creation of constant variables whose values are to remain constant throughout the entire program. These are also called macros. A common practice or convention is to use the upper-case letters when defining such macros. For the programmer to better understand which variable is a constant and which one can change its value during the program.\n"
    },
    {
        "id": 75,
        "Question": "What is the correct execution process of an Arduino code.",
        "Options": [
            "a) Editor->Compiler->Preprocessor",
            "b) Editor->Preprocessor->Compiler",
            "c) Preprocessor->Editor->Compiler",
            "d) Compiler->Preprocessor->Editor"
        ],
        "Answer": "Answer: b\nExplanation: The code that is written is first done so with the help of the editor. Without the editor there will be no place where the programmer can write his or her code. After that the code is handed over to the preprocessor and finally the compiler which translates the code into the Arduino’s Assembly Instruction Set.\n"
    },
    {
        "id": 76,
        "Question": "5. What would the following code output?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">i. #include&lt;file.h&gt; makes the preprocessor check for file.h only in directories specified by the IDE/Compiler.\nii. #include “file.h” makes the preprocessor check for file.h in the directory specified within the double quotes.\niii. Both the lines of code are the same.</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Error",
            "b) 0",
            "c) 0xa",
            "d) 0xAB"
        ],
        "Answer": "Answer: a\nExplanation: In the above code we have attempted to modify the value of X which is initialized using the preprocessing directive “define” which makes its value unchangeable throughout the entire code. Thus, the compiler will throw an error.\n"
    },
    {
        "id": 77,
        "Question": "6. Give the output of the following code.<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">#define X 10;\nvoid setup(){\n    X=0;\n    Serial.begin(9600);\n    Serial.print(X);\n}\nvoid loop(){\n    //Do nothing…\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Error",
            "b) 12",
            "c) 1",
            "d) 13"
        ],
        "Answer": "Answer: b\nExplanation: In this code we used preprocessor directives to perform a simple multiplication operation. The reason for using this method over normally multiplying the variables is that this method saves processing time and memory during the execution of the program.\n"
    },
    {
        "id": 78,
        "Question": "What is the way of throwing an error using preprocessing directives to the Arduino Compiler and forcing it to stop compilation?",
        "Options": [
            "a) #stop",
            "b) #cut",
            "c) #error",
            "d) #warning"
        ],
        "Answer": "Answer: c\nExplanation: The #error directive first throws an error to the Arduino IDE which is then displayed and then the compilation process is stopped prematurely. This is used to enable the user to stop the compilation process programmatically if some criteria or condition is not met before he or she can allow the program to start running.\n"
    },
    {
        "id": 79,
        "Question": "What character does the preprocessor look out for whilst searching for commands in the code?",
        "Options": [
            "a) x",
            "b) @",
            "c) #",
            "d) !"
        ],
        "Answer": "Answer: c\nExplanation: Any special commands that need to be executed by the preprocessor is always initialized with the help of the ‘#’ symbol. This helps in enhancing the clarity of the code that the programmer writes and also makes it easier for the preprocessor to complete it’s job faster since it does not have to process each and every token throughout the program to simply find out what are the preprocessor commands that have been used.\n"
    },
    {
        "id": 80,
        "Question": "#warning and #error are two preprocessor directives and the job of #warning is to throw a message to the Arduino IDE. However, which of these preprocessor directives stops the compilation process?",
        "Options": [
            "a) #error",
            "b) #warning",
            "c) #include",
            "d) #define"
        ],
        "Answer": "Answer: a\nExplanation: As explained in the question, the job of the #warning preprocessor directive is to throw a message to the Arduino IDE as a warning to notify the user or the programmer of something. However, it does not hinder in the compilation process.\n"
    },
    {
        "id": 81,
        "Question": "How many types of macros are there?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: A macro is a constant variable that gets initialized in a program here with the help of a preprocessor. There are two types of macros, namely object type macros and function type macros. An object type macro is one which is simply a variable name with a value attached to it while a function type macro is one which is of the form of expression.\n"
    },
    {
        "id": 82,
        "Question": "What compiler toolchain is used to compile the Arduino Sketches?",
        "Options": [
            "a) AVR-G++/GCC",
            "b) Python",
            "c) PowerShell",
            "d) Perl"
        ],
        "Answer": "Answer: a\nExplanation: The AVR-GCC/G++ software is a compiler which can take C/C++ code as input and translate or compile it into Binary Code that follows the instruction set for the AVR Microcontrollers. They’re used in the Arduino software since most Arduino Boards use the AVR Microcontroller family.\n"
    },
    {
        "id": 83,
        "Question": "Where does the Arduino IDE search if it needs to find out the Name of a type of Arduino Board?",
        "Options": [
            "a) build.txt",
            "b) boards.txt",
            "c) build.core",
            "d) Arduino.h"
        ],
        "Answer": "Answer: b\nExplanation: The different types of Arduino Boards which are also commonly referred to as “Variants” are present in the boards.txt file. This is a particularly important file because it contains the different configuration information for different Arduino Boards like which compiler toolchain to execute on a particular variant.\n"
    },
    {
        "id": 84,
        "Question": "What is the use of the Arduino.h header file?",
        "Options": [
            "a) It gives root access to the microcontroller’s file system",
            "b) It enables the programmer to access all of Arduino’s core functionality",
            "c) It allows other people to create libraries for the Arduino code",
            "d) It doesn’t have any use and can be omitted at any point of time in the code"
        ],
        "Answer": "Answer: b\nExplanation: The Arduino.h file is not something that we encounter during the process of writing the code for the Arduino board because the preprocessor takes care of it before compilation. However, it is a very important file without which we cannot access the Arduino’s features like GPIO IO, Analog IO, etc.\n"
    },
    {
        "id": 85,
        "Question": "How many architectures does the Arduino subfolder in the Hardware section contain?",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 9"
        ],
        "Answer": "Answer: a\nExplanation: The Arduino subfolder of the Hardware section contains support for 2 architectures; AVR and SAM. The AVR Microcontrollers are included in the most common Arduino Boards like the Uno, Nano, Mega, etc. However, some Arduino Boards like the Arduino Due don’t use AVR but use the SAM 32-bit ARM processors.\n"
    },
    {
        "id": 86,
        "Question": "How many configuration files are there which allows us to customize the architecture in an Arduino in order to add support for custom boards?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: There are 3 configuration files which allow a person to tweak the configurations. These include the following files; platform.txt, boards.txt, and programmers.txt. These files are all really important in defining the architecture for different processors.\n"
    },
    {
        "id": 87,
        "Question": "After the compilation process, the file containing the assembly instructions for the microcontroller is stored in a file. What is the file type?",
        "Options": [
            "a) .o",
            "b) .hex",
            "c) .cpp",
            "d) .hpp"
        ],
        "Answer": "Answer: b\nExplanation: The assembly instructions for the microcontroller is stored in a hex file. This file contains the assembly instructions in hex format for the microcontroller to understand and execute. It is the binary executable file that allows us to execute the high-level C code on any microcontroller.\n"
    },
    {
        "id": 88,
        "Question": "Which of the following file format is generated once the C code is compiled?",
        "Options": [
            "a) .c",
            "b) .h",
            "c) .ino",
            "d) .o"
        ],
        "Answer": "Answer: d\nExplanation: All C code is compiled to a .o file. This file format is called the Object File Format. The compiler creates these object files during compilation, for each source code and then links each of these together for making the executable file for that language.\n"
    },
    {
        "id": 89,
        "Question": "What is the .d file format’s use in C?",
        "Options": [
            "a) For managing dependencies",
            "b) For the D programming language",
            "c) For storing the variables and memory locations",
            "d) For creating new errors in dependencies"
        ],
        "Answer": "Answer: a\nExplanation: The “.d” file format is used for managing and generating the dependency list for a program. A dependency is a supporting program that has the functionality that is required for the smooth and in times, the very execution of another program.\n"
    },
    {
        "id": 90,
        "Question": "Why does every compilation of a source code in Arduino check for previous compilations?",
        "Options": [
            "a) To delete the previously generated “.o” files",
            "b) To use the previously generated “.o” files",
            "c) To relocate the previously generated “.o” files",
            "d) To copy the previously generated “.o” files"
        ],
        "Answer": "Answer: b\nExplanation: During the compilation process, the Arduino compiler before compilation searches for previously generated “.o” files in the directory, to make the compilation process faster in some cases. This reduces the redundancy of compiling the same parts of the code repeatedly.\n"
    },
    {
        "id": 91,
        "Question": "How to view each command that gets executed during the compilation process?",
        "Options": [
            "a) Enable Verbose Output",
            "b) Disable Verbose Output",
            "c) Show Sketch Folder",
            "d) Open Serial Plotter"
        ],
        "Answer": "Answer: a\nExplanation: A verbose is a feature that reports all information in a process, function or code. The Arduino Verbose Output helps in displaying the output for each execution step in the Arduino Compilation Process.\n"
    },
    {
        "id": 92,
        "Question": "Which software is used to upload the Arduino Sketches to the board?",
        "Options": [
            "a) avrdude",
            "b) avrgcc",
            "c) g++",
            "d) cpython for windows"
        ],
        "Answer": "Answer: a\nExplanation: The AVR-GCC/G++ software is a compiler which can take C/C++ code as input and translate or compile it into Binary Code that follows the instruction set for the AVR Microcontrollers. After that process is done, the avrdude software has the job of uploading the hex file to the microcontroller, more specifically the AVR Microcontroller family.\n"
    },
    {
        "id": 93,
        "Question": "2. What is the name for the characters ‘-p’ given in the command below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">avrdude -p atmega32u4 -c stk500 -e -U flash:w:diag.hex</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Compile",
            "b) Error",
            "c) Flag",
            "d) Boolean"
        ],
        "Answer": "Answer: c\nExplanation: The character that is being referred here is called a flag. It is basically like a condition or argument that needs to be fulfilled by the program which is to be invoked with the help of the command that the user enters, followed by the actual parameters of that command. Here the flag “p” suggests the explicit mention of the type of the target device.\n"
    },
    {
        "id": 94,
        "Question": "What is the use of the dmesg command?",
        "Options": [
            "a) Sending messages to the device connected",
            "b) Reading messages generated from avrdude",
            "c) Receiving messages from the gcc compiler",
            "d) Receiving messages from the particular device"
        ],
        "Answer": "Answer: d\nExplanation: The dmesg command is used for displaying any messages like errors or warnings that a device might have issued to the system. It can give us 3 things; the time, i.e. the time after startup when the message was generated, the device name, and the message text or message content.\n"
    },
    {
        "id": 95,
        "Question": "What is USBasp?",
        "Options": [
            "a) It is a compiler for microcontroller code",
            "b) It is a software for debugging any code preexisting in microcontrollers",
            "c) It is a programmer for a specific microcontroller family",
            "d) It is a microcontroller that is produced by Atmel"
        ],
        "Answer": "Answer: c\nExplanation: It is a USB programmer for AVR microcontrollers which most Arduino Boards use. In that it is used to put programs into the microcontroller using the flash and the EEPROM of that microcontroller. It is itself powered by an Atmega8 chip. This hardware coupled with the avrdude software is a powerful tool to upload programs into the microcontrollers.\n"
    },
    {
        "id": 96,
        "Question": "",
        "Options": [
            "a) A=MOSI, B=VCC, C=GND, D=RESET, E=SCK, F=MISO",
            "b) A=VCC, B=MOSI, C=SCK, D=GND, E=MISO, F=RESET",
            "c) A=SCK, B=MISO, C=RESET, D=GND, E=VCC, F=MOSI",
            "d) A=MISO, B=MOSI, C=RESET, D=VCC, E=GND, F=SCK"
        ],
        "Answer": "Answer: a\nExplanation: Here,\nPin 1 - MOSI or Master Output Slave Input\nPin 2 - VCC (5V Input Supply)\nPin 3 - GND (Common Ground)\nPin 4 - RESET (Pin that resets the microcontroller manually if something goes wrong.)\nPin 5 - SCK (Serial Clock Pin)\nPin 6 - MISO or Master Input Slave Output\n\n"
    },
    {
        "id": 97,
        "Question": "What is the use of the MOSI and MISO pins?",
        "Options": [
            "a) To download code from the microcontroller to the computer",
            "b) To verify the program that the computer uploads to the microcontroller",
            "c) To erase the SRAM of the microcontroller",
            "d) To dump or transfer programs from the computer to the microcontroller"
        ],
        "Answer": "Answer: d\nExplanation: The MOSI and MISO pins are a part of the SPI (Serial Peripheral Interface) for transferring data over short distances. It is a form of Synchronous Serial Communication. These pins commit hex data from the computer to the EEPROM and flash memory of the microcontroller.\n"
    },
    {
        "id": 98,
        "Question": "Select the correct name for the SPI master-slave configuration.",
        "Options": [
            "a) Dependent Slave Configuration",
            "b) Independent Master Configuration",
            "c) Independent Slave Configuration",
            "d) Chained Master and Slave Configuration"
        ],
        "Answer": "Answer: a\nExplanation: The SPI (Serial Peripheral Interface) enables data transfer using 4 wires of which the MOSI and MISO transfer data between the slave and master devices and the SCK pin through which the Serial Clock Pulse is transmitted is used by the master device to sync with the slave device to a frequency which the slave device supports.\n"
    },
    {
        "id": 99,
        "Question": "What is the recipe for compiling Assembly Source Code in the Arduino IDE?",
        "Options": [
            "a) recipe.S.o.pattern",
            "b) recipe.A.n.pattern",
            "c) recipe.S.b.pattern",
            "d) recipe.S.i.pattern"
        ],
        "Answer": "Answer: c\nExplanation: The Independent Slave Configuration is a type of SPI configuration where each slave is a separate chip and the master device talks to one chip at a time.\nThe setup is given below…\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2020/05/arduino-questions-answers-uploading-q8.png\" alt=\"SPI master-slave configuration diagram\" width=\"746\" height=\"331\" class=\"alignnone size-full wp-image-277943\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2020/05/arduino-questions-answers-uploading-q8.png 746w, https://www.sanfoundry.com/wp-content/uploads/2020/05/arduino-questions-answers-uploading-q8-300x133.png 300w\" sizes=\"(max-width: 746px) 100vw, 746px\" />\n"
    },
    {
        "id": 100,
        "Question": "10. What is the purpose of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">uno.upload.tool=avrdude</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) To set the Board Variant name",
            "b) To set the upload software name",
            "c) To erase the upload tool name",
            "d) To reset the upload tool"
        ],
        "Answer": "Answer: a\nExplanation: A recipe in Computer Science is the steps involved in creating something. Here the compiler has a predetermined “Recipe” or way to deal with Assembly Source Codes when the need arises. Now since the Arduino IDE can also compile C and C++ source files, it also has a predetermined way to deal with those file types as well.\n"
    },
    {
        "id": 101,
        "Question": "What type of signal does the analogWrite() method generate when a pin is set to OUTPUT mode?",
        "Options": [
            "a) Digital Signal",
            "b) Pulse Code Modulated Signal",
            "c) Pulse amplitude Modulated Signal",
            "d) Pulse Width Modulated Signal"
        ],
        "Answer": "Answer: d\nExplanation: The analogWrite() method in Arduino is used to generate a Pulse Width Modulated Signal since the digital circuitry in the Arduino does not allow for generation of true continuous analog waves. So therefore, the PWM Signal is used.\n"
    },
    {
        "id": 102,
        "Question": "2. What is the output of “pin1” if “pin2” is sent “1011” where 1 is 5V and 0 is 0V?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1 = 12;</pre></li><li class=\"li1\"><pre class=\"de1\">int pin2 = 11;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1, OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin2, INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    if(digitalRead(pin2)==1) {</pre></li><li class=\"li1\"><pre class=\"de1\">        digitalWrite(pin1,LOW);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else if(digitalRead(pin2)==0) {</pre></li><li class=\"li1\"><pre class=\"de1\">        digitalWrite(pin1,HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 0100",
            "b) 1011",
            "c) 1110",
            "d) 1111"
        ],
        "Answer": "Answer: a\nExplanation: Here when pin2 receives a digital 1 we set pin1 as “LOW” or a digital 0, and conversely when pin2 receives a digital 0 we set pin1 as “HIGH” or a digital 1. Therefore, effectively generating the inverse of the wave that we received as input.\n"
    },
    {
        "id": 103,
        "Question": "What are the two modes that the pinMode() method sets for a particular pin?",
        "Options": [
            "a) DIGITAL and ANALOG",
            "b) INPUT and OUTPUT",
            "c) TX and RX",
            "d) READ and WRITE"
        ],
        "Answer": "Answer: b\nExplanation: The pinMode() method determines whether the pin number given in the code is to be used as an input pin wherein it can read voltage from an external circuit or for setting a particular voltage at the pin output to be plugged to an external circuit.\n"
    },
    {
        "id": 104,
        "Question": "What are the voltage levels that can be detected if a pin is set to OUTPUT using the pinMode() method and the analogRead() method is used, in the Arduino Uno?",
        "Options": [
            "a) 0 and 5V",
            "b) 0 to 5.1V",
            "c) 0 to 5V",
            "d) 0 to 10V"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino UNO has an operating voltage ranging from 0V to 5V. Hence the Serial monitor will record an output ranging from 0 to 1023. This is done by mapping the value of the voltage to an integer set that has a range of 0 to 1023.\n"
    },
    {
        "id": 105,
        "Question": "5. What will the code given below give as output if a 5V line is connected as input to pin 11?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin_1=11;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin_1, INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int reading=analogRead(pin_1);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(reading);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 0",
            "b) 102",
            "c) Null",
            "d) 1023"
        ],
        "Answer": "Answer: d\nExplanation: The voltage that is put across the pin 11 goes into the analog to digital convertor onboard the Arduino and then it is converted into an integer value that ranges from 0 to 1023. This is done by “mapping” the voltage value read, to a range of integers from 0 to 1023.\n"
    },
    {
        "id": 106,
        "Question": "6. What is the output at the serial monitor of the code below if pin 11 is given the following signal?\n<img src=\"https://www.sanfoundry.com/wp-content/uploads/2020/05/arduino-questions-answers-setting-pin-mode-q6.png\" alt=\"Find the output at the serial monitor of the code from the given diagram\" width=\"307\" height=\"68\" class=\"alignnone size-full wp-image-277947\" srcset=\"https://www.sanfoundry.com/wp-content/uploads/2020/05/arduino-questions-answers-setting-pin-mode-q6.png 307w, https://www.sanfoundry.com/wp-content/uploads/2020/05/arduino-questions-answers-setting-pin-mode-q6-300x66.png 300w\" sizes=\"(max-width: 307px) 100vw, 307px\" /><div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=11;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1, INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int ip=analogRead(pin1);</pre></li><li class=\"li1\"><pre class=\"de1\">    if(ip&gt;0) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(“H”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(“O”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 0H0H0",
            "b) OHHO",
            "c) OHHH",
            "d) HOHOO"
        ],
        "Answer": "Answer: a\nExplanation: The input signal given is of the form 01010. Therefore, according to the code, if ip is greater than 0 then ‘H’ is printed and if ip is less than 0 then ‘O’ is printed. So now we get the output as OHOHO. This is printed to the Serial Monitor with a baud rate of 9600.\n"
    },
    {
        "id": 107,
        "Question": "7.  How many errors are present in the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=12;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinmode(pin1, IN);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int value=analogRead(pin1);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(value+10);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: There are 2 errors in the code given below. They are present in line 4. In line 4 the syntax of the “pinMode()” function is wrong since the ‘M’ is not a capital letter, and while setting pin1 as an input port, we have to write the second argument of the function as “INPUT” not “IN.\n"
    },
    {
        "id": 108,
        "Question": "8. What is the output of the program given below if a 0V is put across pin 11?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin=11;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin, INPUT_PULLUP);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int a=digitalRead(pin);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(a);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 0",
            "c) 0.3",
            "d) 1.001"
        ],
        "Answer": "Answer: a\nExplanation: The reading across the pin would be given as 1 (digital HIGH) since the pinMode is set to INPUT_PULLUP which basically pulls the reading up to the maximum when there is no voltage applied across the pin, but functions as a normal input pin for reading voltage levels when some amount of voltage is applied across it.\n"
    },
    {
        "id": 109,
        "Question": "What is the difference between the INPUT and INPUT_PULLUP arguments in the pinMode() function?",
        "Options": [
            "a) They are both the same",
            "b) INPUT supports only analog voltages while INPUT_PULLUP supports only digital voltage readings",
            "c) INPUT takes the default reading as 0 while INPUT_PULLUP takes default reading as 1023",
            "d) INPUT takes the default reading as 1023 while INPUT_PULLUP takes the default reading as 0"
        ],
        "Answer": "Answer: c\nExplanation: The pinMode() function has 2 arguments; the pin number and the mode. The pin number argument takes the number of the pin as input while the mode can be set in 3 different ways, including INPUT, OUTPUT, and INPUT_PULLUP. Here the OUTPUT argument makes the pin ready for sending signals, the INPUT argument makes the pin take a voltage as input from an external source. The INPUT_PULLUP also does the same function as INPUT however only differing in the aspect of base voltage, where the INPUT argument pulls down the voltage of that port to 0V every time there is no voltage is detected across the port while the INPUT_PULLUP argument pulls up the voltage across the port to the maximum for that board whenever there is no input voltage across the port, and the reading at the port decreases with increase in voltage applied across the port.\n"
    },
    {
        "id": 110,
        "Question": "10. What is the purpose of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin=11;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin, INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int a=1023-analogRead(pin);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(a);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) To demonstrate the working of the INPUT_PULLUP argument",
            "b) To emulate the working of the OUTPUT argument",
            "c) To emulate the analogRead method",
            "d) To reset all input to 0"
        ],
        "Answer": "Answer: a\nExplanation: The code given above inverts whatever voltage reading we get from the pin by subtracting the value that is acquired from the analogRead() method, from 1023, which corresponds to the maximum voltage that can be detected at the port.\n"
    },
    {
        "id": 111,
        "Question": "How many times does the setup() function run on every startup of the Arduino System?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: The setup() function is used predominantly to configure the pins, variables, Serial data, etc. and is executed only once throughout the entire cycle of the program. However other than the above-mentioned uses, it can also be used to execute technically all aspects of an Arduino program, but since it only runs one time, it’s not very useful for anything other than configuring.\n"
    },
    {
        "id": 112,
        "Question": "Can the setup() function change the value of constant variables?",
        "Options": [
            "a) Yes, it can change",
            "b) No, it cannot change",
            "c) Yes, it can change but only integer values",
            "d) Yes, it can change but only byte values"
        ],
        "Answer": "Answer: b\nExplanation: In C/C++ Programming, once a constant is declared and initialized, its value cannot be further altered throughout the entire lifecycle of the program. Thus here the setup() function also follows through the same rule since the Arduino Programming Language is a working subset of the C++ Programming Language.\n"
    },
    {
        "id": 113,
        "Question": "Is it syntactically correct to write the loop() function over the setup() function while writing an Arduino program?",
        "Options": [
            "a) No, it is not syntactically correct",
            "b) Yes, it is syntactically correct but will result in the loop() method executing first",
            "c) Yes, it is syntactically correct and the setup() function will execute first",
            "d) It is syntactically correct but logically wrong"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino programming language is a subset of the C++ programming language, so therefore it supports a bottom-up approach and is an object-oriented programming language, making it irrelevant where the functions are declared.\n"
    },
    {
        "id": 114,
        "Question": "b.<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=11;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    digitalWrite(pin1,LOW);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int i;</pre></li><li class=\"li1\"><pre class=\"de1\">    for(i=1;i&lt;=4;i++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        if(i%2==0) {</pre></li><li class=\"li1\"><pre class=\"de1\">            digitalWrite(pin1,LOW)</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">        else {</pre></li><li class=\"li1\"><pre class=\"de1\">            digitalWrite(pin1,HIGH)</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Only a",
            "b) Only b",
            "c) Neither a nor b",
            "d) Both a and b"
        ],
        "Answer": "Answer: d\nExplanation: Both the codes will execute and give the same results. Here we needed 5 iterations of the loop to make the output possible. So in ‘a’, we did one iteration in the setup() function, which executed only once and then passed onto the loop() function where we carried out the remaining 4 iterations. And in ‘b’, we carried out all the 5 iterations in the setup() function itself. In ‘a’, we had to put up a HIGH signal with every odd value of the iteration variable, while in ‘b’, we had to put up a HIGH signal for every even value of the iteration variable.\n"
    },
    {
        "id": 115,
        "Question": "5. What is the output of the following code if the input voltage to pin1 is 0V,3.3V, 3.2V, and 5V (assuming 0V – 0, 3.2V – 492, 3.3V – 501, 5V -1023)?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=11;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    int i;</pre></li><li class=\"li1\"><pre class=\"de1\">    for(i=1;i&lt;=5;i++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        if(i%2==0) {</pre></li><li class=\"li1\"><pre class=\"de1\">            digitalWrite(pin1,HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">        else {</pre></li><li class=\"li1\"><pre class=\"de1\">            digitalWrite(pin1,LOW);</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    //Do nothing</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 0101",
            "b) 1011",
            "c) 1100",
            "d) 1111"
        ],
        "Answer": "Answer: a\nExplanation: The code sets the 2 pins as input and output ports in the setup() function. Then proceeds to set a threshold in the loop() function. According to the threshold voltages we know that Arduino maps the voltages to a positive integer set of 0 to 1023. So, we take that as a reference and create a digital signal pattern with the second pin as the output port.\n"
    },
    {
        "id": 116,
        "Question": "6. What are the errors in the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=11;</pre></li><li class=\"li1\"><pre class=\"de1\">int pin2=12;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1, INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin2, OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    if(analogRead(pin1)&gt;=500) {</pre></li><li class=\"li1\"><pre class=\"de1\">        digitalWrite(pin2,HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else {</pre></li><li class=\"li1\"><pre class=\"de1\">        digitalWrite(pin2,LOW);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: There are 3 errors in the code given above. They are present in lines 1 and 3. Here, the setup() function’s name is spelled incorrectly with a capital ‘S’, in line 3 the arguments of the analogWrite()  function are swapped, and the function’s name is again spelled incorrectly as the ‘w’ should be a capital letter.\n"
    },
    {
        "id": 117,
        "Question": "What do we need to do if we want to run the setup() function in an infinite loop?",
        "Options": [
            "a) Call the setup() function from a custom named function",
            "b) Call the setup() function from a constructor",
            "c) Call the setup() function from the loop() function",
            "d) Call the setup() function from the destructor"
        ],
        "Answer": "Answer: c\nExplanation: The setup() function is designed to run only at the startup of the Arduino code, in order to initialize and configure the setup before running the actual code. However it is theoretically possible to run the setup() function infinitely by calling it from the loop() function as illustrated below…\n\n\nint pin1=11;void setup() {    pinMode(pin1, OUTPUT);}void loop() {    setup()}\n\n\n"
    },
    {
        "id": 118,
        "Question": "8. How many times will the code run?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void Setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(‘A0’,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    analogwrite(100,’A0’);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    //Do Nothing</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 5",
            "d) 7"
        ],
        "Answer": "Answer: c\nExplanation: In the code above the setup() function is called from itself in a recursive manner. A recursion occurs when a function call statement is issued from within the scope of the same function itself then setting up a loop. It is an alternative to another looping technique called iteration.\n"
    },
    {
        "id": 119,
        "Question": "Choose the correct Combination that works.",
        "Options": [
            "a) BC",
            "b) A",
            "c) C",
            "d) B"
        ],
        "Answer": "Answer: b\nExplanation: Here the best option to use would be the iterative looping technique. This is because it has both efficient memory management and an easy to use implementation. Recursive looping can be used when there is no urgent need to consolidate and minimize memory usage for a project. However, the Goto function is generally not preferred since it is a very complex way to go about looping and is very difficult for other programmers to decipher the program after development.\n"
    },
    {
        "id": 120,
        "Question": "10. What is the signal generated by the code at ‘y’ below if the input to ‘x’ is given as 1100?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int l_var=1;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    l_var++;</pre></li><li class=\"li1\"><pre class=\"de1\">    if(l_var&lt;=5) {</pre></li><li class=\"li1\"><pre class=\"de1\">        setup()</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else {</pre></li><li class=\"li1\"><pre class=\"de1\">        //Do Nothing.</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 11",
            "b) 10",
            "c) 00",
            "d) 01"
        ],
        "Answer": "Answer: a\nExplanation: The code makes use of only the setup() function to create a signal output without relying on the loop() function or any iterative structure. It uses the “goto” function to change the flow of control of the program.\n"
    },
    {
        "id": 121,
        "Question": "How many times does the loop() function run on every startup of the Arduino System?",
        "Options": [
            "a) 1",
            "b) Depends upon the setup() function",
            "c) Infinitely till the power is supplied to the Arduino",
            "d) 3"
        ],
        "Answer": "Answer: c\nExplanation: The loop() function is generally used to carry out most of the calculations that are required to sustain the working of the Arduino project. It is preprogrammed to run continuously once the Arduino is successfully booted and the setup() function has been executed once.\n"
    },
    {
        "id": 122,
        "Question": "Can the loop() function be used to call another function that is custom defined by the programmer?",
        "Options": [
            "a) Yes, it can call",
            "b) No, it cannot call",
            "c) Yes, it can call but only functions with no return values",
            "d) Yes, it can call but only functions with return values"
        ],
        "Answer": "Answer: a\nExplanation: In C/C++ Programming, a function can call any other function whether it be the main function or any other custom defined function. In the case of the Arduino, the setup() and the loop() functions are custom predefined functions that are a part of the Arduino programming language subsystem.\n"
    },
    {
        "id": 123,
        "Question": "Is the loop() function a replacement of the main() function in the Arduino Programming Environment?",
        "Options": [
            "a) No, it is a replacement for the constructor",
            "b) Yes, it is a replacement",
            "c) Yes, but only for certain Arduino Boards",
            "d) No, it is not a replacement"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino programming language is a subset of the C++ programming language, so the main function is also present here. However during the active development of any project using the Arduino Environment we do not encounter the main function()’s use since it is prebuilt for that purpose to make the development simple, so that instead of worrying about linking the correct system functions to the main function during the development cycle of the project, the programmer only needs to worry about the actual working of his/her project.\n"
    },
    {
        "id": 124,
        "Question": "4. What is the output of the output on the Serial Monitor for the program given below if the input supplied to pin1 is of the form 0111?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=11;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    if(digitalRead(pin1)==1) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(“1 0”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(“-1 0”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) -1 0 1 1",
            "b) -1 0 0 1 0 1 0",
            "c) 1 0 1 1 0 1 1",
            "d) -1 1 1 0 1 1 0"
        ],
        "Answer": "Answer: b\nExplanation: The above code prints a 1 and a 0 for every digital HIGH signal that it receives and prints a -1 and 0 for every digital LOW that it receives. This is the premise for the method of RZ Encoding. It is used in telecommunications for sending and receiving signals.\n"
    },
    {
        "id": 125,
        "Question": "5. How many times does the code give a digital HIGH signal at pin1?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=11;</pre></li><li class=\"li1\"><pre class=\"de1\">int x=3;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    for(int i=x;i&lt;6;i++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        if(i%2==0) {</pre></li><li class=\"li1\"><pre class=\"de1\">            x=x+1;</pre></li><li class=\"li1\"><pre class=\"de1\">            loop();</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">        else {</pre></li><li class=\"li1\"><pre class=\"de1\">            digitalWrite(pin1,HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">            digitalWrite(pin1,LOW);</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: The code takes the global variable ‘x’ and sets it as the lower limit or the starting point for the for-loop. Then whenever the value of ‘x’ becomes an even number it increments the value of ‘x’ and then calls the loop() function again thus the control returns to line 7 and starts executing from there. This is an example for nested loops using both recursive and iterative methods.\n"
    },
    {
        "id": 126,
        "Question": "Can a programmer not use the loop function at all in a code?",
        "Options": [
            "a) Yes",
            "b) No",
            "c) Yes, but it needs to be called at least once",
            "d) Yes, but it needs to be commented out"
        ],
        "Answer": "Answer: a\nExplanation: The loop function is a custom predefined function that was designed to execute code over and over again for the Arduino. However if a programmer can replicate that same functionality in his/her code without the use of the loop() function then there is compulsion for him/her to include the loop() function in the program.\n"
    },
    {
        "id": 127,
        "Question": "Can the loop() function be used to replace the functionality of the setup() function?",
        "Options": [
            "a) Yes, it can",
            "b) No, it cannot",
            "c) Yes, it can, but only for certain Arduino Boards",
            "d) Yes, it can, but only for a limited time frame"
        ],
        "Answer": "Answer: a\nExplanation: Yes, the loop() function can replace the setup() function completely, theoretically, since both the loop() function and the setup() functions are custom predefined functions in the Arduino Environment. However, this would result in more work from the developer’s end since he/she would have to find a way to make configuration code run only once.\n"
    },
    {
        "id": 128,
        "Question": "8. What is the output given by the code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=11;</pre></li><li class=\"li1\"><pre class=\"de1\">int x=1;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    //Do nothing</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    if(x==1) {</pre></li><li class=\"li1\"><pre class=\"de1\">        pinMode(pin1,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    x=2;</pre></li><li class=\"li1\"><pre class=\"de1\">    digitalWrite(pin1,HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">    digitalWrite(pin1,LOW);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Infinite Series of 010101…",
            "b) Finite Series of 11111….",
            "c) Finite Series of 0000…",
            "d) Infinite Series of 1010101…."
        ],
        "Answer": "Answer: d\nExplanation: The code above does the process of configuration of pin1 in within the loop() function itself without using the setup() function for anything. It then proceeds to generate a digital HIGH signal followed by a digital LOW signal continuously.\n"
    },
    {
        "id": 129,
        "Question": "How to make the loop function run only once but the code inside run infinitely?",
        "Options": [
            "a) Create a recursive function call statement",
            "b) Create a nested infinite loop within the loop() function",
            "c) Call the setup() function from the loop() function",
            "d) Call the loop() function from the setup() function"
        ],
        "Answer": "Answer: b\nExplanation: Yes, it is possible to make the loop() function execute only once while running the code infinitely. This can be done by using an infinite loop within the loop() function so that the code never goes out of the loop and thus never allowing the loop() function to iterate.\n"
    },
    {
        "id": 130,
        "Question": "Can the loop() function be called recursively?",
        "Options": [
            "a) Yes, it can be called recursively",
            "b) No, it cannot be called recursively",
            "c) Yes, it can be called recursively but only by the setup() function",
            "d) Yes, it can be called recursively but only twice"
        ],
        "Answer": "Answer: a\nExplanation: The Arduino Programming Language is a working subsystem of the C++ Programming Language. This allows for any function to be called recursively at any point in the program. Since the loop() function is a custom predefined function in the Arduino Ecosystem, it too has to follow that rule.\n"
    },
    {
        "id": 131,
        "Question": "How many voltage levels are present when a pin uses digitalWrite()?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: The digitalWrite() function can be used to send out two voltage levels; 0V and 5V which correspond to the digital LOW signal and the digital HIGH signal respectively. These voltage levels can however vary from board to board. For example, in some Arduino Boards the digital HIGH signal corresponds to 3.3V instead of 5V. Hence even if the voltage levels are different here, the meaning of the signal remains the same.\n"
    },
    {
        "id": 132,
        "Question": "Can the digitalRead() function identify analog voltages?",
        "Options": [
            "a) Yes, it can",
            "b) No, it cannot",
            "c) Yes, it can but only 2",
            "d) Yes, it can but only 4"
        ],
        "Answer": "Answer: c\nExplanation: The digitalRead() function is used to receive digital signals as input through the port and then process the data further. However, it can only distinguish between 5V (3.3V for some Arduino Boards) and 0V which correspond to the digital HIGH and the digital LOW signals respectively.\n"
    },
    {
        "id": 133,
        "Question": "Can the digitalWrite() function be used from any analog pin?",
        "Options": [
            "a) No, it cannot",
            "b) Yes, it can, but only on certain Arduino Boards",
            "c) Yes, it can",
            "d) Yes, it can, but only through certain pins"
        ],
        "Answer": "Answer: b\nExplanation: The pins in the Arduino Boards are all digital by default. The analog functionality is an addon to the board with the help of an ADC (Analog to Digital Convertor) Circuit, or a DAC (Digital to Analog Convertor) Circuit. Thus, all analog pins support digital IO but not all digital pins support analog IO. However, this is an exception in the Arduino Nano, Mini and Pro Mini.\n"
    },
    {
        "id": 134,
        "Question": "4. How many errors are present in the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">\tint i=10;</pre></li><li class=\"li1\"><pre class=\"de1\">\tvoid setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">\t\tpinMode(i,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">\t\tdigitalwrite(HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">\t}</pre></li><li class=\"li1\"><pre class=\"de1\">\tvoid loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">\t\t//Do Nothing.</pre></li><li class=\"li1\"><pre class=\"de1\">\t}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: The above code is wrong in two places, in line 4. Here the name of the digitalWrite() function should be spelled with a capital ‘W’, and the function takes two arguments, not one. They are pin number and state. In the code above, only the state is mentioned with no mention of the pin number.\n"
    },
    {
        "id": 135,
        "Question": "How many arguments does the digitalRead() function have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: The digitalRead() function is used to take digital signal inputs to the Arduino. It requires 1 argument; the pin number which would indicate which pin is to be used for that particular operation. This will make the Arduino to start reading voltage fluctuations of the order of 0V and 5V.\n"
    },
    {
        "id": 136,
        "Question": "Can the analogRead() function be used as a replacement for the digitalRead() function?",
        "Options": [
            "a) No, it cannot be used",
            "b) Yes, it can be used but only on certain Arduino Boards",
            "c) Yes, it can be used",
            "d) Yes, it can be used but only for certain pins"
        ],
        "Answer": "Answer: c\nExplanation: The digitalRead() function basically reads voltage differences of 0V and 5V which correspond to 0 and 1023, in the Arduino  Ecosystem. This can be recreated using the analogRead() function to check whether there is a voltage across the pin that corresponds to 0 and 1023 on the Arduino.\n"
    },
    {
        "id": 137,
        "Question": "What is the need for a quantizer in Digital Communications?",
        "Options": [
            "a) Break up a sampled signal to a finite dataset",
            "b) Sample a pure analog signal",
            "c) Sample a digital signal",
            "d) Encode an analog signal"
        ],
        "Answer": "Answer: a\nExplanation: The ADC (Analog to Digital Convertor) Circuit converts the pure analog signal to a digitized signal with discrete voltage points. However, in order to be able to perform further complicated computations on the data, we need to convert the discrete signal into a set of finite data points. This is done by mapping the values to a set of positive real integers.\n"
    },
    {
        "id": 138,
        "Question": "Which of the following is not a Digital Encoding Technique?",
        "Options": [
            "a) NRZ (Non-Return to Zero)",
            "b) Amplitude Modulation",
            "c) Manchester",
            "d) RZ (Return to Zero)"
        ],
        "Answer": "Answer: b\nExplanation: Any digital signal can be defined as a series of 1’s and 0’s. These series may or may not be in a predefined pattern. This can make it very difficult for the receiver to be able to decipher the signal. Thus, the digital coding techniques involve mostly converting a random pattern of 1’s and 0’s into a predefined pattern of a signal which the receiver can decipher easily. Here Amplitude Modulation Technique is an analog modulation technique.\n"
    },
    {
        "id": 139,
        "Question": "Which of the following is not a method to convert analog signals to digital signals?",
        "Options": [
            "a) Pulse Code Modulation",
            "b) Pulse Amplitude Modulation",
            "c) Pulse Width Modulation",
            "d) Frequency Modulation"
        ],
        "Answer": "Answer: d\nExplanation: Any Modulation Technique that converts an analog signal to a digital signal is of immense importance in pure digital circuits like the Arduino. These help the Arduino’s circuit to receive raw unmodulated signals from the outside and process them in a digital environment. Here frequency modulation is the only modulation technique that only works with analog-to-analog signal modulation.\n"
    },
    {
        "id": 140,
        "Question": "What is the numeric base of the math operations performed in binary?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: All binary numbers have a base of 2. This means that this number system has only 2 digits which are 0 and 1. The base of a number system is the number of unique characters or digits that are used for representing numbers.0\n"
    },
    {
        "id": 141,
        "Question": "What type of signal does the analogWrite() function output?",
        "Options": [
            "a) Pulse Width Modulated Signal",
            "b) Pulse Code Modulated Signal",
            "c) Pulse Amplitude Modulated Signal",
            "d) Frequency Modulated Signal"
        ],
        "Answer": "Answer: a\nExplanation: The Pulse Width Modulated Signal is the one which is transmitted by the analogWrite() function. This is done in an attempt to replicate the analog functionality to control certain sensors and actuators.\n"
    },
    {
        "id": 142,
        "Question": "What is the resolution of analog readings on the Arduino Uno?",
        "Options": [
            "a) 5V/1023",
            "b) 3.3V/1024",
            "c) 5V/1024",
            "d) 3.3V/100"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino converts all analog voltages (0V to 5V or 3.3V) taken as input into a range of 0 to 1023. This is done by mapping the voltage levels. On the Arduino Uno the maximum voltage level is 5V and the onboard ADC has a resolution of 10 bits which means it can divide the analog signal it receives into 210 levels.\n"
    },
    {
        "id": 143,
        "Question": "Can the analogRead() function be used from any digital pin?",
        "Options": [
            "a) No, it cannot",
            "b) Yes, it can, but only on certain Arduino Boards",
            "c) Yes, it can",
            "d) Yes, it can, but only through certain pins"
        ],
        "Answer": "Answer: d\nExplanation: The pins in the Arduino Boards are all digital by default. The analog functionality is an addon to the board with the help of an ADC (Analog to Digital Convertor) Circuit which is only connected to a certain number of digital pins, so therefore not all pins can support analog communications.\n"
    },
    {
        "id": 144,
        "Question": "4. What is the output of the program if the input to pin1 is 3.3V on the Arduino Due?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=A0;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    if(analogRead(pin1)==1023) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(“Digital HIGH Detected!”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(“Digital LOW Detected!”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Digital HIGH Detected!",
            "b) Digital LOW Detected!",
            "c) Runtime Error",
            "d) Null"
        ],
        "Answer": "Answer: a\nExplanation: The above code takes an input and then classifies the voltage level into two levels; 0 and 1023. This virtually forces the user to send a 3.3V signal to the Arduino Due to get a “Digital HIGH Detected!” Message and vice versa.\n"
    },
    {
        "id": 145,
        "Question": "How many arguments does the analogRead() function have?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: The analogRead() function is used to take analog signal inputs to the Arduino. It requires 1 argument; the pin number which would indicate which pin is to be used for that particular operation. This will make the Arduino to start reading voltage fluctuations of the order of 0V to 5V or 3.3V for some Arduino Boards.\n"
    },
    {
        "id": 146,
        "Question": "6. What is the purpose of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=A1;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    analogReadResolution(10);</pre></li><li class=\"li1\"><pre class=\"de1\">    int a=analogRead(pin1);</pre></li><li class=\"li1\"><pre class=\"de1\">    analogReadResolution(8);</pre></li><li class=\"li1\"><pre class=\"de1\">    int b=analogRead(pin1);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(a);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(b);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) To demonstrate different resolution settings of the ADC",
            "b) To demonstrate different resolution settings of the DAC",
            "c) To convert a digital input to an analog signal",
            "d) To convert an analog input to a digital signal"
        ],
        "Answer": "Answer: a\nExplanation: The analogReadResolution() function changes the resolution of the ADC (Analog to Digital Convertor) present onboard the Arduino. This will change the value that is mapped to the same voltage level for different levels of resolution.\n"
    },
    {
        "id": 147,
        "Question": "What is the use of the analogReference() function?",
        "Options": [
            "a) To change the digital signal reference value",
            "b) To change the analog signal reference value",
            "c) To print the analog signal reference voltage",
            "d) To print the digital signal reference voltage"
        ],
        "Answer": "Answer: b\nExplanation: The analogReference() function changes the value of the internal reference voltage for all analog calculations in the Arduino Board. For the function to work properly we need to supply the desired voltage level to the AREF pin on the Arduino Board physically before invoking the function. However, any voltage greater than 5V is not recommended since it can damage the board.\n"
    },
    {
        "id": 148,
        "Question": "8. How many errors are present in the code given below if it is made to run on an Arduino Uno?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin();</pre></li><li class=\"li1\"><pre class=\"de1\">    analogReference(AR_DEFAULT);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    //Do nothing.</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: In the code above there are 2 errors in lines 2 and 3. The first one is that the Serial.begin() function is given no baud-rate as input. The second one is that the AR_DEFAULT argument only works for Arduino SAMD Boards like the Arduino Zero and not the Arduino AVR Based Boards like the Arduino Uno on which the above code is to be executed.\n"
    },
    {
        "id": 149,
        "Question": "On which of the following Arduino Boards does the analogReadResolution() function not work?",
        "Options": [
            "a) Arduino Zero",
            "b) Arduino MKR Vidor 4000",
            "c) Arduino Due",
            "d) Arduino Uno"
        ],
        "Answer": "Answer: d\nExplanation: The analogReadResolution() function is used to change the resolution of the ADC for reading a particular voltage and mapping it to the number set. The resolution of the ADC is the number of levels up to which the ADC can quantize the analog Signal. The Arduino Uno is not capable of executing that command.\n"
    },
    {
        "id": 150,
        "Question": "What happens to the output if the analogReadResolution() function is invoked with a resolution higher than the board’s ADC can physically handle?",
        "Options": [
            "a) The output is padded with zeros",
            "b) The output is not obtained as an error is thrown during compile time",
            "c) The output is not obtained as an error is thrown during run time",
            "d) The output is padded with ones"
        ],
        "Answer": "Answer: a\nExplanation: If the value passed as an argument to the analogReadResolution() function is higher than the physical capability of that particular board’s ADC, then the output is padded with zeros so as to enable other boards equipped with ADC’s having higher resolutions can process the data.\n"
    },
    {
        "id": 151,
        "Question": "What is the maximum number of arguments that the pulseIn() function accepts?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: The pulseIn() function is used to determine the length of a pulse supplied to a digital pin. It generally accepts two arguments; the pin number, and the state, i.e. HIGH or LOW. If the state is given as HIGH, then it will wait for the pin to go HIGH and then start counting the time till the pin returns back to LOW. Here the length of the pulse is given by the function in microseconds.\n"
    },
    {
        "id": 152,
        "Question": "2. What is the purpose of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=10;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(pulseInLong(pin1,HIGH));</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) To count the number of pulses",
            "b) To count the voltage fluctuations in pin1",
            "c) To count the duration of a single pulse",
            "d) To count the total number of pulses supplied"
        ],
        "Answer": "Answer: c\nExplanation: The pulseInLong() function is similar to the pulseIn() function wherein it is used to count the duration of a pulse. However the only difference is that the pulseIn() function is not very accurate when counting pulses of very large durations, so we used the pulseInLong() function to do the job.\n"
    },
    {
        "id": 153,
        "Question": "What is the purpose of the tone() function?",
        "Options": [
            "a) To generate a sine wave",
            "b) To generate a cosine wave",
            "c) To generate a stable voltage level",
            "d) To generate a square wave"
        ],
        "Answer": "Answer: d\nExplanation: The tone() function is used to generate a square wave of 50% duty cycle. It accepts a maximum of 3 arguments; the pin number, the frequency, and the duration of the wave. If no duration is specified then the wave is continued to be generated until the noTone() function is invoked within the code.\n"
    },
    {
        "id": 154,
        "Question": "What is the use of the MSBFIRST argument in the shiftIn() function?",
        "Options": [
            "a) To denote the least significant bit",
            "b) To denote the maximum number of Bits",
            "c) To denote the most significant bit",
            "d) To denote the minimum number of bits"
        ],
        "Answer": "Answer: c\nExplanation: The shiftIn() function shifts in one byte of a binary number bit by bit starting from either the most significant bit or the least significant bit. Now after each bit is pulled, the clock pin is turned to HIGH until the next one at which point the clock pin is turned down to LOW again. Now the MSBFIRST argument denotes that the byte of data be read from left to right.\n"
    },
    {
        "id": 155,
        "Question": "5. What is the output of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=10;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    tone(pin1,400);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Finite Square Wave",
            "b) Infinite Sine Wave",
            "c) Infinite Square Wave",
            "d) Infinite Cosine Wave"
        ],
        "Answer": "Answer: c\nExplanation: The code above sets pin1 as the output pin and generates an infinite square wave of frequency 400Hz at pin1. This is done using the tone() function. Here, since no timeout is mentioned the wave will be generated continuously until the Arduino’s power supply is turned off, or another code is compiled and uploaded to it.\n"
    },
    {
        "id": 156,
        "Question": "Can the tone() and noTone() functions be used for digital communications?",
        "Options": [
            "a) No, they cannot be used",
            "b) Yes, they can be used but only on certain Arduino Boards",
            "c) Yes, they can be used for all digital pins and Arduino Boards",
            "d) Yes, they can be used but only for certain pins"
        ],
        "Answer": "Answer: c\nExplanation: The tone() function generates a square wave at a constant 50% duty cycle and a specified frequency. So, if a communication is to be established between two devices on this basis, the receiver only has to record the different frequencies of the square waves and map them to a certain set of finite predefined integers in order to obtain some meaningful data from the transmission.\n"
    },
    {
        "id": 157,
        "Question": "How many tone() functions can be invoked to run simultaneously on an Arduino Board?",
        "Options": [
            "a) As many pins are present",
            "b) Infinite number",
            "c) Only one",
            "d) Depending on the number of timers present"
        ],
        "Answer": "Answer: c\nExplanation: The tone() function uses the Arduino’s built in timer to generate the square wave of the necessary frequency. So the number of tone() invokes a board can handle depends upon the number of timers present on that board.\n"
    },
    {
        "id": 158,
        "Question": "How many arguments does the shiftOut() function require?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: d\nExplanation: The shiftOut() function requires 4 arguments; the pin number to which the bit of data is to be sent, the toggle-pin which is to be turned HIGH or LOW once the data is done transferring, the order in which the bits are to be read (MSBFIRST or LSBFIRST), and the actual data who’s bits are to be shifted out.\n"
    },
    {
        "id": 159,
        "Question": "What is the return type for the shiftOut() function?",
        "Options": [
            "a) double",
            "b) null",
            "c) long",
            "d) int"
        ],
        "Answer": "Answer: b\nExplanation: The shiftOut() function takes a byte of data as input and shifts the data bit by bit out to an output pin by either moving from left to right or vice versa. So, it does provide us an output, however that output is directly updated to the pin, and not sent back as a return value.\n"
    },
    {
        "id": 160,
        "Question": "What is the return type of the pulseIn() function?",
        "Options": [
            "a) null",
            "b) signed byte",
            "c) unsigned long",
            "d) unsigned int"
        ],
        "Answer": "Answer: c\nExplanation: The job of the pulseIn() function is to calculate the time difference (in microseconds) between two digital pulses. It gives the value as output in the form of an unsigned long variable. This is done so as to improve the accuracy of the function when measuring the time gap.\n"
    },
    {
        "id": 161,
        "Question": "What is the name for the library to manipulate data in and out of the EEPROM of the Arduino Board?",
        "Options": [
            "a) EEPROM.h",
            "b) eeprom.h",
            "c) Eeprom.h",
            "d) eepROM.h"
        ],
        "Answer": "Answer: a\nExplanation: The EEPROM is a type of memory in microcontrollers that is able to retain the data that was fed to it even after the power supply is cut off from the chip.The EEPROM.h library allows us to perform read, write, clear, updating, etc. operations on the EEPROM of our Arduino Board. This is a standard library that can be used for all Arduino Boards.\n"
    },
    {
        "id": 162,
        "Question": "2. What is the objective of the code given below if it is executed on the Arduino Uno?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">#include&lt;EEPROM.h&gt;</pre></li><li class=\"li1\"><pre class=\"de1\">int pin=13;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    for(int i=0;i&lt;EEPROM.length();i++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        EEPROM.write(i, 1);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    digitalWrite(pin,HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">    exit(0);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Fill EEPROM with 1’s",
            "b) Fill EEPROM with 0’s",
            "c) Clear EEPROM",
            "d) Export EEPROM data"
        ],
        "Answer": "Answer: a\nExplanation: The EEPROM.write() function is used to write data to the EEPROM directly. This function takes in 2 argurments; the address to which the data is to be written, and the data which is to be written to the EEPROM in the specified address. The program fills the EEPROM with 1’s and then turns on the onboard LED of the Arduino Uno.\n"
    },
    {
        "id": 163,
        "Question": "Which of the following statements is not true when dealing with the Firmata library?",
        "Options": [
            "a) The Firmata Library is used to establish communications between the Arduino and the Desktop",
            "b) The Firmata Library uses the Firmata Protocol for communicating data",
            "c) The Firmata Library uses the Midi Message Format",
            "d) The Firmata Library can only be used on an Arduino Uno"
        ],
        "Answer": "Answer: d\nExplanation: The Firmata Library is used for communicating data to and from the computer. This is required when the Arduino is required to store certain data on the computer which would be otherwise too large for the Arduino to store in its internal memory. Other uses of this library are in the field of IOT.\n"
    },
    {
        "id": 164,
        "Question": "Which of these devices are supported by the Wire Library?",
        "Options": [
            "a) I2C Bus",
            "b) Wi-Fi Devices",
            "c) Bluetooth Devices",
            "d) Cellular Devices"
        ],
        "Answer": "Answer: a\nExplanation: The Wire Library is used to communicate data with the I2C (Inter IC) or TWI (Two Wire Interface) Bus which are almost identical to each other and are used for communicating data to different microcontrollers.\n"
    },
    {
        "id": 165,
        "Question": "What is the use of the Ethernet library?",
        "Options": [
            "a) To connect the Arduino to Bluetooth",
            "b) To connect the Arduino to Wi-Fi",
            "c) To connect the Arduino to Li-Fi",
            "d) To connect the Arduino to Ethernet"
        ],
        "Answer": "Answer: d\nExplanation: The Ethernet Library is used to connect the Arduino to the internet via an Ethernet connection. This library is designed to be used with any Arduino Ethernet Shields or any other W5100, W5200, etc. based devices.\n"
    },
    {
        "id": 166,
        "Question": "If one would want to place a call using an Arduino which library would one use which was specifically designed for that purpose?",
        "Options": [
            "a) The Firmata Library",
            "b) The TFT Library",
            "c) The GSM Library",
            "d) The Ethernet Library"
        ],
        "Answer": "Answer: c\nExplanation: The GSM library on the Arduino helps the user to perform call, SMS, or even Internet Communications via the GSM Module. This library works in conjunction with the GSM Shield which uses a modem and AT commands to connect the Arduino to the GSM network.\n"
    },
    {
        "id": 167,
        "Question": "What is the use of the SD.h Library in Arduino?",
        "Options": [
            "a) To communicate with the SD Card Module",
            "b) To communicate with another microcontroller",
            "c) To communicate with the computer",
            "d) To communicate with the internet"
        ],
        "Answer": "Answer: a\nExplanation: The SD.h Library in Arduino allows for communications between the Arduino Board and an SD Card Module for storage and retrieval of data. It is dependent on the sdfatlib library which works on FAT16 and FAT32 filesystems.\n"
    },
    {
        "id": 168,
        "Question": "Which interface does SD.h depend on for communication between the SD Card Module and the Arduino?",
        "Options": [
            "a) SPI",
            "b) I2C",
            "c) USB",
            "d) TTL"
        ],
        "Answer": "Answer: a\nExplanation: The SD.h library for communication between SD Card Modules and Arduinos use SPI (Serial Peripheral Interface) for establishing communications. The SPI is a synchronous Serial Communication Protocol which is used for short distance communications between microcontrollers and devices like SD Card Readers, shift resistors, etc.\n"
    },
    {
        "id": 169,
        "Question": "What is the library to be used if one wants to use UART communications on an Arduino?",
        "Options": [
            "a) TFT Library",
            "b) SoftwareSerial Library",
            "c) Ethernet Library",
            "d) I2C Library"
        ],
        "Answer": "Answer: b\nExplanation: The UART (Universal Asynchronous Receiver Transmitter) is a piece of hardware that allows digital communications between 2 IC’s. The pins on the Arduino that support this are 0 and 1. This functionality is parallel in nature, i.e. the Atmega chip on the Arduino can receive UART data and continue to work on whatever it was working on, at the same time.\n"
    },
    {
        "id": 170,
        "Question": "Which chipset is the LCD library for Arduino based on?",
        "Options": [
            "a) Hitachi HD44780",
            "b) Hitachi HD45780",
            "c) Hitachi HDD4780",
            "d) Hitachi HD46780"
        ],
        "Answer": "Answer: a\nExplanation: The LCD Library in Arduino allows for controlling LCD Displays with the Arduino. This is based on the Hitachi HD44780 Chipset which is a dot matrix LCD (Liquid Crystal Display) Driver. It can be configured and used with 4-bit and 8-bit microcontrollers.\n"
    },
    {
        "id": 171,
        "Question": "What library is to be required for manipulating audio on the Arduino Due?",
        "Options": [
            "a) AudioMan.h",
            "b) PulseAudio.h",
            "c) Audio.h",
            "d) Sound.h"
        ],
        "Answer": "Answer: c\nExplanation: The Arduino Due uses the Audio.h library for manipulation of sounds. It allows the Arduino Due to use the DAC0 and DAC1 pins to open .wav audio files from a source. Most of the time this library is used with the SD.h standard library to enable the Arduino Due to be able to read audio files from SD Cards.\n"
    },
    {
        "id": 172,
        "Question": "Which of the following Arduino Boards does the USBHost Library work on?",
        "Options": [
            "a) Arduino Nano",
            "b) Arduino Due",
            "c) Arduino Uno",
            "d) Arduino Micro"
        ],
        "Answer": "Answer: b\nExplanation: The USBHost Library was developed for the Arduino Due. This library allows the Arduino Due to appear as a USB Host and connect to external peripherals like the mouse and keyboard. However this does not include device connected through USB Hubs.\n"
    },
    {
        "id": 173,
        "Question": "What is the function of the Scheduler Library?",
        "Options": [
            "a) To allow queueing of functions",
            "b) To allow for cancelling of functions",
            "c) To allow for parallel execution of functions",
            "d) To allow for serial initialization of functions"
        ],
        "Answer": "Answer: c\nExplanation: The Scheduler Library works only on the Arduino Zero, Due, etc. and other Arduino Boards having SAM and SAMD architectures. It allows for parallel running of functions without using interrupt. It allows the CPU to switch seamlessly between tasks.\n"
    },
    {
        "id": 174,
        "Question": "Which Arduino Board Architectures can the Audio Frequency Meter Library work on?",
        "Options": [
            "a) SAM Architecture",
            "b) Intel Architecture",
            "c) SAMD Architecture",
            "d) ARM Architecture"
        ],
        "Answer": "Answer: c\nExplanation: The Audio Frequency Meter Library only works on Arduino Boards having the SAMD Architecture, including the Arduino Zero, MKRZero, etc. It allows for the sampling of an analog signal and finding out it’s frequency. Any analog pin is supported for this operation.\n"
    },
    {
        "id": 175,
        "Question": "Which library allows for manipulating the real time clock of an Arduino?",
        "Options": [
            "a) RTC Library",
            "b) RT Library",
            "c) Clock Library",
            "d) Time Library"
        ],
        "Answer": "Answer: a\nExplanation: This library works on Arduino Boards that have the SAMD Architecture, including the Arduino Zero, MKRZero, etc. It allows for manipulating the Internal Real Time Clock of the Arduino. The Real Time Clock maintains the current time related information and can also be used for scheduling programs.\n"
    },
    {
        "id": 176,
        "Question": "Which Arduino Board does the SigFox Library work with?",
        "Options": [
            "a) Arduino MKR1000",
            "b) Arduino MKRFOX1200",
            "c) Arduino MKRZero",
            "d) Arduino MKRFOX1230"
        ],
        "Answer": "Answer: b\nExplanation: The SigFox Library allows the use of the SigFox transreceiver with the Arduino MKRFOX1200 Board. It uses UNB (Ultra Narrow Band) to interconnect remote devices. It’s a low energy device which falls in the category of LPWAN (Low Powered Wide Area Network).\n"
    },
    {
        "id": 177,
        "Question": "7.  What is the use of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">#include&lt;Esplora.h&gt;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int v=Esplora.readSlider();</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(v);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Read Potentiometer Value",
            "b) Read Resistor Value",
            "c) Read Transistor Voltage Value",
            "d) Read Power Supply Voltage"
        ],
        "Answer": "Answer: a\nExplanation: This library reads the value of the linear potentiometer on the Arduino Esplora as a 10-bit number. This is generated in the form of a voltage level from 0 to 5V and is then mapped to a number set ranging from 0 to 1023.\n"
    },
    {
        "id": 178,
        "Question": "What purpose does the Bridge Library serve on the Arduino Yun?",
        "Options": [
            "a) Connecting the Linux processor and the microcontroller onboard the Yun",
            "b) Disconnecting the Linux processor and the microcontroller onboard the Yun",
            "c) Making the Linux Processor the master device and the microcontroller, the slave device",
            "d) Making the Linux Processor the slave device and the microcontroller, the master device"
        ],
        "Answer": "Answer: a\nExplanation: The Arduino Yun has two processors onboard; the Atheros 9331 which is a processor that runs Linux and the Atmega32U4 which is a microcontroller. The job of the Bridge Library’s job is to connect these two devices and enable communication between them.\n"
    },
    {
        "id": 179,
        "Question": "What is the purpose of the MKRNB Library?",
        "Options": [
            "a) Connecting to the internet over GSM",
            "b) Connecting to the internet over Ethernet",
            "c) Connecting to the internet over Wi-Fi",
            "d) Connecting to the internet over LAN"
        ],
        "Answer": "Answer: a\nExplanation: The MKRNB Library runs on the Arduino MKR NB 1500 and helps in connecting the board to the internet via GSM. The board consists of a modem that takes the data from the serial port of the board and then sends it to the internet via the GSM Network with the help of AT commands.\n"
    },
    {
        "id": 180,
        "Question": "Which of the following boards does the WifiNINA Library work on?",
        "Options": [
            "a) Arduino MKR 1010",
            "b) Arduino Due",
            "c) Arduino MKR VIDOR 3000",
            "d) Arduino Micro"
        ],
        "Answer": "Answer: a\nExplanation: The library enables the Wi-Fi capabilities of the Arduino MKR 1010 Board. It can be also used as a server to accept incoming connections and even send outgoing requests. It also supports WEP and WPA2 Encryption Systems.\n"
    },
    {
        "id": 181,
        "Question": "How many RX-TX pairs of pins are present in the Arduino Mega?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino Mega has 3 RX-TX pairs; 0&1, 19&18, 17&16 and 15&14. The Serial pins are used for establishing and maintaining communications between the computer and the Arduino. However, once any of these RX-TX pairs are setup for serial communications, during the course of the program they cannot be used for GPIO.\n"
    },
    {
        "id": 182,
        "Question": "What is the full form of UART?",
        "Options": [
            "a) Universal Asynchronous Receiver/Transmitter",
            "b) Universal Anti-Rectifying Transmitter",
            "c) Universal Asynchronous Radio Transmitter",
            "d) Universal Asynchronous Rectifier Transistor"
        ],
        "Answer": "Answer: a\nExplanation: The UART architecture is a very important part of Serial Communications. It is not a protocol like the I2C or SPI, but a physical circuit configuration. Serial communication uses the UART architecture to send and receive the data serially from the computer.\n"
    },
    {
        "id": 183,
        "Question": "In Serial Communications, how many sections is a data packet divided into?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: d\nExplanation: The data packet is divided into 4 sections. The first section being the start bit which is usually 1. After that comes the data frame which holds the data which can range from being 5-bits to 9-bits. The section after the data section comes the parity section which denotes whether the number of bits in the data packet is odd or even. The final section is the stop-bit. This section can hold upto 2 bits and is used to indicate the end of the data packet.\n"
    },
    {
        "id": 184,
        "Question": "5. What is the purpose of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Seria.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.write(40);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Send a byte with value 40 through the Serial pins",
            "b) Send a signal to pin 40 on the Arduino board",
            "c) Send a hexadecimal number of 40 through the Serial pins",
            "d) Send a octal number of 40 through the Serial pins"
        ],
        "Answer": "Answer: b\nExplanation: UART stands for Universal Asynchronous Receiver/Transmitter. This means all communication here is not governed by the presence of a clock unlike the I2C and the SPI protocol which require an extra pin for performing serial communications.\n"
    },
    {
        "id": 185,
        "Question": "What is the function in Arduino that is capable of reading Strings from a stream and store the acquired value into a String?",
        "Options": [
            "a) Stream.readstring()",
            "b) Stream.stringread()",
            "c) Stream.readString()",
            "d) Stream.readfromstring()"
        ],
        "Answer": "Answer: a\nExplanation: The above code uses the serial pins on the Arduino Board. The data is sent in the form of a byte whose value is 40. This data is processed into a data packet where the additional sections are added to number 40 and then send using UART.\n"
    },
    {
        "id": 186,
        "Question": "What is the function of the readBytesUntil() function?",
        "Options": [
            "a) Reads only integers from a stream",
            "b) Reads any characters from a stream",
            "c) Reads only special characters from a stream",
            "d) Tokenizes a string from a stream"
        ],
        "Answer": "Answer: c\nExplanation: The Stream.readString() is a function that belongs to the Stream class. It’s capable of reading any String from a stream and then store the output into a String. This function can also be called from the Wire class. There is a timeout for this reading which is defined by the setTimeout() function.\n"
    },
    {
        "id": 187,
        "Question": "What is the maximum number of arguments does the find() function accept?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: The readBytesUntil() function belongs to the Stream class. It is used for reading any characters from a stream. The function continues to read characters entered until the termination character is found. It then puts all the collected data into a buffer.\n"
    },
    {
        "id": 188,
        "Question": "How many parameters does the flush() function accept?",
        "Options": [
            "a) 0",
            "b) 1",
            "c) 2",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: The find() function accepts a maximum of 2 parameters; the target which can be a set of characters, and the length of the target which denotes the lexical length of the target. This function then searches for the target throughout the stream and returns a Boolean True if a match is found, otherwise a Boolean False if the target is not found.\n"
    },
    {
        "id": 189,
        "Question": "What is the default time limit that is set automatically if no value is passed as the limit to the setTimeout() function?",
        "Options": [
            "a) 100 milliseconds",
            "b) 1500 milliseconds",
            "c) 1000 milliseconds",
            "d) 2432 milliseconds"
        ],
        "Answer": "Answer: a\nExplanation: The flush() function is a member of the stream class. The function exists to clear every character that is stored in the buffer. It accepts no arguments since it clears the entire buffer unconditionally on being invoked, so no parameters are required to carry out this operation.\n"
    },
    {
        "id": 190,
        "Question": "1. What is the output of the following program if ‘a’ and ‘b’ are both supplied with 5V?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int a=9;</pre></li><li class=\"li1\"><pre class=\"de1\">int b=10;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(a,INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(b,INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int x=digitalRead(a);</pre></li><li class=\"li1\"><pre class=\"de1\">    int y=digitalRead(b);</pre></li><li class=\"li1\"><pre class=\"de1\">    if(a!=b){</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(“Not Equal”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(“Equal”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Equal",
            "b) Not Equal",
            "c) Runtime Error",
            "d) Compilation Error"
        ],
        "Answer": "Answer: a\nExplanation: In the program above, we use a simple Boolean operator to demonstrate the “not equal to” operator. Since values of ‘x’ and ‘y’ are exactly 1 as stored by the Arduino, the ‘else’ case of the program runs and prints the output to the Serial Monitor.\n"
    },
    {
        "id": 191,
        "Question": "What is the difference between ternary operators and unary operators?",
        "Options": [
            "a) Ternary Operators work with 1 operand while unary operators work with 3 operands",
            "b) Ternary Operators work with 3 operands while unary operators work with 1 operand",
            "c) Ternary Operators work with 2 operands while unary operators work with 3 operands",
            "d) Ternary Operators work with 4 operands while unary operators work with 1 operand"
        ],
        "Answer": "Answer: b\nExplanation: The term “ternary” depicts three and the term “unary” depicts the term one. So therefore, ternary operators need 3 operands and unary operators use 1 operand.\nEg:-\n\n\nint a=10, b=20, c;c=(a<b)?a:b;\n\n\nThe above code will make c=10 since ‘a’ is lesser than ‘b’.\n\n\n        \n\na++;\n\n\nThe above code will increment the value of ‘a’ by 1.\n"
    },
    {
        "id": 192,
        "Question": "3. What will be the output of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int a=92;</pre></li><li class=\"li1\"><pre class=\"de1\">    int b=101;</pre></li><li class=\"li1\"><pre class=\"de1\">    int c=a&amp;b;</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(c);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 100",
            "b) 69",
            "c) 68",
            "d) 40"
        ],
        "Answer": "Answer: c\nExplanation: The above code uses the ‘&’ symbol to perform a bitwise AND operation on ‘a’ and ‘b’ which serve as the operands. It performs an AND operation on each bit starting from the most significant bit to the least significant bit. The resulting binary number is then converted to int and then printed on the serial monitor.\n"
    },
    {
        "id": 193,
        "Question": "4. What is the output of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int *pointer;</pre></li><li class=\"li1\"><pre class=\"de1\">    int val=100;</pre></li><li class=\"li1\"><pre class=\"de1\">    pointer=&amp;val;</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(*pointer);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 100",
            "b) 2e444ad233",
            "c) cc10091a2",
            "d) a99102123"
        ],
        "Answer": "Answer: a\nExplanation: The above code plays around with a feature called pointers. In line 5 we create a pointer to an integer datatype. Then in the next line we initialize a variable with a value. Then we store the address of that variable to the pointer. And finally, we access the value of the pointer using the “*” operator.\n"
    },
    {
        "id": 194,
        "Question": "What is the name of the | operator?",
        "Options": [
            "a) Logical OR",
            "b) Bitwise OR",
            "c) Logical AND",
            "d) Bitwise AND"
        ],
        "Answer": "Answer: b\nExplanation: The ‘|’ operator is used to perform a bitwise OR operation on any two numbers which serve as the operands. It performs an OR operation on each bit starting from the most significant bit to the least significant bit.\n"
    },
    {
        "id": 195,
        "Question": "What is the name of the ~ operator?",
        "Options": [
            "a) Bitwise NOT",
            "b) Logical NOT",
            "c) Bitwise SHIFT",
            "d) Pointer Address"
        ],
        "Answer": "Answer: a\nExplanation: The ~ operator is used to perform a bitwise NOT operation on any two numbers which serve as the operands. It performs a NOT operation on each bit starting from the most significant bit to the least significant bit.\n"
    },
    {
        "id": 196,
        "Question": "What is the name of the ^ operator?",
        "Options": [
            "a) Bitwise XNOR",
            "b) Bitwise NAND",
            "c) Bitwise XOR",
            "d) Bitwise AND"
        ],
        "Answer": "Answer: c\nExplanation: The ^ operator is used to perform a bitwise XOR operation on any two numbers which serve as the operands. It performs an XOR operation on each bit starting from the most significant bit to the least significant bit.\n"
    },
    {
        "id": 197,
        "Question": "What is the purpose of the << operator?",
        "Options": [
            "a) Bitwise AND",
            "b) Bitwise Right Shift",
            "c) Bitwise Left Shift",
            "d) Bitwise OR"
        ],
        "Answer": "Answer: c\nExplanation: The << operator takes two numbers as operands. Then it shifts the bits of the first operand by the value present in the second operand from right to left. The second operand however has to be a number less than 32 only. Otherwise the operation will not work.\n"
    },
    {
        "id": 198,
        "Question": "How many operands does the >= operator require?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: Yes, there is a difference between those two operators. The = operator signifies any assignment of values to some variable or data storage, while the == operator is a comparison operator which checks the equality of the operands it works with.\n"
    },
    {
        "id": 199,
        "Question": "1. What is the output of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int a=10;</pre></li><li class=\"li1\"><pre class=\"de1\">    int b=12;</pre></li><li class=\"li1\"><pre class=\"de1\">    int c=13;</pre></li><li class=\"li1\"><pre class=\"de1\">    if(a&gt;b &amp;&amp; a&gt;c) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(a);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else if(b&gt;a &amp;&amp; b&gt;c) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(b);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else if(c&gt;a &amp;&amp; c&gt;b) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(c);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 10",
            "b) 12",
            "c) 13",
            "d) null"
        ],
        "Answer": "Answer: c\nExplanation: The above code uses the if-else-if structure to find out the maximum of three integers. We must use 3 conditional blocks here to compare each value with the other one such that we can find the integer which is greater than the both the other integers.\n"
    },
    {
        "id": 200,
        "Question": "Which of the following control structures is an exit-controlled loop?",
        "Options": [
            "a) For loop",
            "b) While loop",
            "c) Const and Goto",
            "d) Do-While loop"
        ],
        "Answer": "Answer: d\nExplanation: An entry-controlled loop is a looping structure that performs the initialization, condition-checking, and increment/decrement operation at the beginning of the loop. So therefore, before a loop even starts to execute, a check is made if the condition is satisfied or not. In an exit controlled only the condition checking is done after the execution.\n"
    },
    {
        "id": 201,
        "Question": "3. What is the output of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int a=1011;</pre></li><li class=\"li1\"><pre class=\"de1\">    int rev=0,t=a;</pre></li><li class=\"li1\"><pre class=\"de1\">    while(t!=0) {</pre></li><li class=\"li1\"><pre class=\"de1\">        rev=rev*10;</pre></li><li class=\"li1\"><pre class=\"de1\">        rev=rev+t%10;</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    If(n==rev) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(“Palindrome”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    else {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(“Not a palindrome”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Null",
            "b) Palindrome",
            "c) Not a palindrome",
            "d) Compilation Error"
        ],
        "Answer": "Answer: c\nExplanation: The above code checks whether a given number is a palindrome number or not. A palindrome number is one which when reversed gives the same number as the original number. This concept can also be used with strings and not just numbers.\n"
    },
    {
        "id": 202,
        "Question": "4. What is the output of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">    int i,n,t1=0,t2=1,nt;</pre></li><li class=\"li1\"><pre class=\"de1\">    n=4;</pre></li><li class=\"li1\"><pre class=\"de1\">    for(i=1;i&lt;=n;++i) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(t1);</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(“ ”);</pre></li><li class=\"li1\"><pre class=\"de1\">        nt=t1+t2;</pre></li><li class=\"li1\"><pre class=\"de1\">        t1=t2;</pre></li><li class=\"li1\"><pre class=\"de1\">        t2=nt;</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    //Do Nothing</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 0 1 1 2",
            "b) 1 1 2 3",
            "c) 1 2 3 5",
            "d) 2 3 5 8"
        ],
        "Answer": "Answer: a\nExplanation: The above code demonstrates the Fibonacci series in which 2 numbers in the series are added up together to make the third number and so on and so forth. The above code uses 0 and 1 as the initial two numbers so the series starts with 0 and 1 then goes on to print 4 more numbers since the for loop used here is limited to 4 only.\n"
    },
    {
        "id": 203,
        "Question": "What is the name of the control structure used to stop any loop prematurely and only exit out of the loop, not affecting the running of the rest of the program?",
        "Options": [
            "a) The continue statement",
            "b) The break statement",
            "c) The exit statement",
            "d) The purge statement"
        ],
        "Answer": "Answer: b\nExplanation: From all the above options only the break statement is generally used for exiting loops. This can be also applied for switch case control structures. The difference between the break statement and the exit statement is that the break statement can only abort looping control structures, but the exit statement completely aborts the program execution.\n"
    },
    {
        "id": 204,
        "Question": "Which one of the control structures is similar to the if-else statement?",
        "Options": [
            "a) Switch-case",
            "b) For loop",
            "c) While loop",
            "d) Continue"
        ],
        "Answer": "Answer: a\nExplanation: The switch case is another type of decision-making control structure which can be used as a total replacement for the if-else structure. However, since it’s a more rigid structure, it’s mostly used for menu driven programs.\n"
    },
    {
        "id": 205,
        "Question": "8. What is the output of the code given below if there is a constant 5V supply to pin 10?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int x=0;</pre></li><li class=\"li1\"><pre class=\"de1\">    do {</pre></li><li class=\"li1\"><pre class=\"de1\">        x=analogRead(10);</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(x);</pre></li><li class=\"li1\"><pre class=\"de1\">    }while(x!=1023);  </pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1023",
            "b) 1024",
            "c) null",
            "d) 1029"
        ],
        "Answer": "Answer: a\nExplanation: The above code is wrong since the if statement deals with conditional expressions only and not allocation statements. It is a control structure that allows the user to make basic decisions to control the flow of control of the program.\n"
    },
    {
        "id": 206,
        "Question": "9. What is the output of the code given below if the input is 1101 to pin 10?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    if(digitalRead(10)==1) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(“HIGH ”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) HIGH HIGH LOW HIGH",
            "b) HIGH HIGH HIGH HIGH",
            "c) HIGH HIGH HIGH",
            "d) LOW LOW HIGH HGH"
        ],
        "Answer": "Answer: a\nExplanation: The above code takes an input and the prints the value of the voltage that is mapped to an integer set of 0 to 1023. The loop runs continuously until the value of ‘x’ is equal to 1023 or 5V as input. The control structure that is used here is the do-while loop and is an exit-controlled loop.\n"
    },
    {
        "id": 207,
        "Question": "Can the break statement be used to abort a program?",
        "Options": [
            "a) Yes",
            "b) Yes, but only if it is used within the global scope",
            "c) No",
            "d) Yes, but only for some Arduino Boards"
        ],
        "Answer": "Answer: c\nExplanation: The code given above reads a digital signal from pin 10 and then prints a “HIGH” statement to the Serial Monitor. However, this only happens when the signal given as input is a digital 1, or 5V. When a digital 0 or any other voltage level is detected that is below 5V, the code does not print anything.\n"
    },
    {
        "id": 208,
        "Question": "2. What is the output of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int i, j, n=3, temp;</pre></li><li class=\"li1\"><pre class=\"de1\">    int a[3]={2, 1, 3};</pre></li><li class=\"li1\"><pre class=\"de1\">    for(i=0;i&lt;n-1;i++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        for(j=0;j&lt;n-1-I;j++) {</pre></li><li class=\"li1\"><pre class=\"de1\">            if(a[j]&gt;a[j+1]) {</pre></li><li class=\"li1\"><pre class=\"de1\">                temp=a[j];</pre></li><li class=\"li1\"><pre class=\"de1\">                a[j]=a[j+1];</pre></li><li class=\"li1\"><pre class=\"de1\">                a[j+1]=temp;</pre></li><li class=\"li1\"><pre class=\"de1\">            }</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    for(i=0;i&lt;n;i++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(a[i]);</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(“ ”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1 2 3",
            "b) 3 2 1",
            "c) 1 3 2",
            "d) 2 1 3"
        ],
        "Answer": "Answer: a\nExplanation: The minimum number of times an entry-controlled loop will run if the condition fails at first attempt is 0. However, the minimum number of times an exit-controlled loop will run if the condition fails at first attempt is 1. Here the difference is that in an entry-controlled loop, the condition is checked before entry into the loop structure, while in an exit-controlled loop, the condition is checked after the completion of the loop structure.\n"
    },
    {
        "id": 209,
        "Question": "3. What is the purpose of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int a[4]={1,2,3,4};</pre></li><li class=\"li1\"><pre class=\"de1\">    int search_item=2;</pre></li><li class=\"li1\"><pre class=\"de1\">    int i;</pre></li><li class=\"li1\"><pre class=\"de1\">    for(i=0;i&lt;4;i++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        if(a[i]==search_item) {</pre></li><li class=\"li1\"><pre class=\"de1\">            Serial.print(“Found!”);</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Search",
            "b) Sort",
            "c) Delete",
            "d) Append"
        ],
        "Answer": "Answer: a\nExplanation: The above code demonstrates the Bubble Sort Technique using the concept of nested for-loop. Bubble Sort is a sorting technique. The version which we have used here sorts the contents (numbers) of the array in ascending order.\n"
    },
    {
        "id": 210,
        "Question": "4. What is the output of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int n,c,d,position,swap;</pre></li><li class=\"li1\"><pre class=\"de1\">    int array[4]={1,2,4,3};</pre></li><li class=\"li1\"><pre class=\"de1\">    n=4;</pre></li><li class=\"li1\"><pre class=\"de1\">    for(c=0;c&lt;n;c++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        position=c;</pre></li><li class=\"li1\"><pre class=\"de1\">        for(d=c+1;d&lt;n;d++) {</pre></li><li class=\"li1\"><pre class=\"de1\">            if(array[position]&gt;array[d]) {</pre></li><li class=\"li1\"><pre class=\"de1\">                position=d;</pre></li><li class=\"li1\"><pre class=\"de1\">\t    }</pre></li><li class=\"li1\"><pre class=\"de1\">\t}</pre></li><li class=\"li1\"><pre class=\"de1\">        if(position!=c) {</pre></li><li class=\"li1\"><pre class=\"de1\">            swap=array[c];</pre></li><li class=\"li1\"><pre class=\"de1\">            array[c]=array[position];</pre></li><li class=\"li1\"><pre class=\"de1\">            array[position]=swap;</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">    for(c=0;c&lt;n;c++) {</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(array[c]);</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.print(“ ”);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1 2 4 3",
            "b) 1 3 2 4",
            "c) 3 1 2 4",
            "d) 1 2 3 4"
        ],
        "Answer": "Answer: a\nExplanation: The code given above performs continuously checks whether a number called “search_item” is present in the array given or not. This operation is called a Linear Search wherein the search operation sweeps the array linearly from one end to another and checks if an item is present or not.\n"
    },
    {
        "id": 211,
        "Question": "What are the three components of a for-loop?",
        "Options": [
            "a) initialization, conditional, increment/decrement",
            "b) conditional, memory allocation, memory deletion",
            "c) reset, increment, conditional",
            "d) reset, increment/decrement, memory allocation"
        ],
        "Answer": "Answer: d\nExplanation: The above code takes 4 integers in an array and then attempts to sort the elements in ascending order using the Selection Sort Algorithm. This is done by repeatedly finding the smallest number from the array and putting it at the beginning.\n"
    },
    {
        "id": 212,
        "Question": "6. How many times will the following loop run if the input to the code is a constant 5V signal?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin1=10;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin1,INPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    for(int i=0;i&lt;10;i--) {</pre></li><li class=\"li1\"><pre class=\"de1\">        if(digitalRead(pin1)==1) {</pre></li><li class=\"li1\"><pre class=\"de1\">            Serial.println(“HELLO”);</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 2",
            "c) infinitely",
            "d) 5"
        ],
        "Answer": "Answer: a\nExplanation: The for-loop structure is an entry controlled looping structure. It is generally used when there is a clear starting point and ending point to the loop. Unlike the while loop in which the ending point may or may not be included in the loop structure.\n"
    },
    {
        "id": 213,
        "Question": "Which one of the control structures is similar to the if-else statement?",
        "Options": [
            "a) Switch-case",
            "b) For loop",
            "c) While loop",
            "d) Continue"
        ],
        "Answer": "Answer: c\nExplanation: The above code is going to run infinitely since the in the increment/decrement section the condition given is i–. Which literally means that the loop will execute until i becomes 10-1, and each time the loop executes, we decrement it by 1. So in effect, i will continuously become lesser and lesser and never be equal to 10-1.\n"
    },
    {
        "id": 214,
        "Question": "8. What is the output of the code given below if there is a constant 5V supply to pin 10?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int x=0;</pre></li><li class=\"li1\"><pre class=\"de1\">    do {</pre></li><li class=\"li1\"><pre class=\"de1\">        x=analogRead(10);</pre></li><li class=\"li1\"><pre class=\"de1\">        Serial.println(x);</pre></li><li class=\"li1\"><pre class=\"de1\">    }while(x!=1023);  </pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 1023",
            "b) 1024",
            "c) null",
            "d) 1029"
        ],
        "Answer": "Answer: a\nExplanation: The switch case is another type of decision-making control structure which can be used as a total replacement for the if-else structure. However, since it’s a more rigid structure, it’s mostly used for menu driven programs.\n"
    },
    {
        "id": 215,
        "Question": "Is there a difference between iteration and recursion?",
        "Options": [
            "a) Yes",
            "b) No",
            "c) Yes, but only in some programming languages",
            "d) Yes, but it depends on the version of programming language used"
        ],
        "Answer": "Answer: a\nExplanation: The above code takes an input and the prints the value of the voltage that is mapped to an integer set of 0 to 1023. The loop runs continuously until the value of ‘x’ is equal to 1023 or 5V as input. The control structure that is used here is the do-while loop and is an exit-controlled loop.\n"
    },
    {
        "id": 216,
        "Question": "Can an infinite loop be dangerous to embedded systems due to memory leak?",
        "Options": [
            "a) Yes",
            "b) Yes, but only if it is used within a limited scope",
            "c) No",
            "d) Yes, but only for some Arduino Boards"
        ],
        "Answer": "Answer: a\nExplanation: Iteration is the method of executing a set of statements repeatedly with the use of looping control structures like the for-loop, while-loop, do-while loop, etc. while recursion does the same thing but without using any looping control structures. It uses function call statements.\n"
    },
    {
        "id": 217,
        "Question": "1. What is the unit of delay in the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    digitalWrite(10,HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">    delay(1000);</pre></li><li class=\"li1\"><pre class=\"de1\">    digitalWrite(10,LOW);</pre></li><li class=\"li1\"><pre class=\"de1\">    delay(1000);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Milliseconds",
            "b) Microseconds",
            "c) Seconds",
            "d) Minutes"
        ],
        "Answer": "Answer: a\nExplanation: The delay() function is used to delay the execution of a command by a certain specified amount of time. This function takes only one argument and that is the time in milliseconds. In the code above we are giving a delay of 1000 ms or 1 s after each digitalWrite() command is executed.\n"
    },
    {
        "id": 218,
        "Question": "What is the return type of the micros() function?",
        "Options": [
            "a) Signed Long",
            "b) Signed Int",
            "c) Unsigned Long",
            "d) Unsigned Int"
        ],
        "Answer": "Answer: c\nExplanation: The micros() function gives the up-time or the time since the Arduino started to run the program. The return type here is unsigned long, which means basically a number of the long datatype without any plus or minus signs. This number denotes the up-time in microseconds.\n"
    },
    {
        "id": 219,
        "Question": "What is the return type of the millis() function?",
        "Options": [
            "a) Signed Long",
            "b) Unsigned Long",
            "c) Signed Float",
            "d) Unsigned Int"
        ],
        "Answer": "Answer: b\nExplanation: The millis() function gives the up-time or the time since the Arduino started to run the program. The return type here is unsigned long, which means basically a number of the long datatype without any plus or minus signs. This number denotes the up time in milliseconds.\n"
    },
    {
        "id": 220,
        "Question": "What is the return type of the delayMicroseconds() function?",
        "Options": [
            "a) Unsigned Int",
            "b) Signed Int",
            "c) Unsigned Long",
            "d) Signed Long"
        ],
        "Answer": "Answer: a\nExplanation: The delayMicroseconds() function delays or pauses program execution for a certain amount of time. The return type here is unsigned int, which means basically a number of the int datatype without any plus or minus signs. This number here is denoted by microseconds.\n"
    },
    {
        "id": 221,
        "Question": "5. What is the time period of the output signal of the program given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int pin=10;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(pin,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    digitalWrite(pin,HIGH);</pre></li><li class=\"li1\"><pre class=\"de1\">    delay(10);</pre></li><li class=\"li1\"><pre class=\"de1\">    digitalWrite(pin,LOW);</pre></li><li class=\"li1\"><pre class=\"de1\">    delay(10);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 20 Microseconds",
            "b) 100 Milliseconds",
            "c) 10 Milliseconds",
            "d) 0.02 Seconds"
        ],
        "Answer": "Answer: d\nExplanation: The program given above uses the delay() function to create a delay of a specified amount of time in milliseconds between each HIGH or LOW signal. Here this delay function is used to create a pulse train with a time period of 20 Milliseconds (10 Milliseconds for the completion of each half of one wave) or 0.02 Seconds.\n"
    },
    {
        "id": 222,
        "Question": "6. What is the purpose of the program given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int ledState = LOW;</pre></li><li class=\"li1\"><pre class=\"de1\">int ledPin = 13;</pre></li><li class=\"li1\"><pre class=\"de1\">unsigned long previousMillis = 0;</pre></li><li class=\"li1\"><pre class=\"de1\">const long interval = 1000;           </pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(ledPin, OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    unsigned long currentMillis = millis();</pre></li><li class=\"li1\"><pre class=\"de1\">    if (currentMillis - previousMillis &gt;= interval) {</pre></li><li class=\"li1\"><pre class=\"de1\">        previousMillis = currentMillis;</pre></li><li class=\"li1\"><pre class=\"de1\">        if (ledState == LOW) {</pre></li><li class=\"li1\"><pre class=\"de1\">            ledState = HIGH;</pre></li><li class=\"li1\"><pre class=\"de1\">        } else {</pre></li><li class=\"li1\"><pre class=\"de1\">            ledState = LOW;</pre></li><li class=\"li1\"><pre class=\"de1\">        }</pre></li><li class=\"li1\"><pre class=\"de1\">        digitalWrite(ledPin, ledState);</pre></li><li class=\"li1\"><pre class=\"de1\">    }</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) To create a delay in blink without using the delay() function",
            "b) To create a delay in blink with the delay() function",
            "c) To find the up-time",
            "d) To find the down-time"
        ],
        "Answer": "Answer: a\nExplanation: The program above blinks the onboard LED if executed on the Arduino Uno at a delay of 1 Second without using the help of the delay function. It uses the millis() function to calculate the delay to give. The millis() function gives the up-time of the program in milliseconds.\n"
    },
    {
        "id": 223,
        "Question": "What is the resolution of the micros() function on the Arduino Nano?",
        "Options": [
            "a) 2 Microseconds",
            "b) 3 Microseconds",
            "c) 4 Microseconds",
            "d) 5 Microseconds"
        ],
        "Answer": "Answer: c\nExplanation: The micros() function gives the up-time of the Arduino program in microseconds. This function has a resolution, i.e. the intervals in which it gives an output. This resolution depends on the Frequency of the specific Arduino Board that its running on. On the Arduino Duemilanove it’s resolution is 4 Microseconds.\n"
    },
    {
        "id": 224,
        "Question": "What is the overflow point of the millis() function?",
        "Options": [
            "a) 10 day",
            "b) 30 days",
            "c) 50 days",
            "d) 70 days"
        ],
        "Answer": "Answer: c\nExplanation: The millis() function gives the up-time or the time since the Arduino started to run the program. The overflow point of this function is 50 days. This means that the value returned by this function will return to 0 after 50 days.\n"
    },
    {
        "id": 225,
        "Question": "What is the resolution of the micros() function on the Arduino LilyPad?",
        "Options": [
            "a) 2 Microseconds",
            "b) 4 Microseconds",
            "c) 6 Microseconds",
            "d) 8 Microseconds"
        ],
        "Answer": "Answer: d\nExplanation: The micros() function gives the up-time of the Arduino program in microseconds. This function has a resolution, i.e. the intervals in which it gives an output. This resolution depends on the Frequency of the specific Arduino Board that its running on. On the Arduino LilyPad it’s resolution is 8 Microseconds.\n"
    },
    {
        "id": 226,
        "Question": "1. What is the output of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">     Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    String s=String(13,HEX);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(s);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 13",
            "b) A",
            "c) B",
            "d) D"
        ],
        "Answer": "Answer: d\nExplanation: The program above makes use of the String() function to convert the given number into a string. The String() function takes a maximum of 2 arguments; the number, and the base. Here the number 13 is given a base HEX which means it’s a hexadecimal number which makes it D.\n"
    },
    {
        "id": 227,
        "Question": "2. What is the output of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    String s=String(13,BIN);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(s);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 13",
            "b) 1101",
            "c) 1001",
            "d) null"
        ],
        "Answer": "Answer: b\nExplanation: The program above makes use of the String() function to convert the given number into a string. The String() function takes a maximum of 2 arguments; the number, and the base. Here the number 13 is given a base BIN which means it’s a binary number which makes it 1101.\n"
    },
    {
        "id": 228,
        "Question": "How many bits of memory does the bool datatype occupy?",
        "Options": [
            "a) 2",
            "b) 4",
            "c) 6",
            "d) 8"
        ],
        "Answer": "Answer: d\nExplanation: The bool datatype can only take 2 values; TRUE or FALSE. This takes a space of 8 bits or 1 byte. It’s mostly used in digital read or write operations to denote a 0V or 5V signal output or input. It can also be used for decision making.\n"
    },
    {
        "id": 229,
        "Question": "What datatype should one use to represent 2147483610?",
        "Options": [
            "a) Int",
            "b) Byte",
            "c) Short",
            "d) Long"
        ],
        "Answer": "Answer: d\nExplanation: Any number can be represented in the form of a whole number or a floating-point number. If it must be represented as a whole number, then there are many options depending upon the size of the number in question. Here the number 2146492440 should be represented using the long datatype since it has a range of -2147483648 to -2147483647.\n"
    },
    {
        "id": 230,
        "Question": "How many bits of memory does the Short datatype take up?",
        "Options": [
            "a) 17",
            "b) 15",
            "c) 16",
            "d) 14"
        ],
        "Answer": "Answer: c\nExplanation: Any number can be represented in the form of a whole number or a floating-point number. If it must be represented as a whole number, then there are many options depending upon the size of the number in question. Here the short datatype takes up 16 bits of memory. In other words, it can store numbers between -32768 to 32767.\n"
    },
    {
        "id": 231,
        "Question": "What method does the int datatype use for storing negative numbers?",
        "Options": [
            "a) 1’s Complement",
            "b) 2’s Complement",
            "c) 3’s Complement",
            "d) 4’s Complement"
        ],
        "Answer": "Answer: b\nExplanation: The int datatype stores 16 bits of data. The way it handles negative numbers is by a method called the 2’s complement wherein a sign bit is added to the binary equivalent of the number and then all the bits are inverted and then added by one.\n"
    },
    {
        "id": 232,
        "Question": "How can you assign the binary number 101 to an integer variable?",
        "Options": [
            "a) Var = B101",
            "b) Var = 101",
            "c) Var = bin(101)",
            "d) Var = Bin(101)"
        ],
        "Answer": "Answer: a\nExplanation: The concept used above is a binary formatter. If this letter is associated with the number during initialization of the variable, the number is converted from that base to the base 10 which is the decimal base. This binary formatter only works for numbers which have a length of 8 bits.\n"
    },
    {
        "id": 233,
        "Question": "8. What will the output of the code be?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    int n=0x101;</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(n);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 200",
            "b) 101",
            "c) 119",
            "d) 257"
        ],
        "Answer": "Answer: d\nExplanation: The concept used above is a hexadecimal formatter. If this letter is associated with the number during initialization of the variable, the number is converted from that base to the base 10 which is the decimal base. Thus, the output comes as 257.\n"
    },
    {
        "id": 234,
        "Question": "9. What is the output of the following program?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    String s=String(5.231, 1);</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.println(s);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 5",
            "b) 5.2",
            "c) 5.23",
            "d) 5.231"
        ],
        "Answer": "Answer: b\nExplanation: The program above makes use of the String() function to convert the given number into a string. The String() function takes a maximum of 2 arguments; in this case, the number and the decimal point limit. The decimal point limit dictates the number of decimal points till which the String() function should convert the number to a String. The rest is omitted.\n"
    },
    {
        "id": 235,
        "Question": "10. How many errors are present in the program given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">    pinMode(10,OUTPUT);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    word x=1000;</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) 0",
            "b) 1",
            "c) 2",
            "d) 3"
        ],
        "Answer": "Answer: a\nExplanation: The program given above is completely fine. It simply initializes a variable ‘x’ of the word datatype. The word datatype is a datatype that can store any unsigned whole number or integer ranging from 0 to 65535. It has a memory allocation of 16 bits.\n"
    },
    {
        "id": 236,
        "Question": "What is the math function to find out the minimum of 2 numbers?",
        "Options": [
            "a) The min() function",
            "b) The minimum_number() function",
            "c) The m() function",
            "d) The minimumOf() function"
        ],
        "Answer": "Answer: a\nExplanation: The min() function takes in 2 arguments and outputs only 1 number. This function finds out the minimum of the 2 numbers that are entered as arguments to the function. This function is essential in sorting techniques.\n"
    },
    {
        "id": 237,
        "Question": "What is the math function to find out the maximum of 2 numbers?",
        "Options": [
            "a) The maximumOf() function",
            "b) The maximum_number() function",
            "c) The max() function",
            "d) The m() function"
        ],
        "Answer": "Answer: c\nExplanation: The max() function takes in 2 arguments and outputs only 1 number. This function finds out the maximum of the 2 numbers that are entered as arguments to the function. This function is essential in sorting techniques.\n"
    },
    {
        "id": 238,
        "Question": "What is the maximum number of arguments for the constrain() function?",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: The constrain() function is used to restrict the output from going below or above a certain minimum or maximum number respectively. It takes three arguments; the number to be contrained, the minimum value, and the maximum value.\n"
    },
    {
        "id": 239,
        "Question": "What is the maximum number of arguments for the map() function?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 5",
            "d) 7"
        ],
        "Answer": "Answer: c\nExplanation: The map() function is used to map a number from one number set to another number set. It takes three arguments; the number to be mapped, the lowest number of the source number set, the highest number of the source number set, the lowest number of the destination number set, the highest number of the destination number set.\n"
    },
    {
        "id": 240,
        "Question": "What is the purpose of the pow(x,y) function?",
        "Options": [
            "a) To find xy",
            "b) To find yx",
            "c) To find ex",
            "d) To find 10y"
        ],
        "Answer": "Answer: a\nExplanation: The pow() function is used to find the value of a number raised to another number. It takes two arguments; the base, and the exponent. The input datatypes are of the float datatype and the output is of the double datatype.\n"
    },
    {
        "id": 241,
        "Question": "What is the use of the sqrt() function?",
        "Options": [
            "a) To find the square of a number",
            "b) To find the square root of a number",
            "c) To find the cube root of a number",
            "d) To find the cube of a number"
        ],
        "Answer": "Answer: b\nExplanation: The sqrt() function is used to find the square root of a number. It takes one argument; the number whose square root is to be found out. This function can accept any number-based datatypes and gives the output in the double datatype.\n"
    },
    {
        "id": 242,
        "Question": "What is the use of the sq() function?",
        "Options": [
            "a) To find the square root of a number",
            "b) To find the square of a number",
            "c) To find the cube of a number",
            "d) To find the cube root of a number"
        ],
        "Answer": "Answer: b\nExplanation: The sq() function is used to find the square of a number. It takes one argument; the number whose square is to be found out. This function can accept any number-based datatypes and gives the output in the double datatype.\n"
    },
    {
        "id": 243,
        "Question": "What is the use of the cos() function?",
        "Options": [
            "a) To find the cosine of a number",
            "b) To find the sine of a number",
            "c) To find the tan of a number",
            "d) To find the inverse cosine of a number"
        ],
        "Answer": "Answer: a\nExplanation: The cos() function is used to find the cosine of a number. It takes one argument; the number whose cosine is to be found out. This number is to be entered in the radian format and not the degree format. This function can accept any number-based datatypes and gives the output in the double datatype.\n"
    },
    {
        "id": 244,
        "Question": "What is the use of the sin() function?",
        "Options": [
            "a) To find the sine of a number",
            "b) To find the cosine of a number",
            "c) To find the tan of a number",
            "d) To find the inverse tan of a number"
        ],
        "Answer": "Answer: a\nExplanation: The sin() function is used to find the sine of a number. It takes one argument; the number whose sine is to be found out. This number is to be entered in the radian format and not the degree format. This function can accept the float datatype and gives the output in the double datatype.\n"
    },
    {
        "id": 245,
        "Question": "What is the use of the tan() function?",
        "Options": [
            "a) To find the sine of a number",
            "b) To find the cosine of a number",
            "c) To find the tan of a number",
            "d) To find the inverse tan of a number"
        ],
        "Answer": "Answer: c\nExplanation: The tan() function is used to find the tangent of an angle. It takes one argument; the angle whose tangent is to be found out. This number is to be entered in the radian format and not the degree format. This function can accept the float datatype and gives the output in the double datatype.\n"
    },
    {
        "id": 246,
        "Question": "What is the special escape sequence for newline in C++?",
        "Options": [
            "a) ‘\\b’",
            "b) ‘\\m’",
            "c) ‘\\n’",
            "d) ‘\\\\’"
        ],
        "Answer": "Answer: c\nExplanation: The newline character is used for shifting the cursor to the next line for any output to the monitor. It is mostly used for formatting output. During execution this escape sequence is converted to the OS Specific newline representation.\n"
    },
    {
        "id": 247,
        "Question": "What is the minimum number of arguments that the strcpy() function accept?",
        "Options": [
            "a) 4",
            "b) 3",
            "c) 2",
            "d) 1"
        ],
        "Answer": "Answer: c\nExplanation: The strcpy() function is used to copy the contents from one String variable to another. Hence it requires a minimum of two arguments that include the source variable (The variable from whose contents need to be copied from) and the destination variable (The variable to which the contents are to be copied to).\n"
    },
    {
        "id": 248,
        "Question": "What is the function of the strcmp() function?",
        "Options": [
            "a) To compare two strings",
            "b) To compile two strings",
            "c) To concatenate two strings",
            "d) To converge two strings"
        ],
        "Answer": "Answer: a\nExplanation: The strcmp() function takes in two arguments to work and it’s job is to compare two strings. it returns 0 if the first and second strings are the same, returns a number greater than 0 if the first string is greater than the second one and vice versa.\n"
    },
    {
        "id": 249,
        "Question": "Which of the following escape sequences placed at the end of a string makes the string a Null Terminated String?",
        "Options": [
            "a) ‘\\p’",
            "b) ‘\\u’",
            "c) ‘\\0’",
            "d) ‘\\1’"
        ],
        "Answer": "Answer: c\nExplanation: The ‘\\0’ when placed at the end of a string makes it a null terminated string which is simply a single dimensional array of characters that are trailed by the ‘\\0’ escape sequence. It is also called the ASCII NUL character.\n"
    },
    {
        "id": 250,
        "Question": "What is the return type of the front() function?",
        "Options": [
            "a) char",
            "b) int",
            "c) long",
            "d) short"
        ],
        "Answer": "Answer: a\nExplanation: The front() function returns a character from the string given as input. It takes in no arguments. It returns the first character that is present in the string. It can be used as “cout<<str.front();” which prints the first character from the variable “str”.\n"
    },
    {
        "id": 251,
        "Question": "How many arguments does the back() function take?",
        "Options": [
            "a) 0",
            "b) 1",
            "c) 2",
            "d) 3"
        ],
        "Answer": "Answer: a\nExplanation:  The back() function returns a character from the string given as input. It takes in no arguments. It returns the last character that is present in the string. It can be used as “cout<<str.front();” which prints the last character from the variable “str”.\n"
    },
    {
        "id": 252,
        "Question": "How many arguments does the at() function take?",
        "Options": [
            "a) 0",
            "b) 1",
            "c) 2",
            "d) 3"
        ],
        "Answer": "Answer: b\nExplanation:  The at() function returns a character from the string given as input. It takes 1 argument. It returns the character that is present in the string as specified by the argument. It can be used as “cout<<str.at(1);” which prints the second character from the variable “str”.\n"
    },
    {
        "id": 253,
        "Question": "Which of these functions are used to partially or fully substitute a string?",
        "Options": [
            "a) replace()",
            "b) size()",
            "c) subs()",
            "d) substring()"
        ],
        "Answer": "Answer: a\nExplanation: The replace function works with 3 arguments; the index in the source string, the string to be substituted with, and the string variable. It can be used as “str.replace(a,b, “hello”);” where ‘b’ characters are replaced from index ‘a’ in ‘str’.\n"
    },
    {
        "id": 254,
        "Question": "What is the return type of the substr() function?",
        "Options": [
            "a) int",
            "b) long",
            "c) byte",
            "d) string"
        ],
        "Answer": "Answer: d\nExplanation: The substr() function is used to return a portion of a given string. It accepts 2 inputs as arguments; the lower and upper indexes. It can be used as “str.substr(a,b);” where a is the lower index and b is the upper index.\n"
    },
    {
        "id": 255,
        "Question": "In C++ what type of operator is a cast operator?",
        "Options": [
            "a) Unary",
            "b) Binary",
            "c) Ternary",
            "d) Quaternary"
        ],
        "Answer": "Answer: a\nExplanation: The cast operator is a unary operator which is used to convert one data type into another forcefully. One example is:\n\n\n\t\n\nvoid setup() {\n    float f=34.5;\n    int i = static_cast<int>(f);\n}\n\n\nThe code above results in the variable ‘i’ having a value of 34 stored in it.\n"
    },
    {
        "id": 256,
        "Question": "What is Type Casting?",
        "Options": [
            "a) Converting a file from one type to another",
            "b) Creating new arrays",
            "c) Deleting the variable from memory",
            "d) Converting a variable from one type to another"
        ],
        "Answer": "Answer: d\nExplanation: Casting is the process of forcefully converting a variable from one data type to another. There are 4 types of casting; static cast, dynamic cast, const cast, reinterpret cast.\n"
    },
    {
        "id": 257,
        "Question": "Who carries out implicit type casting?",
        "Options": [
            "a) The programmer",
            "b) The assembler",
            "c) The compiler",
            "d) The microcontroller"
        ],
        "Answer": "Answer: c\nExplanation: This is also called type promotion and is carried out automatically by the compiler wherein it automatically converts a variable from one data type to another data type which is higher than that. Usually this is done to avoid any loss of data during calculations of floating type numbers.\n"
    },
    {
        "id": 258,
        "Question": "Who initiates explicit type casting?",
        "Options": [
            "a) The programmer",
            "b) The compiler",
            "c) The microcontroller",
            "d) The assembler"
        ],
        "Answer": "Answer: a\nExplanation: Explicit type casting is the process wherein the programmer specifies in the code the source and destination data type of any variable whose type needs to be converted. Unlike Implicit type casting, here the compiler doesn’t initiate the conversion until the programmer says so.\n"
    },
    {
        "id": 259,
        "Question": "5. What is the output of the given code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void setup() {\n    double x=11.3;\n    int s=(int)x+12;\n    Serial.begin(9600);\n    Serial.print(s);\n}\nvoid loop() {\n    //Do nothing.\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 12.2",
            "b) 23.3",
            "c) null",
            "d) 23"
        ],
        "Answer": "Answer: d\nExplanation: Here normally since we have the value of the variable ‘x’ as 11.3, if we normally add 12 to it the answer should have been 23.3. However, since we are converting the value of ‘x’ to an integer, the value of ‘x’ gets rounded off to 11 before the operation. Hence, we have the value 23.\n"
    },
    {
        "id": 260,
        "Question": "What is the conversion type for reinterpret casting?",
        "Options": [
            "a) Pointer to Variable",
            "b) Variable to Variable",
            "c) Pointer to Pointer",
            "d) Variable to Pointer"
        ],
        "Answer": "Answer: c\nExplanation:  Reinterpret casting is used to convert a pointer of any data type to another pointer of any other data type. Additionally, this does not match the datatype of the value and the pointer.\n"
    },
    {
        "id": 261,
        "Question": "7. What is the output of the following code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void print(char *str)\n{\n    Serial.print(x);\n}\nvoid setup()\n{\n    Serial.begin(9600);\n    const char *x=”Hello”;\n    print(const&lt;char *&gt;(x));\n    return 0;\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Hello",
            "b) H",
            "c) Ello",
            "d) null"
        ],
        "Answer": "Answer: a\nExplanation: The code above uses the const_cast function of C++, which toggles whether a variable is constant or not, i.e. if it is constant then removes the constant tag and vice versa. In the code above we see how to pass a constant variable through a function which accepts only non-constant variables.\n"
    },
    {
        "id": 262,
        "Question": "What is the use of the typeid() function?",
        "Options": [
            "a) To find the datatype of the variable",
            "b) To find the “const” status of the variable",
            "c) To find the address of the variable",
            "d) To find the value of the variable"
        ],
        "Answer": "Answer: a\nExplanation: The typeid() function returns the datatype of the expression or variable that is passed through it. It returns a constant type_info object which can be used as a string in further programming.\n"
    },
    {
        "id": 263,
        "Question": "9. Given below are 3 lines of code. Select the options given below with respect to the syntactical correctness regarding both C and C++?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">short x = 200;</pre></li><li class=\"li1\"><pre class=\"de1\">int b = (int) a;</pre></li><li class=\"li1\"><pre class=\"de1\">int c = int (a);</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Lines 1 and 2 are incorrect",
            "b) Lines 2 and 3 are incorrect",
            "c) Only line 1 is incorrect",
            "d) No lines are incorrect"
        ],
        "Answer": "Answer: d\nExplanation: In the code snippet given above, none of the lines are incorrect. Lines 2 and 3 exhibit the explicit type casting method for both C-Like cast notation and functional notation respectively, while line 1 simply declares and initiates a variable x of the short data type and value of 200.\n"
    },
    {
        "id": 264,
        "Question": "What functions are a static variable visible to?",
        "Options": [
            "a) Only Static Functions",
            "b) All Types of Functions",
            "c) Only Functions with a return type",
            "d) Only Non Static Functions"
        ],
        "Answer": "Answer: a\nExplanation: The static keyword makes the variable only visible to one function. The data held by static variables is not erased when the function call is over. This is what differentiates any static variable with a non-static variable.\n"
    },
    {
        "id": 265,
        "Question": "From which memory does the compiler revert to if a variable is declared volatile?",
        "Options": [
            "a) RAM",
            "b) Storage Register",
            "c) ROM",
            "d) EEPROM"
        ],
        "Answer": "Answer: a\nExplanation: Any global variable when defined in a program automatically is open for all functions present in the program to access and perform read or write operations. On the contrary any variable defined within the scope of a function, will only be able to be accessed within the function itself.\n"
    },
    {
        "id": 266,
        "Question": "4. What would be the output of the program?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int pin=11;\nvoid setup() {\n    pinMode(pin,OUTPUT);\n    int a=0;\n    Serial.begin(9600);\n}\nvoid loop() {\n    digitalWrite(pin,HIGH);\n    Serial.println(a);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 0",
            "b) null",
            "c) error",
            "d) 1"
        ],
        "Answer": "Answer: a\nExplanation: ‘volatile’ is a directive to the compiler. It makes the compiler load the variable from the Random-Access Memory instead of the storage register. It is also called a variable qualifier. It can be used if exactly precise values are to be stored.\n"
    },
    {
        "id": 267,
        "Question": "5. Which line in the code snippet is wrong?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void setup() {\n    int a = 0;\n    const int b = 1;\n    b=a;\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 2",
            "b) 3",
            "c) 4",
            "d) 1"
        ],
        "Answer": "Answer: b\nExplanation: The code above is wrong since the variable ‘a’ which is declared within the scope of the setup() function is invoked for printing in the subsequent loop() function. This is a violation of the scope policies hence the program will give an error.\n"
    },
    {
        "id": 268,
        "Question": "6. What would be the wrong line in this program?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void setup() {\n    int i;\n    for(i=0;i&lt;10;i++) {\n        int a=10;\n        a=9;\n        break;\n    }\n    Serial.begin(9600);\n    Serial.println(a);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 7",
            "d) 9"
        ],
        "Answer": "Answer: c\nExplanation: The Line 4 is wrong because it uses the variable ‘b’ and tries to put the value of the variable ‘a’ into it. However, that is not possible since variable ‘b’ is declared a ‘const’ variable. This means once the variable is declared, it’s value cannot be changed throughout the length of the entire program.\n"
    },
    {
        "id": 269,
        "Question": "Which of the sizes of data given below require us to shut off all interrupts while inputting them into a volatile variable?",
        "Options": [
            "a) 1 bit",
            "b) 2 bit",
            "c) 2 bytes",
            "d) 0.5 bytes"
        ],
        "Answer": "Answer: c\nExplanation: In the code above, the line 9 is wrong since it refers to a variable ‘a’ that was declared and initiated inside the scope of the for loop and so inaccessible to the rest of the variables inside the function setup() but outside the loop.\n"
    },
    {
        "id": 270,
        "Question": "8. What is the output of the code below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">#include&lt;stdio.h&gt; \nint function() \n{ \n    static int c = 0; \n    c++; \n    return c; \n} \nint main() \n{ \n    printf(\"%d  \", function()); \n    printf(\"%d \",  function()); \n    return 0; \n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 1 2",
            "b) 1 1",
            "c) null",
            "d) 1 3"
        ],
        "Answer": "Answer: c\nExplanation: The volatile keyword has a lot of uses and advantages in programming. However, when it comes to inputting large quantities of data, anything more than a bit in size will definitely result in the formation of garbage values. So, in order to input that kind of data we need to shut off all interrupts before inputting the value.\n"
    },
    {
        "id": 271,
        "Question": "9. In which line is there an error in the code snippet given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int x=10;\nconst int b;\nx=b;\nb=x;</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 1",
            "b) 2",
            "c) 3",
            "d) 4"
        ],
        "Answer": "Answer: a\nExplanation: The variable used in function() is declared static which means it will retain the last value after each function call statement which is then demonstrated in the code, when it is called through the print statement. Had the variable not been declared static, then it would print 1 1, since after every function call it’s memory would be wiped.\n"
    },
    {
        "id": 272,
        "Question": "How many times can a variable declared ‘const’ be fed a value in any program?",
        "Options": [
            "a) 1",
            "b) 26",
            "c) 30",
            "d) 0"
        ],
        "Answer": "Answer: d\nExplanation: In the last line, the variable ‘b’ cannot accept any other value since it is declared ‘const’ at the beginning of the code snippet. However, the previous line is correct since the variable ‘a’ is not declared ‘const’ in the code snippet, so it can accept the value from ‘b’.\n"
    },
    {
        "id": 273,
        "Question": "What is the use of the Interrupt Service Routine in an Arduino?",
        "Options": [
            "a) To automate functions",
            "b) To boot up the arduino",
            "c) To make more memory",
            "d) To exit any code that is running"
        ],
        "Answer": "Answer: a\nExplanation: The interrupt service routine can be used to automate a number of functions in an arduino. In a situation where the entire focus of the code is bound to one function, the ISR can act as a pause for the arduino to stop the current function temporarily and divert memory to another function. That way, the entire memory of the arduino is used up in one function.\n"
    },
    {
        "id": 274,
        "Question": "What is the use of the digitalPinToInterrupt() function?",
        "Options": [
            "a) To create an Interrupt Object",
            "b) To delete an Interrupt Object",
            "c) To map the Arduino Pin to the Interrupt pin",
            "d) To invoke the Interrupt Service Routine"
        ],
        "Answer": "Answer: c\nExplanation: The digitalPinToInterrupt() function translates the physical pin number on the arduino into the interrupt index. This works in almost all Arduino Boards and is usually used in conjunction with the attachInterrupt() function.\n"
    },
    {
        "id": 275,
        "Question": "What is the use of the attachInterrupt() function?",
        "Options": [
            "a) To enable ISR usage",
            "b) To enable ISR usage, but only on certain Arduino Boards",
            "c) To decommission ISR usage for a particular Arduino Board",
            "d) To translate pin numbers"
        ],
        "Answer": "Answer: a\nExplanation: The attachInterrupt() function allows us to initiate an interrupt routine in any Arduino Board. The interrupt service routine can be used to automate a number of functions in an Arduino.\n"
    },
    {
        "id": 276,
        "Question": "What is the use of pin change interrupts?",
        "Options": [
            "a) To change pins during interrupts",
            "b) To use more pins for interrupts",
            "c) To disable pin usage during interrupts",
            "d) To enable pin usage during interrupts"
        ],
        "Answer": "Answer: b\nExplanation: The delay function will not work inside any Interrupt and it will not be able to function properly in any way. So, no programmer should use it inside the code dedicated for running as Interrupts. However delayMicroseconds() will work as it normally would.\n"
    },
    {
        "id": 277,
        "Question": "When does the Interrupt Handler execute it’s assigned code?",
        "Options": [
            "a) After all the codes executed in the program",
            "b) Before any code is executed in the program",
            "c) Blocks the code from getting executed at any time in the program",
            "d) When the interrupt is in effect"
        ],
        "Answer": "Answer: b\nExplanation: Pin change Interrupts can be used to enable the Arduino to use more than one pin during the interrupt service routine. In ATMega 168 or 328 based Arduino boards, upto 20 pins can be dedicated to interrupts.\n"
    },
    {
        "id": 278,
        "Question": "What is the use of the interrupt mode?",
        "Options": [
            "a) Decides which type of transition to trigger on",
            "b) Decides when to turn off interrupts",
            "c) Decides which pin to turn off",
            "d) Decides when to turn off the Arduino Board"
        ],
        "Answer": "Answer: d\nExplanation: The Interrupt Handler is an event by nature which, when raised, stops any code that is executing and first executes the code that is assigned to it, then returns the control back to the normal execution.\n"
    },
    {
        "id": 279,
        "Question": "What is the use of the detachInterrupt() function?",
        "Options": [
            "a) To turn off interrupt",
            "b) To turn on interrupt",
            "c) To disable interrupt functions for the remaining ON time.",
            "d) To turn off the Arduino"
        ],
        "Answer": "Answer: a\nExplanation: There are different types of transition, RISING, FALLING, and CHANGE.\nRISING – Triggers interrupt when pin transitions from LOW to HIGH.\nFALLING – Triggers interrupt when pin transitions from HIGH to LOW.\nCHANGE – Triggers interrupt when pin transitions from LOW to HIGH or HIGH to LOW.\n"
    },
    {
        "id": 280,
        "Question": "How many pins are available for interrupt functions in the Arduino Zero?",
        "Options": [
            "a) No pins",
            "b) All pins except pin 4",
            "c) Only pin 4",
            "d) Only pin 3"
        ],
        "Answer": "Answer: a\nExplanation: The interrupt service routine can be used to automate a number of functions in an arduino. In a situation where the entire focus of the code is bound to one function, the ISR can act as a pause for the arduino to stop the current function temporarily and divert memory to another function. The detachInterrupt() function turns off the ISR functionality temporarily.\n"
    },
    {
        "id": 281,
        "Question": "How many pins are available for interrupt functions in the Arduino Uno?",
        "Options": [
            "a) No pins",
            "b) All pins except pin 2 and 3",
            "c) Only pin 2",
            "d) Only pins 2 and 3"
        ],
        "Answer": "Answer: b\nExplanation: ISR allows to initiate an interrupt routine in any Arduino Board. The interrupt service routine can be used to automate a number of functions in an Arduino. Usually a number of pins are assigned for any Board. The Arduino Zero has ISR functionality enabled for all it’s pins except pin 4.\n"
    },
    {
        "id": 282,
        "Question": "In which memory does the Arduino save data in when the PROGMEM Utility is invoked?",
        "Options": [
            "a) EEPROM",
            "b) SRAM",
            "c) Flash",
            "d) DRAM"
        ],
        "Answer": "Answer: c\nExplanation: When the PROGMEM Utility is invoked, data being saved is diverted to the flash memory instead of the SRAM. This utility is a variable modifier, which means it can change the variable policy whenever invoked.\n"
    },
    {
        "id": 283,
        "Question": "Which header file contains the PROGMEM Utility?",
        "Options": [
            "a) The avr/pgmspace.h header file",
            "b) The pmspace.h header file",
            "c) The avr/pspace.h header file",
            "d) The avr/progmem.h header file"
        ],
        "Answer": "Answer: a\nExplanation: The PROGMEM Utility is contained within the avr/pgmspace.h header file and this file is to be invoked whenever a programmer needs to use the PROGMEM Utility for his or her program. However, while using the data stored in the Flash memory one also needs to use certain functions defined within the header file to retrieve the data.\n"
    },
    {
        "id": 284,
        "Question": "What type of variables does the PROGMEM Utility work on?",
        "Options": [
            "a) Globally Defined or static",
            "b) Defined inside a function and non-static",
            "c) Defined inside a for-loop and non-static",
            "d) Defined inside a while-loop and non-static"
        ],
        "Answer": "Answer: a\nExplanation: The PROGMEM Utility can only be used for variables which have “public” access to the entire program and conversely can be accessed by anyone, or is a static variable, which means they need to be defined outside a function and be static or non-static, or if they are defined within any function, they need to be static.\n"
    },
    {
        "id": 285,
        "Question": "What is the equivalent macro for the PROGMEM Utility when dealing with sending data that is to be printed, into the Flash memory?",
        "Options": [
            "a) A() Macro",
            "b) C() Macro",
            "c) F() Macro",
            "d) N() Macro"
        ],
        "Answer": "Answer: a\nExplanation: The PROGMEM Utility can be used with non-static variables provided they are defined outside any function, i.e. they are defined globally. Conversely if one needs to work on a variable that is not defined globally then they would need to convert that variable into a static variable in order to use the PROGMEM Utility.\n"
    },
    {
        "id": 286,
        "Question": "7. Given below are four lines of boilerplate code. Which ones are faulty?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">const dataType variableName[] PROGMEM = {};\nconst PROGMEM dataType variableName[] = {};\nconst dataType PROGMEM variableName[] = {};\ndataType PROGMEM const variableName[] = {};</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Lines 1 and 3",
            "b) Lines 3 and 4",
            "c) Lines 1 and 2",
            "d) Lines 3 and 2"
        ],
        "Answer": "Answer: a\nExplanation: When the PROGMEM Utility is invoked, data being saved is diverted to the flash memory instead of the SRAM. This utility is a variable modifier so it can be used on any kind of data structures allowed by the language.\n"
    },
    {
        "id": 287,
        "Question": "In which versions of the Arduino IDE can the PROGMEM Utility be used without declaration in the Arduino code?",
        "Options": [
            "a) Any Arduino IDE version above 2.0",
            "b) Any Arduino IDE version above 1.0",
            "c) Any Arduino IDE version below 1.0",
            "d) Any Arduino IDE version above 3.1"
        ],
        "Answer": "Answer: c\nExplanation: The F() macro is used for sending data, which is usually in the form of strings that are declared within the Serial.print() function which means they are not to be stored anywhere in the program but are to be printed onto the serial monitor, to the Flash Memory before it is printed.\n"
    },
    {
        "id": 288,
        "Question": "9. What is the purpose of the boilerplate code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">strcpy_P(buffer, (char *)pgm_read_word(&amp;(StringVariable)));</pre></div></div></div></div></div></div>",
        "Options": [
            "a) To copy data from the SRAM",
            "b) To copy data from the EEPROM",
            "c) To copy data from the Flash Memory",
            "d) To copy data to the EEPROM"
        ],
        "Answer": "Answer: b\nExplanation: The PROGMEM Utility can only be used for variables which have “public” access to the entire program and conversely can be accessed by anyone, or is a static variable, which means they need to be defined outside a function and be static or non-static. This means that there is a certain degree of syntactical freedom that the programmer is vested with when using the PROGMEM Utility since it is a variable modifier.\n"
    },
    {
        "id": 289,
        "Question": "10. What is the use of the boilerplate code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">someByte = pgm_read_word ( &amp;( someData[x][y] ) );</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Reading Strings from Flash Memory",
            "b) Reading Integers from Flash Memory",
            "c) Reading files from Flash Memory",
            "d) Reading special characters from Flash Memory"
        ],
        "Answer": "Answer: b\nExplanation: PROGMEM is part of the avr/pgmspace.h library. It is imported automatically in the more recent versions of the Arduino IDE. However, if one is using an IDE version below 1.0, then the header must be included first at the top of the code.\n"
    },
    {
        "id": 290,
        "Question": "What is the meaning of the data returned by the sizeof() function?",
        "Options": [
            "a) Length",
            "b) Location",
            "c) Pointer",
            "d) Memory"
        ],
        "Answer": "Answer: a\nExplanation: When the sizeof() function is used, it returns a number which corresponds to the length of the structure in question. It’s used by programmers for finding the, say number of elements in an array, or the number of characters in a string, etc…\n"
    },
    {
        "id": 291,
        "Question": "When the sizeof() function is invoked on an array. What information does it return?",
        "Options": [
            "a) Number of elements in the array",
            "b) The largest element in the array",
            "c) The total sum of the ASCII values of the elements in the array",
            "d) The largest ASCII value of any element in the array"
        ],
        "Answer": "Answer: a\nExplanation: The primary use of the sizeof() function is to return the length or size of an element that is given to it. So, if this element is an array which is a collection of elements, it will give the number of elements present inside the array.\n"
    },
    {
        "id": 292,
        "Question": "3. What will the output for the code given below be, if executed on an Arduino UNO?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void setup() {\n    Serial.begin(9600);\n    Serial.print(sizeof(int));\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 3",
            "b) 1",
            "c) 2",
            "d) 8"
        ],
        "Answer": "Answer: c\nExplanation: The above code uses the sizeof() function to find the capacity of the integer for that particular board. It returns the number of bytes allocated for an int. Normally on 64-bit systems like laptops and desktop computers, this would give a value of 4, however on an Arduino UNO, it will give a value of 2 since the ATMega Board powering the Arduino UNO has a 16-bit architecture.\n"
    },
    {
        "id": 293,
        "Question": "What function will we use to find out the number of elements in an array?",
        "Options": [
            "a) sizeof()",
            "b) size()",
            "c) sf()",
            "d) sizeOf()"
        ],
        "Answer": "Answer: a\nExplanation: The primary use of the sizeof() function is to return the length or size of an element that is given to it. So, if this element is an array which is a collection of elements, it will give the number of elements present inside the array.\n"
    },
    {
        "id": 294,
        "Question": "What notation should we use for denoting the breadth of an array?",
        "Options": [
            "a) sizeof(a[0])",
            "b) sizeof(a)",
            "c) sizeof(a[])",
            "d) sizeof(a.0)"
        ],
        "Answer": "Answer: a\nExplanation: When the first element of an array is invoked in the sizeof() function, if the array is a 2D array then it will give the number of elements present in the breadth of the matrix.\n"
    },
    {
        "id": 295,
        "Question": "6. What is the output of the following line of code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">printf(\"%lu\\n\", sizeof(char));</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 21",
            "b) %fdf",
            "c) 1",
            "d) null"
        ],
        "Answer": "Answer: c\nExplanation:  When sizeof() is used with the data types such as int, float, char, etc. It returns the amount of memory that is allocated to the respective data types.\n"
    },
    {
        "id": 296,
        "Question": "7.  What will be the output of the following code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int a = 0; \ndouble d = 10.21;\nprintf(\"%lu\", sizeof(a + d));</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 23",
            "b) null",
            "c) 8",
            "d) 10.21"
        ],
        "Answer": "Answer: c\nExplanation:  The sizes of int and double are 4 and 8 respectively, a is an integer variable whereas d is a double variable. The final result will be a double in this case in order to keep the precision. Hence the output of the code is 8 bytes.\n"
    },
    {
        "id": 297,
        "Question": "9. What is the output of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int x = 3; \nprintf(\"%d\\n\", sizeof(x++)); \nprintf(\"x = %d\", x);</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 3",
            "b) 4",
            "c) Runtime Error",
            "d) null"
        ],
        "Answer": "Answer: c\nExplanation: The sizeof() function here is being used to allocate a block of memory. This code is dynamic because the size of int is different on different machine architectures. So, we have allocated a block of memory that is enough to hold 100 integers irrespective of the size of the int data type in the machine in which this code is going to be executed.\n"
    },
    {
        "id": 298,
        "Question": "10. What will be the output of the following code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int a = 10; \ndouble d = 10.21;\nprintf(\"%lu\", sizeof(a + d));</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 8",
            "b) null",
            "c) 9",
            "d) 20.21"
        ],
        "Answer": "Answer:a\nExplanation: The output of the code will be 3 instead of 4 because inspite of the increment operator put inside the sizeof() function, the function never really processes the variable as a whole and puts into memory, but only processes the value that is held.\n"
    },
    {
        "id": 299,
        "Question": "1. What is the output of the program given below if a voltage of 5V is supplied to the pin corresponding to the A0 pin on an Arduino UNO?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void setup() {\n    Serial.begin(9600);\n    pinMode(A0, INPUT);\n}\nvoid loop() { \n    int s = analogRead(A0);\n    Serial.println(s);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) null",
            "b) Error",
            "c) 0",
            "d) 1024"
        ],
        "Answer": "Answer: d\nExplanation: The Arduino UNO’s analog pins map the value of the sensed voltage to an internal numbering scale which makes it easier for the programmer to work since it is more difficult to analog voltage levels in programming practice. Thus, for a value of 5V, which reaches the maximum limit, we get a value of 1024.\n"
    },
    {
        "id": 300,
        "Question": "2. What is the value of “val” in the following program if the pin 12 is given 5V 3 times?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int val=0;\nvoid setup() {\n    Serial.begin(9600);\n    PinMode(13,INPUT);\n}\nvoid loop() {\n    int s = digitalRead(13);\n    if(s==1){\n        val=val+1;\n    }\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) null",
            "b) 113",
            "c) 3",
            "d) 2"
        ],
        "Answer": "Answer: c\nExplanation: In the program the variable “val” is declared as a global variable, I.e. its value can be accessed by all functions in the current program. This variable is then setup to 1 higher than itself every time the digitalRead() function detects a HIGH or a 5V signal at its end. Hence raising the value every time a 5V signal is applied.\n"
    },
    {
        "id": 301,
        "Question": "3. What will the output for the code given below be, if executed on an Arduino UNO?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void setup() {\n    Serial.begin(9600);\n    Serial.print(sizeof(int));\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 3",
            "b) 1",
            "c) 2",
            "d) 8"
        ],
        "Answer": "Answer: c\nExplanation: The above code uses the sizeof() function to find the capacity of the integer for that particular board. It returns the number of bytes allocated for an int. Normally on 64-bit systems like laptops and desktop computers, this would give a value of 4, however on an Arduino UNO, it will give a value of 2 since the ATMega Board powering the Arduino UNO has a 16-bit architecture.\n"
    },
    {
        "id": 302,
        "Question": "4. What is the output of the following program?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void setup() { \n    String my_str = \"This is the sentence\"; \n    Serial.begin(9600); \n    my_str.replace(\"sentence\", \"Arduino sketch\"); \n    Serial.println(my_str);\n}\nvoid loop() { }</pre></div></div></div></div></div></div>",
        "Options": [
            "a) “This is the sentence”",
            "b) “This is the ARDUINO SKETCH”",
            "c) “This is the Arduino Sketch”",
            "d) null"
        ],
        "Answer": "Answer: c\nExplanation:  The code given here, takes a string and then proceeds to replace the value of the string with custom word(s). It is an example of String manipulation in Arduino. It uses the replace() function for achieving this.\n"
    },
    {
        "id": 303,
        "Question": "5. What will be the nature of the output of the program?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">long rn; \nvoid setup() { \n    Serial.begin(9600); \n    randomSeed(analogRead(0)); \n} \nvoid loop() { \n    randNumber = random(300); \n    Serial.println(rn);\n    delay(1000);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Series of purely mathematical indeterministic random numbers",
            "b) Series of purely mathematical deterministic random numbers",
            "c) null",
            "d) Series of indeterministic random numbers based on noise"
        ],
        "Answer": "Answer: d\nExplanation: The function here attempts to generate random numbers based on the analog noise generated at one of the pins present in the board. This will create a seemingly indeterministic set of numbers ranging from 0 to 300, which is great for a random number generator function.\n"
    },
    {
        "id": 304,
        "Question": "6. What is the output of the following line of code?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void main() {  \n    printf(\"%lu\\n\", sizeof(char));\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 21",
            "b) %fdf",
            "c) 1",
            "d) null"
        ],
        "Answer": "Answer: c\nExplanation:  When sizeof() is used with the data types such as int, float, char, etc. It returns the amount of memory that is allocated to the respective data types.\n"
    },
    {
        "id": 305,
        "Question": "7. What will be the output of the following code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void main() {\n    int a = 0; \n    double d = 10.21;\n    printf(\"%lu\", sizeof(a + d));\n}\nvoid loop() {}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 23",
            "b) null",
            "c) 8",
            "d) 10.21"
        ],
        "Answer": "Answer: c\nExplanation:  The sizes of int and double are 4 and 8 respectively, a is an integer variable whereas d is a double variable. The final result will be a double in this case in order to keep the precision. Hence the output of the code is 8 bytes.\n"
    },
    {
        "id": 306,
        "Question": "8. What does the following code do?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void main() {\n    int* ptr = (int*)malloc(100 * sizeof(int));\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Static Memory Allocation",
            "b) Static Memory Clearance",
            "c) Dynamic Memory Allocation",
            "d) Dynamic Memory Clearance"
        ],
        "Answer": "Answer: c\nExplanation: The sizeof() function here is being used to allocate a block of memory. This code is dynamic because the size of int is different on different machine architectures.  So we have allocated a block of memory that is enough to hold 100 integers irrespective of the size of the int data type in the machine in which this code is going to be executed.\n"
    },
    {
        "id": 307,
        "Question": "9. What is the output of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void main() {\n    Serial.begin(); \n    int x = 2; \n    printf(\"%d\\n\", sizeof(x++)); \n    printf(\"x = %d\", x);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 2",
            "b) 4",
            "c) Runtime Error",
            "d) null"
        ],
        "Answer": "Answer: a\nExplanation: The output of the code will be 2 instead of 3 because inspite of the increment operator put inside the sizeof() function, the function never really processes the variable as a whole and puts into memory, but only processes the value that is held.\n"
    },
    {
        "id": 308,
        "Question": "10. What will be the output of the following code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">void main() { \n    int a = 10; \n    double d = 10.21;\n    printf(\"%lu\", sizeof(a + d));\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) 8",
            "b) null",
            "c) 9",
            "d) 20.21"
        ],
        "Answer": "Answer: a\nExplanation:  The sizes of int and double are 4 and 8 respectively, a is an integer variable whereas d is a double variable. The final result will be a double in this case in order to keep the precision. Hence the output of the code is 8 bytes.\n"
    },
    {
        "id": 309,
        "Question": "What is the use of the IR Sensor?",
        "Options": [
            "a) Object Detection",
            "b) Humidity Detection",
            "c) Image Processing",
            "d) GPS"
        ],
        "Answer": "Answer: a\nExplanation: The IR Sensor is used for calculating the distance between the sensor and the object. It is mostly used for calculating the acceleration, velocity and position of the sensor attached to the device. It basically has two terminals which emit an IR Signal and receive the emitted IR Signal. The time difference between these two gives us the required data for such calculations.\n"
    },
    {
        "id": 310,
        "Question": "How many pins are present in the IR Sensor?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 2",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: The pins that are present on the IR Sensor include, the Ground, the Vcc and the Signal pins. The role of the Ground and the Vcc is to power the sensor. The Vcc accepts a maximum voltage of approximately 5V. The signal pin is present to convey the data from the sensor to the microcontroller or the microprocessor.\n"
    },
    {
        "id": 311,
        "Question": "What mode should we put the Arduino pin to, for object detection to work with the IR Sensor?",
        "Options": [
            "a) Analog",
            "b) Digital",
            "c) PCM",
            "d) TDM"
        ],
        "Answer": "Answer: b\nExplanation: Having the input pin to digital on the Arduino, will give us a HIGH signal from the sensor whenever an object is detected to be in range of the sensor thus fulfilling its need. So, for object detection we can attain the required data simply by a digital HIGH or LOW signal.\n"
    },
    {
        "id": 312,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the IR sensor?",
        "Options": [
            "a) Damage is caused",
            "b) Sensor will work fine",
            "c) Sensor will not respond for the time the voltage is applied",
            "d) Sensor will function normally"
        ],
        "Answer": "Answer: a\nExplanation:  The IR Sensors are mostly built to work on a voltage range of approximately 3.3V to 5V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 313,
        "Question": "If 1 means an object is detected and 0 meaning no object is detected, then considering the sensor is stationary, what can be said about the movement of the object if the output by the sensor is 1010101?",
        "Options": [
            "a) Object is stationary",
            "b) Object is oscillating side by side",
            "c) Object is continuously moving away",
            "d) Object is continuously moving closer"
        ],
        "Answer": "Answer: b\nExplanation: The only explanation for such output from the sensor would be if the object is moving in such a path, that makes it within the range of the sensor and vice versa after each specified amount of time and this continuously happens along a deterministic path so that we know that the only way this can happen is that if the object is oscillating between two given points.\n"
    },
    {
        "id": 314,
        "Question": "6. What will the output of the code be if the object is continuously moving away from the sensor?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int op = 7;\nint isObstacle = HIGH;\nvoid setup() {\n    pinMode(op, INPUT);\n    Serial.begin(9600);\n} \nvoid loop() { \n    isObstacle = digitalRead(op);\n    if (isObstacle == LOW) { \n        Serial.println(\"1+\"); \n    } \n    else {\n        Serial.print(\"clear+\"); \n    } \n    delay(200);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) clear+clear+1+1",
            "b) 1+1+clear+clear",
            "c) clear+clear+clear+clear",
            "d) 1+1+clear+1"
        ],
        "Answer": "Answer: b\nExplanation: If the object is moving continuously away then within the four cycles of the given output, the first half of the set sees the object within range so printing a “1+”, while within the second half of the code, the object has already moved beyond the range of the sensor so it gives the “clear+” signal.\n"
    },
    {
        "id": 315,
        "Question": "7. What will the output of the code be if the object is continuously moving towards the sensor?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int op = 6;\nint isObstacle = HIGH;\nvoid setup() {\n    pinMode(op, INPUT);\n    Serial.begin(9600);\n} \nvoid loop() { \n    isObstacle = digitalRead(op);\n    if (isObstacle == LOW) { \n        Serial.println(\"1+\"); \n    } \n    else {\n        Serial.print(\"clear+\"); \n    } \n    delay(200);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) clear+clear+1+1",
            "b) 1+1+clear+clear",
            "c) clear+clear+clear+clear",
            "d) 1+1+clear+1"
        ],
        "Answer": "Answer: a\nExplanation: If the object is moving continuously towards the sensor, then within the four cycles of the given output, the first half of the set sees the object beyond the range so it will print a “clear+”, while within the second half of the code, the object has already moved inside the range of the sensor so it gives the “1+” signal.\n"
    },
    {
        "id": 316,
        "Question": "If 1 means an object is detected and 0 meaning no object is detected, then considering the sensor is stationary, what can be said about the movement of the object if the output by the sensor is 111000?",
        "Options": [
            "a) Object is stationary",
            "b) Object is oscillating side by side",
            "c) Object is continuously moving away",
            "d) Object is continuously moving closer"
        ],
        "Answer": "Answer: c\nExplanation: The only explanation for such output from the sensor would be if the object is moving in such a path, that after a few cycles, the object becomes out of range of the sensor, thus implying that it is moving away continuously from the sensor.\n"
    },
    {
        "id": 317,
        "Question": "9. What will the output of the code be if the relative velocity between the object and the sensor is 0, and it is within the range of the sensor for the entire time both are moving?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">int op = 6;\nint isObstacle = HIGH;\nvoid setup() {\n    pinMode(op, INPUT);\n    Serial.begin(9600);\n} \nvoid loop() { \n    isObstacle = digitalRead(op);\n    if (isObstacle == LOW) { \n        Serial.println(\"1+\"); \n    } \n    else {\n        Serial.print(\"clear+\"); \n    } \n    delay(200);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) clear+clear+1+1",
            "b) 1+1+clear+clear",
            "c) clear+clear+clear+clear",
            "d) 1+1+1+1"
        ],
        "Answer": "Answer: d\nExplanation:   If the relative velocity of the sensor with respect to the object is 0, then effectively it means that the object is stationary when compared to the sensor, so in that movement, since the object is within the sensor’s range, the sensor detects that the object is continuously within range hence the output will be continuously “1+”.\n"
    },
    {
        "id": 318,
        "Question": "What kind of waves does the IR Sensor work on?",
        "Options": [
            "a) Infrared",
            "b) Indigo",
            "c) Ultrasonic",
            "d) Infrasonic"
        ],
        "Answer": "Answer: a\nExplanation: The IR Sensor works on Infrared waves. These waves have a longer wavelength than visible light and are a form of electromagnetic radiation. Usually Infrared can be felt as heat when incident on humans, but the sensor’s intensity is too small to be felt usually.\n"
    },
    {
        "id": 319,
        "Question": "What is the use of the Ultrasonic Sensor?",
        "Options": [
            "a) Proximity Detection",
            "b) Humidity Detection",
            "c) Image Processing",
            "d) GPS"
        ],
        "Answer": "Answer: a\nExplanation: The Ultrasonic Sensor is used for calculating the distance between the sensor and the object. It is mostly used for calculating the acceleration, velocity and position of the sensor attached to the device. It basically has two terminals which emit an Ultrasonic Signal and receive the emitted Ultrasonic Signal. The time difference between these two gives us the required data for such calculations.\n"
    },
    {
        "id": 320,
        "Question": "How many pins are present in the Ultrasonic Sensor?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 2",
            "d) 4"
        ],
        "Answer": "Answer: d\nExplanation: The pins that are present on the Ultrasonic Sensor include, the Ground, the Vcc and the Signal pins. The role of the Ground and the Vcc is to power the sensor. The Vcc accepts a maximum voltage of approximately 5V. The signal pins; Trigger and Echo are present to detect the obstacle and convey the data from the sensor to the microcontroller or the microprocessor.\n"
    },
    {
        "id": 321,
        "Question": "What mode should we put the Arduino pin to, in order for object detection to work with the Ultrasonic Sensor?",
        "Options": [
            "a) Analog",
            "b) Digital",
            "c) PCM",
            "d) TDM"
        ],
        "Answer": "Answer: b\nExplanation: The TRIGGER pin is to be kept HIGH for a period of 10 microseconds meanwhile the ECHO pin is HIGH for the time period it takes for the sent Ultrasonic wave to return to the sensor. Thus, the entire detection is digital.\n"
    },
    {
        "id": 322,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the Ultrasonic sensor?",
        "Options": [
            "a) Damage is caused",
            "b) Sensor will work fine",
            "c) Sensor will not respond for the time the voltage is applied",
            "d) Sensor will function normally"
        ],
        "Answer": "Answer: a\nExplanation:  The Ultrasonic Sensors are mostly built to work on a voltage range of approximately 3.3V to 5V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 323,
        "Question": "If 1 means an object is detected and 0 meaning no object is detected, then considering the sensor is stationary, what can be said about the movement of the object if the output by the sensor is 1010101?",
        "Options": [
            "a) Object is stationary",
            "b) Object is oscillating side by side",
            "c) Object is continuously moving away",
            "d) Object is continuously moving closer"
        ],
        "Answer": "Answer: b\nExplanation: The only explanation for such output from the sensor would be if the object is moving in such a path, that makes it within the range of the sensor and vice versa after each specified amount of time and this continuously happens along a deterministic path so that we know that the only way this can happen is that if the object is oscillating between two given points.\n"
    },
    {
        "id": 324,
        "Question": "6. What is the final value of the d2 variable?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><pre class=\"de1\">const int trigPin = 9;\nconst int echoPin = 10;\nlong d1;\nint d2;\nvoid setup() {\n    pinMode(trigPin, OUTPUT);\n    pinMode(echoPin, INPUT);\n    Serial.begin(9600); \n}\nvoid loop() {\n    digitalWrite(trigPin, LOW);\n    delayMicroseconds(2);\n    digitalWrite(trigPin, HIGH);\n    delayMicroseconds(10);\n    digitalWrite(trigPin, LOW);\n    d1 = pulseIn(echoPin, HIGH);\n    d2 = d1*0.034/2;\n    Serial.println(d2);\n}</pre></div></div></div></div></div></div>",
        "Options": [
            "a) Distance",
            "b) Duration",
            "c) Time Period",
            "d) Position"
        ],
        "Answer": "Answer: a\nExplanation: The above code is used to find the distance between the sensor and the object. First, we set the TRIG pin LOW for 2 microseconds. After that, in order to start the sensor, we need to set the TRIG pin HIGH for 10 microseconds. Now using the pulseIn() function we find the duration of time in microseconds and then convert it to the distance and store it in the d2 variable.\n"
    },
    {
        "id": 325,
        "Question": "What kind of waves does the Ultrasonic Sensor work on?",
        "Options": [
            "a) Gas",
            "b) Heat",
            "c) Light",
            "d) Sound"
        ],
        "Answer": "Answer: d\nExplanation: The Ultrasonic Sensor works on Ultrasonic Sound Waves. These sound Waves are very powerful and have a very high frequency which results in low attenuation.\n"
    },
    {
        "id": 326,
        "Question": "What are the factors that affect the performance of the Ultrasonic Sensor during operation?",
        "Options": [
            "a) Distant Target Object",
            "b) Target Object hidden by fog",
            "c) Smoke",
            "d) Dust"
        ],
        "Answer": "Answer: a\nExplanation: The Ultrasonic Sensor uses sound Waves of very high frequency to locate and track objects that are in it’s range. The advantages of this technique is that since we are using sound Waves, other factors like most, or fog or anything that causes low visibility become immaterial. However, the only problem is since the sound Waves are propagated at every direction from the source, they become weak as the distance increases and so they are inefficient in dealing with long distance targets.\n"
    },
    {
        "id": 327,
        "Question": "What is the optimum current that is required to operate the Ultrasonic Sensor?",
        "Options": [
            "a) 20 mA",
            "b) 15 mA",
            "c) 200 A",
            "d) 1 A"
        ],
        "Answer": "Answer: b\nExplanation: The current rating on any Sensor is given so that users can know the what is the optimum current that needs to be fed to the active sensor such that the internal electronics is not destroyed by excess current.\n"
    },
    {
        "id": 328,
        "Question": "What is the maximum distance that the Ultrasonic Sensor can detect an object?",
        "Options": [
            "a) 8 cm",
            "b) 200 cm",
            "c) 9 cm",
            "d) 20.21 cm"
        ],
        "Answer": "Answer: b\nExplanation:  The maximum range of the Ultrasonic Sensor is the greatest distance upto which the sensor can pinpoint an object.\n"
    },
    {
        "id": 329,
        "Question": "What is the use of the ADXL-335 sensor?",
        "Options": [
            "a) To measure acceleration",
            "b) To measure heat",
            "c) To measure temperature",
            "d) To measure GPS Location"
        ],
        "Answer": "Answer: a\nExplanation: The ADXL-335 is an accelerometer which can calculate the instantaneous acceleration. It can be used for many applications, most importantly in phones, since it can be also used for calculating the roll or tilt.\n"
    },
    {
        "id": 330,
        "Question": "How many pins are present in the ADXL-335?",
        "Options": [
            "a) 1",
            "b) 4",
            "c) 2",
            "d) 5"
        ],
        "Answer": "Answer: d\nExplanation: The ADXL-335 Accelerometer has 5 pins which correspond to Vcc for powering the device, GND for completing the circuit, and X,Y,Z pins which give the sensor’s output to be calculated with the help of a microcontroller.\n"
    },
    {
        "id": 331,
        "Question": "What mode should the 3 axis pins of the ADXL-335 be read in, in an Arduino in order to obtain meaningful values?",
        "Options": [
            "a) Analog",
            "b) Digital",
            "c) PCM",
            "d) TDM"
        ],
        "Answer": "Answer: a\nExplanation: The axis pins of the ADXL-335 Accelerometer give output in the form of analog signals. These should then be read from the Arduino with the help of the “analogRead()” method so as to obtain the full voltage value that they are putting out.\n"
    },
    {
        "id": 332,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the ADXL-335 sensor?",
        "Options": [
            "a) Damage is caused",
            "b) Sensor will work fine",
            "c) Sensor will not respond for the time the voltage is applied",
            "d) Sensor will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The ADXL-335 Accelerometer modules are mostly built to work on a voltage range of approximately 3.3V to 5V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 333,
        "Question": "Which of the formulae give us the value of acceleration for the x-axis in the ADXL-335?",
        "Options": [
            "a) Axout = (((Value * Vref) / 1024) – 1.65) / 0.330",
            "b) Axout = (((Value * Vref) / 1024) – 1.65) / 2000",
            "c) Axout = (((Value * Vref) / 1024) – 1.65) / 330",
            "d) Axout = (((Value * Vref) / 1024) – 1.65) / 0.12"
        ],
        "Answer": "Answer: a\nExplanation: (((Value * Vref) / 1024) – 1.65) / 0.330 gives the correct value of acceleration along any axis of the accelerometer module. However, in order to make the equation work, we would need to plug in the values of the X-axis, Y-axis, and Z-axis separately in 3 different variables to obtain the value of acceleration along each individual axis.\n"
    },
    {
        "id": 334,
        "Question": "Which of the formulae give us the angle of inclination in the ADXL-335?",
        "Options": [
            "a) theta=atan(X_Value/sqrt((Y_Value*Y_Value)+(Z_Value*Z_Value)))",
            "b) theta=atan(X_Value/sqrt((Y_Value*Y_Value)*(Z_Value*Z_Value)))",
            "c) theta=atan(X_Value/sqrt((Y_Value)+(Z_Value*Z_Value)))",
            "d) theta=atan(X_Value/sqrt((Y_Value*Y_Value)+(Z_Value)))"
        ],
        "Answer": "Answer: a\nExplanation: atan(X_Value/sqrt((Y_Value*Y_Value)+(Z_Value*Z_Value))) gives the correct value of the angle of inclination of the accelerometer module. Here all the three values read from the 3 data pins of the ADXL-335 module are to be replaced in the equation at the same time in order for this to work.\n"
    },
    {
        "id": 335,
        "Question": "What kind of sensor is the ADXL-335 Accelerometer Module?",
        "Options": [
            "a) Passive",
            "b) Active",
            "c) Radio",
            "d) Pressure based"
        ],
        "Answer": "Answer: a\nExplanation: Yes, you can measure the acceleration of the train but in this case the acceleration value of the train is going to be 0 since acceleration is the rate of change of velocity with time and in this case since the velocity of the train is constant with respect to time, then the acceleration measured by the sensor should be 0.\n"
    },
    {
        "id": 336,
        "Question": "The ADXL-335 Accelerometer sensor module uses capacitive technology to detect changes. The Equation governing that function is given by C=f(A/d). What is the meaning of ‘A’ in the equation?",
        "Options": [
            "a) Area",
            "b) Air",
            "c) Antenna",
            "d) Acceleration"
        ],
        "Answer": "Answer: b\nExplanation: The ADXL-335 sensor is an active sensor since it requires an active DC voltage source to function properly. On the contrary, an LDR can be said to be a sort of a passive sensor since it does not require the input of current from an external source for its working.\n"
    },
    {
        "id": 337,
        "Question": "10. What is the drawback of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">int val, Vref=5;</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    Serial.begin(9600);</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    val= (((analogRead(A3) * Vref) / 1024) – 1.65) / 0.330;</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Wrong pin number",
            "b) Wrong equation",
            "c) Wrong target datatype",
            "d) Incorrect parenthesis"
        ],
        "Answer": "Answer: a\nExplanation: The ADXL-335 Accelerometer sensor uses capacitive technology to carry out its functions. I the equation C=f(A/d), ‘A’ stands for the area of the plate, and the ‘d’ stands for the distance of separation between the two plates.\n"
    },
    {
        "id": 338,
        "Question": "What is the use of the Nokia 5110 GDM?",
        "Options": [
            "a) To measure luminosity of something",
            "b) To display something",
            "c) To measure temperature",
            "d) To measure GPS Location"
        ],
        "Answer": "Answer: b\nExplanation: The Nokia 5110 Graphical Display Module is used to display various texts, images, and patterns. It is not a sensor so it cannot sense anything, but it gives an output, from a controlled signal so it behaves more like a transducer.\n"
    },
    {
        "id": 339,
        "Question": "How many pins are present in the Nokia 5110 GDM have?",
        "Options": [
            "a) 1",
            "b) 8",
            "c) 10",
            "d) 5"
        ],
        "Answer": "Answer: b\nExplanation: The Nokia 5110 Graphical Display Module has 8 pins based on the internal architecture of it’s microcontroller. The pins are Vcc which supplies voltage and powers the entire module, GND which completes the circuit, RST which resets the module’s display, CE, which enables communications to the onboard chip of the module, DC  and Dinis used to send data commands, Clk which is the clock pin, and BL which enables or disables the backlight of the display module.\n"
    },
    {
        "id": 340,
        "Question": "What kind of input does the DC pin accept?",
        "Options": [
            "a) Analog",
            "b) Digital",
            "c) PCM",
            "d) TDM"
        ],
        "Answer": "Answer: b\nExplanation: The DC pin of the Nokia 5110 Graphical Display Module accepts only binary input wherein 0 means that sending 0 or a logical LOW signal will prime the module to accept system commands while sending a 1 or a logical HIGH signal will prime the module to accept actual display data.\n"
    },
    {
        "id": 341,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the Nokia 5110 GDM?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The Nokia 5110 Graphical Display Modules are mostly built to work on a voltage range of approximately 3.3V to 5V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 342,
        "Question": "What will happen if we start using the Nokia 5110 GDM without resetting?",
        "Options": [
            "a) Damage is caused",
            "b) Module will work fine",
            "c) Module will not respond indefinitely",
            "d) Module will overheat"
        ],
        "Answer": "Answer: a\nExplanation: The Nokia 5110 Graphical Display Module requires you to apply a pulse to the RST pin which clears all the internal registers and primes the module to start accepting new commands. So, it is always necessary to wipe out the residual data.\n"
    },
    {
        "id": 343,
        "Question": "What communication protocol does the Nokia 5110 GDM follow?",
        "Options": [
            "a) SPI",
            "b) UART",
            "c) I2C",
            "d) API"
        ],
        "Answer": "Answer: a\nExplanation: The Nokia 5110 Graphical Display Module uses the SPI communication protocol. It means Serial Peripheral Interface and it allows only a single stream of data to be moved to and from the source and the deployment target.\n"
    },
    {
        "id": 344,
        "Question": "What is the use of the X and Y Addresses of the RAM for Display Control?",
        "Options": [
            "a) Rows and Columns",
            "b) Rows",
            "c) Columns",
            "d) Pixels"
        ],
        "Answer": "Answer: a\nExplanation: The X and Y addresses of the RAM in the Display Control unit of the Module are used for referring to the row and column position of a particular pixel on the monitor of the module.\n"
    },
    {
        "id": 345,
        "Question": "What is the use of the VLCD?",
        "Options": [
            "a) Temperature Control",
            "b) Heat Generation",
            "c) Shutting down the LCD",
            "d) Starting up the LCD"
        ],
        "Answer": "Answer: a\nExplanation: The LCD needs a particular optimum temperature to be able to function properly, so we have the temperature control registers TC0 and TC1 for that purpose so that the VLCD or the LCD controlling Voltage is regulated to the right temperature for maximum image contrast on the display module.\n"
    },
    {
        "id": 346,
        "Question": "What kind of images can the Nokia 5110 GDM display?",
        "Options": [
            "a) Colored Image",
            "b) Grayscale Image",
            "c) Binary Image",
            "d) Inverted Image"
        ],
        "Answer": "Answer: c\nExplanation: Since the pixels of the Nokia 5110 Graphical Display Module have only two states, that are either ON or OFF, it is able to only display binary bitmap images. So, while feeding the image to the module, the image must be converted to binary with the help of preprocessing software.\n"
    },
    {
        "id": 347,
        "Question": "10. What is the drawback of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">#include &lt;SPI.h&gt;</pre></li><li class=\"li1\"><pre class=\"de1\">#include &lt;Adafruit_GFX&gt;</pre></li><li class=\"li1\"><pre class=\"de1\">#include &lt;Adafruit_PCD8544.h&gt;</pre></li><li class=\"li1\"><pre class=\"de1\">#include \"images.h\"</pre></li><li class=\"li1\"><pre class=\"de1\">Adafruit_PCD8544 display = Adafruit_PCD8544(13, 11, 8, 7, 9);</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    display.begin();</pre></li><li class=\"li1\"><pre class=\"de1\">    display.setContrast(50);  </pre></li><li class=\"li1\"><pre class=\"de1\">    display.clearDisplay();  </pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {  </pre></li><li class=\"li1\"><pre class=\"de1\">    display.clearDisplay();</pre></li><li class=\"li1\"><pre class=\"de1\">    display.drawBitmap(0, 0, Face, 84, 48, 1);</pre></li><li class=\"li1\"><pre class=\"de1\">    display.display();</pre></li><li class=\"li1\"><pre class=\"de1\">    delay(300);</pre></li><li class=\"li1\"><pre class=\"de1\">    display.clearDisplay();</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Wrong header file name",
            "b) Wrong display coordinate",
            "c) Wrong target datatype",
            "d) Incorrect parenthesis"
        ],
        "Answer": "Answer: a\nExplanation: The code misspelled the Adafruit GFX library by not adding the C header file name extension “.h” at the end of the name. The Adafruit GFX library is very important as it pairs the Arduino and allows it to talk to TFT displays connected to it.\n"
    },
    {
        "id": 348,
        "Question": "What is the use of the GSR Sensor?",
        "Options": [
            "a) Monitors electrodermal activity",
            "b) Monitors skin capacitance",
            "c) Monitors skin temperature",
            "d) Monitors heartbeat"
        ],
        "Answer": "Answer: a\nExplanation: The GSR Sensor stands for Galvanic Skin Response Sensor. This sensor can monitor the electrical conductance or the electrodermal activity and help us classify the emotion of a person.\n"
    },
    {
        "id": 349,
        "Question": "How many pins are present in the GSR Sensor?",
        "Options": [
            "a) 1",
            "b) 4",
            "c) 10",
            "d) 5"
        ],
        "Answer": "Answer: b\nExplanation: The GSR Sensor has 4 pins. These are the Vcc for powering the sensor, GND for completing the circuit, and SIG and NC being the data pins.\n"
    },
    {
        "id": 350,
        "Question": "What kind of output does the SIG pin give?",
        "Options": [
            "a) Analog",
            "b) Digital",
            "c) PCM",
            "d) TDM"
        ],
        "Answer": "Answer: a\nExplanation: The SIG pin gives us the actual data received by the sensor, and since the value can fluctuate very easily it is an Analog pin.\n"
    },
    {
        "id": 351,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the GSR Sensor?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The GSR Sensors are mostly built to work on a voltage range of approximately 3.3V to 5V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 352,
        "Question": "How many electrodes does the GSR Sensor need?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 5",
            "d) 2"
        ],
        "Answer": "Answer: d\nExplanation: The GSR Sensor needs 2 electrodes to complete the circuit with your body in order to obtain a reading. The sensor records the resistance formed by the load that is your body and outputs the data to the A0 or the SIG pin.\n"
    },
    {
        "id": 353,
        "Question": "What is the optimum current that is required to operate the GSR Sensor?",
        "Options": [
            "a) 20 mA",
            "b) 15 mA",
            "c) 200 A",
            "d) 1 A"
        ],
        "Answer": "Answer: b\nExplanation: The current rating on any Sensor is given so that users can know what is the optimum current that needs to be fed to the active sensor such that the internal electronics is not destroyed by excess current.\n"
    },
    {
        "id": 354,
        "Question": "What kind of sensor is the GSR Sensor?",
        "Options": [
            "a) Passive",
            "b) Active",
            "c) Radio",
            "d) Pressure based"
        ],
        "Answer": "Answer: b\nExplanation: The GSR sensor is an active sensor since it requires an active DC voltage source to function properly. On the contrary, an LDR can be said to be a sort of a passive sensor since it does not require the input of current from an external source for its working.\n"
    },
    {
        "id": 355,
        "Question": "What can the GSR Sensor’s function be applied to?",
        "Options": [
            "a) Sleep Analysis",
            "b) Heat Generation",
            "c) Injury Detection",
            "d) Physical health issues"
        ],
        "Answer": "Answer: a\nExplanation: The GSR Sensor gives the electrodermal activity of the person in the form of a convenient number. So, in real time it can be used to track sleep defects in patients.\n"
    },
    {
        "id": 356,
        "Question": "What is the unit for skin conductance?",
        "Options": [
            "a) Mega Siemens",
            "b) Deca Siemens",
            "c) Micro Siemens",
            "d) Octa Siemens"
        ],
        "Answer": "Answer: c\nExplanation: The unit of skin conductance is micro Siemens. It works by applying a very small voltage across the two terminals of the sensor and then recording the current passing through the body.\n"
    },
    {
        "id": 357,
        "Question": "What voltage is applied between the two electrodes or terminals of the GSR Sensor?",
        "Options": [
            "a) 1 V",
            "b) 0.5V",
            "c) 330 mV",
            "d) 10 V"
        ],
        "Answer": "Answer: b\nExplanation: A voltage of 0.5 v is applied across the terminals and the current passing through the body is recorded and finally the value of EDA is calculated.\n"
    },
    {
        "id": 358,
        "Question": "What is the use of the MPU 6050 Sensor?",
        "Options": [
            "a) Monitors Motion",
            "b) Monitors air pressure",
            "c) Monitors objects",
            "d) Monitors heartbeat"
        ],
        "Answer": "Answer: a\nExplanation:  The MPU 6050 Sensor is a complete motion tracking device which comes equipped out of the box with a gyroscope for tracking tilt, roll, etc.. , accelerometer for tracking motion, and a temperature sensor.\n"
    },
    {
        "id": 359,
        "Question": "How many pins are present in the MPU6050 Sensor?",
        "Options": [
            "a) 1",
            "b) 4",
            "c) 8",
            "d) 5"
        ],
        "Answer": "Answer: b\nExplanation: The MPU 6050 Sensor has 8 pins which includes the Vcc, GND, INT, AD0, XCL, XDA, SDA, and SCL. All these pins have very specific functions and input patterns which need to be connected in perfect order in order for the sensor to function properly.\n"
    },
    {
        "id": 360,
        "Question": "What is the use of the AD0 pin?",
        "Options": [
            "a) I2C Slave Address LSB Pin",
            "b) SPI Master Address MSB Pin",
            "c) UART Slave Address LSB Pin",
            "d) UART Master Address LSB Pin"
        ],
        "Answer": "Answer: a\nExplanation: The AD0 pin is the I2C Slave Address LSB pin on the MPU 6050. This is 0th bit in 7-bit slave address of device. If connected to VCC then it is read as logical HIGH and slave address changes.\n"
    },
    {
        "id": 361,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the MPU 6050 Sensor?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The MPU 6050 Sensors are mostly built to work on a voltage range of approximately 3.3V to 5V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 362,
        "Question": "Which of the formulae give us the angular velocity in the MPU 6050 along the X axis?",
        "Options": [
            "a) Angular velocity along the X axis = (Gyroscope X axis raw data/131) °/s",
            "b) Angular velocity along the X axis = (Gyroscope X axis raw data/132) °/s",
            "c) Angular velocity along the X axis = (Gyroscope X axis raw data/12) °/s",
            "d) Angular velocity along the X axis = (Gyroscope X axis raw data/130) °/s"
        ],
        "Answer": "Answer: a\nExplanation: (Gyroscope X axis raw data/131) °/s gives the correct value of the angular velocity of the MPU 6050 sensor. Here all the three values read from the 3 data pins of the Gyroscope module in the MPU 6050 are to be replaced in the equation one by one in order to get the 3D Model.\n"
    },
    {
        "id": 363,
        "Question": "What is the optimum current that is required to operate the MPU 6050 Sensor?",
        "Options": [
            "a) 20 mA",
            "b) 15 mA",
            "c) 200 A",
            "d) 1 A"
        ],
        "Answer": "Answer: b\nExplanation: The current rating on any Sensor is given so that users can know what is the optimum current that needs to be fed to the active sensor such that the internal electronics is not destroyed by excess current.\n"
    },
    {
        "id": 364,
        "Question": "What kind of sensor is the MPU 6050 Sensor?",
        "Options": [
            "a) Passive",
            "b) Active",
            "c) Radio",
            "d) Pressure based"
        ],
        "Answer": "Answer: b\nExplanation: The MPU 6050 sensor is an active sensor since it requires an active DC voltage source to function properly. On the contrary, an LDR can be said to be a sort of a passive sensor since it does not require the input of current from an external source for its working.\n"
    },
    {
        "id": 365,
        "Question": "What is the datatype of the output given by the temperature module on the MPU 6050?",
        "Options": [
            "a) Signed Double",
            "b) Unsigned Byte",
            "c) Signed Int",
            "d) Unsigned Float"
        ],
        "Answer": "Answer: c\nExplanation: The temperature module gives us a signed integer in order to depict the current temperature. This helps because then we can have the full range of both the positive and the negative temperature scale.\n"
    },
    {
        "id": 366,
        "Question": "What is the formula for calculating the temperature in degrees celsius from the raw data gathered by the temperature module of the MPU 6050?",
        "Options": [
            "a) Temperature in degrees celsius = ((temperature sensor data)/340 + 36.53) °/c",
            "b) Temperature in degrees celsius = ((temperature sensor data)/340 + 36) °/c",
            "c) Temperature in degrees celsius = ((temperature sensor data) + 36.53) °/c",
            "d) Temperature in degrees celsius = ((temperature sensor data)/340 * 36.53) °/c"
        ],
        "Answer": "Answer: a\nExplanation: ((temperature sensor data)/340 + 36.53) °/c gives the correct value of the temperature recorded by the MPU 6050 sensor. This is in the form of a signed int so as to denote negative temperatures too thus giving us the full range.\n"
    },
    {
        "id": 367,
        "Question": "Which of the formulae give us the acceleration in the MPU 6050 along the X axis?",
        "Options": [
            "a) Acceleration along the X axis = (Accelerometer X axis raw data/16384) g",
            "b) Acceleration along the X axis = (Accelerometer X axis raw data/1634) g",
            "c) Acceleration along the X axis = (Accelerometer X axis raw data/1384) g",
            "d) Acceleration along the X axis = (Accelerometer X axis raw data/1622) g"
        ],
        "Answer": "Answer: a\nExplanation: (Accelerometer X axis raw data/16384) gives the correct value of the acceleration of the MPU 6050 sensor. Here all the three values read from the 3 data pins of the Accelerometer module in the MPU 6050 are to be replaced in the equation one by one in order to get the 3D Model.\n"
    },
    {
        "id": 368,
        "Question": "What is the use of the LDR Sensor?",
        "Options": [
            "a) Monitors Motion",
            "b) Monitors air pressure",
            "c) Monitors Light Intensity",
            "d) Monitors heartbeat"
        ],
        "Answer": "Answer: c\nExplanation:  An LDR Sensor is used to measure the light intensity of the space surrounding it. Similar variations of these kinds of sensors are used in phones which allow manufacturers to turn off the screen when you place your phone to your ear during a call.\n"
    },
    {
        "id": 369,
        "Question": "How many pins are present in the LDR Sensor?",
        "Options": [
            "a) 1",
            "b) 4",
            "c) 2",
            "d) 5"
        ],
        "Answer": "Answer: c\nExplanation: The LDR is a passive sensor, which means it does not require any external voltage supply for it to run. So it only has two terminals which are to be connected in parallel for maximum performance and so that if the LDR becomes defunct, it does not affect the working of the entire circuit.\n"
    },
    {
        "id": 370,
        "Question": "What is the full form of the LDR Sensor?",
        "Options": [
            "a) Lithium Diode Resistor",
            "b) Light Diaphragm Resistor",
            "c) Lithium Disk Resistor",
            "d) Light Dependent Resistor"
        ],
        "Answer": "Answer: d\nExplanation: An LDR is called a Light Dependent Resistor. It is also called a photo-resistor or a cadmium sulfide cell. It is a photocell that works on the principle of photo-conductivity. It’s resistance value decreases when the intensity of light decreases and vice-versa.\n"
    },
    {
        "id": 371,
        "Question": "What will happen if we supply a voltage of 250 kV to the terminal of the LDR Sensor?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The LDR Sensors are mostly built to work on a voltage range that is not too high and should not be used for high power usage as it will burn up. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 372,
        "Question": "Which of the formulae give us the relation between resistance and illumination in the LDR Sensor?",
        "Options": [
            "a) Resistance = Constant_1 * (Illumination^Constant_2)",
            "b) Resistance = Constant_1 * (Illumination+Constant_2)",
            "c) Resistance = Constant_1 ^ (Illumination-Constant_2)",
            "d) Resistance = Constant_1 + (Illumination^Constant_2)"
        ],
        "Answer": "Answer: a\nExplanation:  Constant_1 * (Illumination^Constant_2) gives the correct relation between the resistance and the illumination in the LDR sensor. Here the SI unit of resistance is Ohms and that of Illumination is Lux.\n"
    },
    {
        "id": 373,
        "Question": "Which one of the following materials would be used for making an LDR?",
        "Options": [
            "a) Lead Sulfide",
            "b) Pure Aluminum",
            "c) Iron Ore",
            "d) Aluminum Oxide"
        ],
        "Answer": "Answer: a\nExplanation: What the LDR needs is a semiconductor. So that when some light having enough energy strikes on it, more electrons are excited to the conduction band which results in large number of charge carriers which in turn results in current flowing through it when the circuit is closed.\n"
    },
    {
        "id": 374,
        "Question": "What kind of sensor is the LDR Sensor?",
        "Options": [
            "a) Passive",
            "b) Active",
            "c) Radio",
            "d) Pressure based"
        ],
        "Answer": "Answer: a\nExplanation: The LDR sensor is a passive sensor since it requires no external supply of voltage in order for it to work. It simply acts as a variable resistor and changes the resistance of itself while light of varying intensity falls on it.\n"
    },
    {
        "id": 375,
        "Question": "If an LDR is connected to an LED and a battery and is brought from the dark to the light, what will be the state of the LED?",
        "Options": [
            "a) Lit",
            "b) Not lit",
            "c) Damaged by voltage change",
            "d) Damaged by power surge"
        ],
        "Answer": "Answer: a\nExplanation: The resistance of an LDR depends upon the amount of light that is incident on it. So greater the light intensity, lesser is it’s resistance, and so greater is the current flowing through to the LED making it brighter.\n"
    },
    {
        "id": 376,
        "Question": "How much time on an average does the LDR take for it’s resistance to change when light is incident?",
        "Options": [
            "a) 8 to 12 ms",
            "b) 12 min",
            "c) 30 s",
            "d) 354 hr"
        ],
        "Answer": "Answer: b\nExplanation: LDR’s are non linear devices. Their sensitivity varies with the wavelength of light that’s incident on them. Some LDR’s might not response to a certain range of wavelengths at all depending upon the kind of material used in different devices, which consequently have different spectral response curves.\n"
    },
    {
        "id": 377,
        "Question": "What is the use of the Relay (Dual Channel) Module?",
        "Options": [
            "a) Monitors Motion",
            "b) Evaluates air pressure",
            "c) Monitors objects",
            "d) Switches circuits"
        ],
        "Answer": "Answer: d\nExplanation: The Relay (Dual Channel) Module is used for controlling a circuit by one signal or when many circuits must be controlled by one signal. Thus making it a primarily switching device.\n"
    },
    {
        "id": 378,
        "Question": "How many pins are present in the Relay (Dual Channel) Module?",
        "Options": [
            "a) 12",
            "b) 220",
            "c) 13",
            "d) 50"
        ],
        "Answer": "Answer: c\nExplanation: The Relay (Dual Channel) Module has 13 pins which includes the 2 Vcc’s, 2 GND’s, IN1 and IN2 which are the two input channels, 2 NC’s, 2 NO’s and 2 COM’s. All these pins have very specific functions and input patterns which need to be connected in perfect order in order for the module to function properly.\n"
    },
    {
        "id": 379,
        "Question": "What is the use of the IN1 and IN2 pin?",
        "Options": [
            "a) Input",
            "b) Output",
            "c) Ground",
            "d) Power input"
        ],
        "Answer": "Answer: a\nExplanation: The IN1 and IN2 respectively are used for sending digital inputs to the module. They accept 5V usually if the module has a 5V rating. Some modules also come with a 3.3V rating so it is important to check the rating of the module to be used.\n"
    },
    {
        "id": 380,
        "Question": "What will happen if we supply a voltage of 250 kV to the Vcc of the Relay (Dual Channel) module?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The Relay modules  are mostly built to work on a voltage range of approximately 3.3V to 5V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 381,
        "Question": "What is the use of the COM pin?",
        "Options": [
            "a) Input",
            "b) Output",
            "c) Ground",
            "d) Circuit Completion"
        ],
        "Answer": "Answer: d\nExplanation: The COM pin is used for completing the circuit such that the relay module can function fully when connected to the micro-controller. There are 2 COM pins, 1 for each channel.\n"
    },
    {
        "id": 382,
        "Question": "What is the optimum current that is required to operate the Relay Module?",
        "Options": [
            "a) 28 A",
            "b) 13 A",
            "c) 210 A",
            "d) 1 A"
        ],
        "Answer": "Answer: a\nExplanation: The current rating on the Relay Module is given so that users can know what is the optimum current that needs to be fed to the module such that the internal electronics is not destroyed by excess current.\n"
    },
    {
        "id": 383,
        "Question": "What kind of device is the Relay Module?",
        "Options": [
            "a) Passive Sensor",
            "b) Active Sensor",
            "c) Radio Device",
            "d) Switching Device"
        ],
        "Answer": "Answer: d\nExplanation: The Relay Module is a switching device since it’s primary function is to switch or change the direction of flow of current or stop it altogether. This way it controls the working of any given circuit.\n"
    },
    {
        "id": 384,
        "Question": "What is the type of output given by the DC Relay Module?",
        "Options": [
            "a) Analog Signal",
            "b) AC Signal",
            "c) DC Signal",
            "d) Hybrid Signal"
        ],
        "Answer": "Answer: c\nExplanation: The Relay Module can switch current flow depending upon the rating of  it. If the Relay Module has been rated for DC Usage then it should not be used for AC Circuits and vice-versa.\n"
    },
    {
        "id": 385,
        "Question": "How much time does it take for the relay module to react to a change?",
        "Options": [
            "a) 5 to 10 ms",
            "b) 12 to 10 min",
            "c) 52 to 100 ms",
            "d) 5 to 10 s"
        ],
        "Answer": "Answer: a\nExplanation:  5 to 10 ms is the correct value of the time needed for the module to react to any command given to it by an external voltage source or micro-controller.\n"
    },
    {
        "id": 386,
        "Question": "What happens to the NO1 and NO2 pins when INT1 and INT2 is HIGH?",
        "Options": [
            "a) Gets connected to COM",
            "b) Gets disconnected from COM",
            "c) Gets connected to Vcc",
            "d) Gets connected to GND"
        ],
        "Answer": "Answer: b\nExplanation: A disconnected COM port gives the correct value of the state of the NO1 and NO2 pins when 5V or logical HIGH signal is fed to the INT1 and INT2 pins. Conversely they also get connected to the COM when INT1 and INT2 pins are set to LOW.\n"
    },
    {
        "id": 387,
        "Question": "What is the use of the Motor Driver (L293D) Module?",
        "Options": [
            "a) Monitors Motion",
            "b) Evaluates air pressure",
            "c) Controls Motors",
            "d) Switches circuits"
        ],
        "Answer": "Answer: d\nExplanation: The Motor Driver (L293D)  Module is used for controlling motors by one micro-controller or when many motors must be controlled by one micro-controller.\n"
    },
    {
        "id": 388,
        "Question": "How many pins are present in the Motor Driver (L293D) Module?",
        "Options": [
            "a) 12",
            "b) 16",
            "c) 13",
            "d) 50"
        ],
        "Answer": "Answer: b\nExplanation: The L293D Motor Driver Module contains 16 pins which include 4 GND pins, 4 Vcc pins, 4 Output pins, 2 Enabling pins and 2 Voltage pins. All these pins have very specific functions and input patterns which need to be connected in perfect order in order for the module to function properly.\n"
    },
    {
        "id": 389,
        "Question": "What is the use of the EN1_2 pin?",
        "Options": [
            "a) Input",
            "b) Output",
            "c) Activation",
            "d) Power input"
        ],
        "Answer": "Answer: c\nExplanation: The EN1_2 pin is used to enable a part of the IC which controls a segment of the motors connected to it. They accept 5V usually if the module has a 5V rating.\n"
    },
    {
        "id": 390,
        "Question": "What will happen if we supply a voltage of 250 kV to the Vcc of the L293D module?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The L293D modules  are mostly built to work on a voltage of approximately 5V. Any voltage lower than that and the module will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 391,
        "Question": "What is the use of the EN3_4 pin?",
        "Options": [
            "a) Input",
            "b) Output",
            "c) Activation",
            "d) Power input"
        ],
        "Answer": "Answer: c\nExplanation: The EN3_4 pin is used to enable a part of the IC which controls a segment of the motors connected to it. They accept 5V usually if the module has a 5V rating.\n"
    },
    {
        "id": 392,
        "Question": "What is the use of the OUT1 and OUT2 pins?",
        "Options": [
            "a) Input",
            "b) Output",
            "c) Activation",
            "d) Power input"
        ],
        "Answer": "Answer: b\nExplanation: The OUT1 and OUT2 pins are used to control the motors that are connected to the IC. They accept up to 5V usually if the module has a 5V rating.\n"
    },
    {
        "id": 393,
        "Question": "What is the use of the Vcc2 pin?",
        "Options": [
            "a) Input",
            "b) Output",
            "c) Activation",
            "d) Power input"
        ],
        "Answer": "Answer: d\nExplanation: The Vcc2 pin is used to input a high amount of voltage and is not internally used by the IC. It is there to power the motors attached to it. This way the same IC can be used for controlling higher powered motors.\n"
    },
    {
        "id": 394,
        "Question": "What is the use of the Vcc1 pin?",
        "Options": [
            "a) Input",
            "b) Output",
            "c) Activation",
            "d) Power input"
        ],
        "Answer": "Answer: d\nExplanation: The Vcc1 pin is used for powering the internal IC components. It accepts a maximum of 5V approximately. This should not be confused with the Vcc2 pin which powers the motors as that could lead to the blowout of the IC.\n"
    },
    {
        "id": 395,
        "Question": "What happens when the sequence 0 1 1 is fed to the IN1, IN2 and EN1_2 pins respectively?",
        "Options": [
            "a) Clockwise Motor Rotation",
            "b) Anticlockwise Motor Rotation",
            "c) Stops Motor Rotation",
            "d) Stalls Motor Rotation"
        ],
        "Answer": "Answer: b\nExplanation: Anticlockwise motor rotation  gives the correct logic sequence which enables the micro-controller to turn one set of motors anticlockwise. This is true for the other set too.\n"
    },
    {
        "id": 396,
        "Question": "What happens when the sequence 1 1 1 is fed to the IN3, IN4 and EN3_4 pins respectively?",
        "Options": [
            "a) Clockwise Motor Rotation",
            "b) Anticlockwise Motor Rotation",
            "c) Stops Motor Rotation",
            "d) Stalls Motor Rotation"
        ],
        "Answer": "Answer: c\nExplanation: Stopping motor rotation altogether gives the correct logic sequence which enables the micro-controller to stop one set of motors. This is true for the other set too.\n"
    },
    {
        "id": 397,
        "Question": "What is the use of the ESP8266 WiFi Module?",
        "Options": [
            "a) Monitors Motion",
            "b) Evaluates air pressure",
            "c) Network Provider",
            "d) Switches circuits"
        ],
        "Answer": "Answer: c\nExplanation: The ESP8266 WiFi Module is basically a network provider module which helps your micro-controller to connect to any WiFi network in the vicinity.\n"
    },
    {
        "id": 398,
        "Question": "How many pins are present in the ESP8266 WiFi Module?",
        "Options": [
            "a) 12",
            "b) 10",
            "c) 8",
            "d) 50"
        ],
        "Answer": "Answer: c\nExplanation: The ESP8266 WiFi Module has 8 pins which includes the GPIO-0, GPIO-1, RX, TX, Vcc, GND and CH_EN. All these pins have very specific functions and input patterns which need to be connected in perfect order in order for the module to function properly.\n"
    },
    {
        "id": 399,
        "Question": "What is the use of the TX pin?",
        "Options": [
            "a) Upload",
            "b) Download",
            "c) Ground",
            "d) Power input"
        ],
        "Answer": "Answer: a\nExplanation: The TX pin is used for connecting to RX pin of programmer micro-controller  to upload the program usually. It can also be used as a general purpose Input/output pin.\n"
    },
    {
        "id": 400,
        "Question": "What will happen if we supply a voltage of 250 kV to the Vcc of the ESP8266 WiFi Module?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The ESP8266 WiFi Modules are mostly built to work on a voltage of approximately 3.3V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 401,
        "Question": "What is the maximum source current that is required to operate the ESP8266 WiFi Module?",
        "Options": [
            "a) 28 A",
            "b) 12 mA",
            "c) 100 mA",
            "d) 1 A"
        ],
        "Answer": "Answer: b\nExplanation: The source current rating on the ESP8266 WiFi Module is given so that users can know what is the maximum value of the IO Source Current in the module such that the internal electronics is not destroyed by excess current supplied.\n"
    },
    {
        "id": 402,
        "Question": "What is the optimum supply current that is required to operate the ESP8266 WiFi Module?",
        "Options": [
            "a) 28 A",
            "b) 13 mA",
            "c) 100 mA",
            "d) 1 A"
        ],
        "Answer": "Answer: c\nExplanation: The current rating on the ESP8266 WiFi Module is given so that users can know what is the optimum current that needs to be fed to the module such that the internal electronics is not destroyed by excess current.\n"
    },
    {
        "id": 403,
        "Question": "What kind of device is the ESP8266 WiFi Module?",
        "Options": [
            "a) Passive Sensor",
            "b) Active Sensor",
            "c) Networking Device",
            "d) Switching Device"
        ],
        "Answer": "Answer: c\nExplanation: The ESP8266 WiFi Module is a networking device since it’s main function in any system is to be able to connect to any nearby WiFi network for uploading or downloading data hence enabling IOT.\n"
    },
    {
        "id": 404,
        "Question": "What is the type of waves that the ESP8266 WiFi Module detects?",
        "Options": [
            "a) Infrared Signal",
            "b) Radio Signal",
            "c) DC Signal",
            "d) Hybrid Signal"
        ],
        "Answer": "Answer: b\nExplanation: The ESP8266 WiFi Module detects WiFi and connects to the network. Since WiFi is a kind of radio frequency signal so the main purpose is to detect signals that fall into that kind of frequency range on the spectrum.\n"
    },
    {
        "id": 405,
        "Question": "What mode does the ESP8266 WiFi Module switch to when fed the sequence 1 1 to its GPIO-0 and GPIO-2 Pins?",
        "Options": [
            "a) UART Mode",
            "b) Sleep Mode",
            "c) Active Mode",
            "d) Flash Mode"
        ],
        "Answer": "Answer: d\nExplanation: UART Mode  gives the correct combination of input needed for the module to run the program that is already uploaded to the module.\n"
    },
    {
        "id": 406,
        "Question": "What mode does the ESP8266 WiFi Module switch to when fed the sequence 0 1 to its GPIO-0 and GPIO-2 Pins?",
        "Options": [
            "a) UART Mode",
            "b) Sleep Mode",
            "c) Active Mode",
            "d) Flash Mode"
        ],
        "Answer": "Answer: a\nExplanation: UART Mode  gives the correct combination of input needed for the module to program using Arduino or any serial communication supplied to it externally.\n"
    },
    {
        "id": 407,
        "Question": "What is the use of the OV7670 Camera Module?",
        "Options": [
            "a) Monitors Motion",
            "b) Evaluates air pressure",
            "c) Network Provider",
            "d) Image Capture"
        ],
        "Answer": "Answer: d\nExplanation: The OV7670 Camera Module is basically an image capturing device which is designed for use in embedded systems. It uses a 3.3V Power supply and an external oscillator provides the clock source for the XCLK pin.\n"
    },
    {
        "id": 408,
        "Question": "How many pins are present in the OV7670 Camera Module?",
        "Options": [
            "a) 18",
            "b) 10",
            "c) 8",
            "d) 50"
        ],
        "Answer": "Answer: a\nExplanation: The OV7670 Camera Module has 18 pins which includes the Vdd for Power supply, GND for grounding, SDIOC for SCCB clock, SDIOD for SCCB data, VSYNC for Vertical Sync, HREF for Horizontal Sync, PCLK for Pixel Clock, XCLK for System Clock, D0 to D7 pins are for Video output, RESET for resetting the module, and PDWN for powering down the module.\n"
    },
    {
        "id": 409,
        "Question": "What is the resolution of the OV7670 Camera Module?",
        "Options": [
            "a) 640×480 VGA",
            "b) 640×481 VGA",
            "c) 640×1020 VGA",
            "d) 640×12 VGA"
        ],
        "Answer": "Answer: a\nExplanation: 640×480 VGA is the correct resolution of the OV7670 Camera Module. The resolution of a camera is the number of pixels that the camera output has,both horizontal and vertical that forms the image matrix, be it for still images or video outputs.\n"
    },
    {
        "id": 410,
        "Question": "What will happen if we supply a voltage of 250 kV to the Vdd of the EOV7670 Camera Module ?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The OV7670 Camera Modules are mostly built to work on a voltage of approximately 3.3V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 411,
        "Question": "What is the nature of the video output protocol in the OV7670 Camera Module?",
        "Options": [
            "a) Serial Analog",
            "b) Parallel Analog",
            "c) Parallel Digital",
            "d) Serial Digital"
        ],
        "Answer": "Answer: b\nExplanation: The OV7670 Camera Module has a voltage rating of 3.3V so if we are to connect it to the 5V Arduino output, it will damage the internal circuit for the module. So we need to add a potential divider in the area to bring the voltage down.\n"
    },
    {
        "id": 412,
        "Question": "What kind of device is the ESP8266 WiFi Module?",
        "Options": [
            "a) Passive Sensor",
            "b) Active Sensor",
            "c) Transducer Device",
            "d) Switching Device"
        ],
        "Answer": "Answer: c\nExplanation: The output format in the  OV7670 Camera Module is Parallel Digital. This is due to the fact that it has 8 pins dedicated to video output marked from D0 to D7 on the module which are to be connected to the Arduino for the output.\n"
    },
    {
        "id": 413,
        "Question": "What is the type of waves that the ESP8266 WiFi Module detects?",
        "Options": [
            "a) Infrared Signal",
            "b) Radio Signal",
            "c) VL Signal",
            "d) Hybrid Signal"
        ],
        "Answer": "Answer: c\nExplanation: The OV7670 Camera Module acts like a transducer. Transducers convert an input from one physical form to another. In this case, the camera module converts light patterns into electrical signals to be used for further processing.\n"
    },
    {
        "id": 414,
        "Question": "What technology does the  OV7670 Camera Module use for image sub-sampling?",
        "Options": [
            "a) VarioPixel",
            "b) ConstPix",
            "c) Activarr",
            "d) Tidal"
        ],
        "Answer": "Answer: c\nExplanation: The OV7670 Camera Module detects light wave patterns which fall in the visible spectrum, that is approximately 700 nm. This is roughly the light waves which are also visible to the naked human eye.\n"
    },
    {
        "id": 415,
        "Question": "What is the use of the Nokia 5110 GDM?",
        "Options": [
            "a) To measure luminosity of something",
            "b) To display something",
            "c) To measure temperature",
            "d) To measure GPS Location"
        ],
        "Answer": "Answer: b\nExplanation: The Nokia 5110 Graphical Display Module is used to display various texts, images, and patterns. It is not a sensor so it cannot sense anything, but it gives an output, from a controlled signal so it behaves more like a transducer.\n"
    },
    {
        "id": 416,
        "Question": "How many pins are present in the Nokia 5110 GDM have?",
        "Options": [
            "a) 1",
            "b) 8",
            "c) 10",
            "d) 5"
        ],
        "Answer": "Answer: b\nExplanation: The Nokia 5110 Graphical Display Module has 8 pins based on the internal architecture of it’s microcontroller. The pins are Vcc which supplies voltage and powers the entire module, GND which completes the circuit, RST which resets the module’s display, CE, which enables communications to the onboard chip of the module, DC  and Dinis used to send data commands, Clk which is the clock pin, and BL which enables or disables the backlight of the display module.\n"
    },
    {
        "id": 417,
        "Question": "What kind of input does the DC pin accept?",
        "Options": [
            "a) Analog",
            "b) Digital",
            "c) PCM",
            "d) TDM"
        ],
        "Answer": "Answer: b\nExplanation: The DC pin of the Nokia 5110 Graphical DIsplay Module accepts only binary input wherein 0 means that sending 0 or a logical LOW signal will prime the module to accept system commands while sending a 1 or a logical HIGH signal will prime the module to accept actual display data.\n"
    },
    {
        "id": 418,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the Nokia 5110 GDM?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The Nokia 5110 Graphical Display Modules  are mostly built to work on a voltage range of approximately 3.3V to 5V. Any voltage lower than that and the sensor will not be able to power on, but however any voltage significantly above that and the sensor may suffer permanent damage.\n"
    },
    {
        "id": 419,
        "Question": "What will happen if we start using the Nokia 5110 GDM without resetting?",
        "Options": [
            "a) Damage is caused",
            "b) Module will work fine",
            "c) Module will not respond indefinitely",
            "d) Module will overheat"
        ],
        "Answer": "Answer: a\nExplanation: The Nokia 5110 Graphical Display Module  requires you to apply a pulse to the RST pin which clears all the internal registers and primes the module to start accepting new commands. So it is always necessary to wipe out the residual data.\n"
    },
    {
        "id": 420,
        "Question": "What communication protocol does the Nokia 5110 GDM follow?",
        "Options": [
            "a) SPI",
            "b) UART",
            "c) I2C",
            "d) API"
        ],
        "Answer": "Answer: a\nExplanation: The Nokia 5110 Graphical Display Module uses the SPI communication protocol. It means Serial Peripheral Interface and it allows only a single stream of data to be moved to and from the source and the deployment target.\n"
    },
    {
        "id": 421,
        "Question": "What is the use of the X and Y Addresses of the RAM for Display Control?",
        "Options": [
            "a) Rows and Columns",
            "b) Rows",
            "c) Columns",
            "d) Pixels"
        ],
        "Answer": "Answer: a\nExplanation: The X and Y addresses of the RAM in the Display Control unit of the Module are used for referring to the row and column position of a particular pixel on the monitor of the module.\n"
    },
    {
        "id": 422,
        "Question": "What is the use of the VLCD?",
        "Options": [
            "a) Temperature Control",
            "b) Heat Generation",
            "c) Shutting down the LCD",
            "d) Starting up the LCD"
        ],
        "Answer": "Answer: a\nExplanation: The LCD needs a particular optimum temperature to be able to function properly, so we have the temperature control registers TC0 and TC1 for that purpose so that the VLCD or the LCD controlling Voltage is regulated to the right temperature for maximum image contrast on the display module.\n"
    },
    {
        "id": 423,
        "Question": "What kind of images can the Nokia 5110 GDM display?",
        "Options": [
            "a) Colored Image",
            "b) Grayscale Image",
            "c) Binary Image",
            "d) Inverted Image"
        ],
        "Answer": "Answer: c\nExplanation: Since the pixels of the Nokia 5110 Graphical Display Module have only two states, that are either ON or OFF, it is able to only display binary bitmap images. So while feeding the image to the module, the image must be converted to binary with the help of preprocessing software.\n"
    },
    {
        "id": 424,
        "Question": "10. What is the drawback of the code given below?<div class=\"hk1_style-wrap4\"><div class=\"hk1_style-wrap3\"><div class=\"hk1_style-wrap2\"><div class=\"hk1_style-wrap\"><div class=\"hk1_style\"><div class=\"text\"><ol><li class=\"li1\"><pre class=\"de1\">#include &lt;SPI.h&gt;</pre></li><li class=\"li1\"><pre class=\"de1\">#include &lt;Adafruit_GFX&gt;</pre></li><li class=\"li1\"><pre class=\"de1\">#include &lt;Adafruit_PCD8544.h&gt;</pre></li><li class=\"li1\"><pre class=\"de1\">#include \"images.h\"</pre></li><li class=\"li1\"><pre class=\"de1\">Adafruit_PCD8544 display = Adafruit_PCD8544(13, 11, 8, 7, 9);</pre></li><li class=\"li1\"><pre class=\"de1\">void setup() {</pre></li><li class=\"li1\"><pre class=\"de1\">    display.begin();</pre></li><li class=\"li1\"><pre class=\"de1\">    display.setContrast(50);</pre></li><li class=\"li1\"><pre class=\"de1\">    display.clearDisplay();</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li><li class=\"li1\"><pre class=\"de1\">void loop() {</pre></li><li class=\"li1\"><pre class=\"de1\">    display.clearDisplay();</pre></li><li class=\"li1\"><pre class=\"de1\">    display.drawBitmap(0, 0, Face, 84, 48, 1);</pre></li><li class=\"li1\"><pre class=\"de1\">    display.display();</pre></li><li class=\"li1\"><pre class=\"de1\">    delay(300);</pre></li><li class=\"li1\"><pre class=\"de1\">    display.clearDisplay();</pre></li><li class=\"li1\"><pre class=\"de1\">}</pre></li></ol></div></div></div></div></div></div>",
        "Options": [
            "a) Wrong header file name",
            "b) Wrong display coordinate",
            "c) Wrong target datatype",
            "d) Incorrect parenthesis"
        ],
        "Answer": "Answer: a\nExplanation:The code misspelled the Adafruit_GFX library by not adding the C header file name extension “.h” at the end of the name. The Adafruit_GFX library is very important as it pairs the Arduino and allows it to talk to TFT displays connected to it.\n"
    },
    {
        "id": 425,
        "Question": "What is the use of the Adafruit FONA 3G+GPS Breakout?",
        "Options": [
            "a) To measure luminosity of something",
            "b) To provide 3G Connectivity",
            "c) To measure temperature",
            "d) To measure Wi-Fi strength"
        ],
        "Answer": "Answer: b\nExplanation: The  Adafruit FONA 3G+GPS Breakout is a module that provides 3G network connectivity for all kinds of embedded systems. It also has provisions for GPS tracking for providing on board geolocation capabilities.\n"
    },
    {
        "id": 426,
        "Question": "Which module enables GPS capabilities to the Adafruit FONA 3G+GPS Breakout?",
        "Options": [
            "a) Qualcomm 8015",
            "b) Qualcomm 20111",
            "c) Qualcomm 234",
            "d) Qualcomm 8013"
        ],
        "Answer": "Answer: a\nExplanation: The  Adafruit FONA 3G+GPS Breakout’s GPS capabilities is powered by the Qualcomm 8015 GPS Module. It enables geolocation services from the same device for all kinds of embedded and IOT applications. It can be controlled using the serial port.\n"
    },
    {
        "id": 427,
        "Question": "What kind of commands does the Adafruit FONA 3G+GPS Breakout accept?",
        "Options": [
            "a) Analog Commands",
            "b) BT Commands",
            "c) AT Commands",
            "d) TDM Commands"
        ],
        "Answer": "Answer: c\nExplanation: The Adafruit FONA 3G+GPS Breakout accepts AT commands which can be provided from any computer that is connected to it. AT Commands are an abbreviation for Attention Commands which are generally used for manipulating different types of modems.\n"
    },
    {
        "id": 428,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the Adafruit FONA 3G+GPS Breakout?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The Adafruit FONA 3G+GPS Breakout  are mostly built to work on a voltage of approximately 5V. Any voltage lower than that and the board will not be able to power on, but however any voltage significantly above that and the board may suffer permanent damage.\n"
    },
    {
        "id": 429,
        "Question": "Which port on any Arduino board should be connected to the Key Port on the Adafruit FONA 3G+GPS Breakout?",
        "Options": [
            "a) Any Digital Pin",
            "b) Vcc",
            "c) Gnd",
            "d) Any Analog Pin"
        ],
        "Answer": "Answer: c\nExplanation: The  Adafruit FONA 3G+GPS Breakout’s Key pin should be always connected to the Gnd Pin on any Arduino Board. This pin provides the function of the power on/off indicator. When you would like to shutdown the board, connect the pin to the Gnd of the Arduino Board for about 3 to 5 seconds. However for prolonged use usage of the  Adafruit FONA 3G+GPS Breakout one needs to permanently connect this pin to the Gnd of the Arduino.\n"
    },
    {
        "id": 430,
        "Question": "What is the full form of the RI pin on the Adafruit FONA 3G+GPS Breakout?",
        "Options": [
            "a) Ring Indicator",
            "b) Right Indicator",
            "c) Right Impersonation",
            "d) Rig Indicator"
        ],
        "Answer": "Answer: a\nExplanation: The Adafruit FONA 3G+GPS Breakout has an RI pin which acts as a interrupt out pin for it. When a call is received on the module this pin becomes LOW, and is HIGH by default. Furthermore, it can also be used as an indicator for SMS.\n"
    },
    {
        "id": 431,
        "Question": "How many LED indicators are present on the Adafruit FONA 3G+GPS Breakout?",
        "Options": [
            "a) 2",
            "b) 1",
            "c) 10",
            "d) 4"
        ],
        "Answer": "Answer: d\nExplanation: There are 4 LED indicators present on the  Adafruit FONA 3G+GPS Breakout. They include; NET for indicating the connection status and AT command acceptance, PWR for indicating when the module is booted, Charging which is usually orange and indicates the status of charge for the on board LiPo Battery, and the Charged LED which indicates when the battery is fully charged.\n"
    },
    {
        "id": 432,
        "Question": "What signal should be sent to the RESET pin of the Adafruit FONA 3G+GPS Breakout in order to perform a Hard Reset of the module?",
        "Options": [
            "a) 100ms LOW Signal",
            "b) Continuous HIGH Signal",
            "c) 100ms HIGH Signal",
            "d) Continuous LOW Signal"
        ],
        "Answer": "Answer: a\nExplanation: The RESET Pin on the  Adafruit FONA 3G+GPS Breakout should only be used when some software issue has been created due to some configuration error. It completely hard resets the board erasing every manual configuration.\n"
    },
    {
        "id": 433,
        "Question": "What is the use of the RTSin pin on the  Adafruit FONA 3G+GPS Breakout?",
        "Options": [
            "a) Right Turn Pin",
            "b) Hardware Control Pin",
            "c) Software Control Pin",
            "d) Residue Transmitter Pin"
        ],
        "Answer": "Answer: c\nExplanation: The SPK + and – pins on the  Adafruit FONA 3G+GPS Breakout are used to connect to any 8 Ohm speakers, the two pins are differential so they do not need to be connected to any DC blocking capacitors, however they should not be used to connect to any stereo powered speakers.\n"
    },
    {
        "id": 434,
        "Question": "What is the use of the LM35 Temperature Sensor Module?",
        "Options": [
            "a) Object Identification",
            "b) To provide 3G Connectivity",
            "c) To measure temperature",
            "d) To measure Wi-Fi strength"
        ],
        "Answer": "Answer: c\nExplanation: The LM35 Temperature sensor module is used for measuring the temperature in the immediate surroundings of the sensor. The output of the sensor is an analog voltage which is proportional to the Celsius temperature scale.\n"
    },
    {
        "id": 435,
        "Question": "How many terminals does the LM35 Temperature Sensor Module have?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 2",
            "d) 4"
        ],
        "Answer": "Answer: b\nExplanation: The LM35 Temperature Sensor Module has 3 terminals which correspond to the GND or ground, the VCC which acts as voltage input, and OUT which puts out the output voltage of the sensor corresponding to the temperature.\n"
    },
    {
        "id": 436,
        "Question": "What is the sensitivity of the LM35 Temperature Sensor Module?",
        "Options": [
            "a) 10mV/°C",
            "b) 1mV/°C",
            "c) 23mV/°C",
            "d) 12mV/°C"
        ],
        "Answer": "Answer: a\nExplanation: The sensitivity per unit centigrade of the LM35 Temperature Sensor Module is the smallest degree change in temperature that corresponds to a change in the voltage reading on the sensor module.\n"
    },
    {
        "id": 437,
        "Question": "What will happen if we supply a voltage of 250V to the Vcc of the LM35 Temperature Sensor Module?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The LM35 Temperature Sensor Modules are mostly built to work on a voltage of approximately 4V to 30V. Any voltage lower than that and the board will not be able to power on, but however any voltage significantly above that and the board may suffer permanent damage.\n"
    },
    {
        "id": 438,
        "Question": "What is the maximum temperature value that the LM35 Temperature Sensor Module can read?",
        "Options": [
            "a) 100°C",
            "b) 140°C",
            "c) 150°C",
            "d) 130°C"
        ],
        "Answer": "Answer: c\nExplanation: The maximum temperature that the LM35 Temperature Sensor Module can read is 150°C, above which the module cannot generate sufficient voltage in order to denote a temperature value accurately.\n"
    },
    {
        "id": 439,
        "Question": "What is the minimum temperature that the LM35 Temperature Sensor Module can read?",
        "Options": [
            "a) -11°C",
            "b) -55°C",
            "c) -10°C",
            "d) 0°C"
        ],
        "Answer": "Answer: b\nExplanation: The minimum temperature that the LM35 Temperature Sensor Module can read is -55°C, below which the module cannot generate sufficiently accurate order of voltage fluctuations to denote a temperature value.\n"
    },
    {
        "id": 440,
        "Question": "If the temperature would be 25°C then what would be the corresponding output on the LM35 Temperature Sensor?",
        "Options": [
            "a) 250mV",
            "b) 200mV",
            "c) 25V",
            "d) 250V"
        ],
        "Answer": "Answer: a\nExplanation: The temperature sensitivity of the LM35 Temperature Sensor Module is 10mV/°C which means that the value of the voltage output will increase linearly with the increase in the surrounding temperature, or in other words it is linearly proportional. Hence if the temperature outside is 25°C then the output would be (10×25)mV or 250mV.\n"
    },
    {
        "id": 441,
        "Question": "What is the formula for obtaining the temperature value in degrees centigrade from the LM35 Temperature Sensor while using an ADC?",
        "Options": [
            "a) °C=ADC/10mV",
            "b) °C=ADC/100mV",
            "c) °C=ADC/1mV",
            "d) °C=ADC/120mV"
        ],
        "Answer": "Answer: a\nExplanation: The correct formula for converting the voltage reading taken from the ADC into the correct degrees centigrade value of the temperature surrounding the sensor is °C=ADC/10mV. This is because 10mV is the scale factor of the LM35 Temperature Sensor Module.\n"
    },
    {
        "id": 442,
        "Question": "What is the approximate self heating temperature of the LM35 Temperature Sensor Module?",
        "Options": [
            "a) 0.08°C",
            "b) 0.91°C",
            "c) 0.11°C",
            "d) 1.23°C"
        ],
        "Answer": "Answer: a\nExplanation: The correct value of self heating under usual conditions for the LM35 Temperature Sensor Module is approximately 0.08°C. Self heating is the amount of heat that a particular electronic component generates while operating in a circuit due to internal resistances and impedances to the flow of electrons through it.\n"
    },
    {
        "id": 443,
        "Question": "What is the use of the RFID Module?",
        "Options": [
            "a) Object Identification",
            "b) To provide 3G Connectivity",
            "c) To measure temperature",
            "d) To measure Wi-Fi strength"
        ],
        "Answer": "Answer: a\nExplanation: The RFID Module is primarily used for object identification and tracking. It’s abbreviation stands for Radio Frequency Identification Module. It’s working is mostly wireless and uses electromagnetic fields.\n"
    },
    {
        "id": 444,
        "Question": "What is the role of the MISO pin in the RFID Module?",
        "Options": [
            "a) Master In Slave Out",
            "b) Manage Internal Slave Output",
            "c) Master Internal Search Optimization",
            "d) Manage Input Slave Op"
        ],
        "Answer": "Answer: a\nExplanation: The RFID Module’s MISO pin acts as Master In Slave Out while the SPI Interface is activated, and as a serial clock when I2C Interface is enabled. However, when UART Mode is activated, it assumes the role of the Serial Data Output Pin.\n"
    },
    {
        "id": 445,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the RFID Module?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The RFID Module has an SDA/SS/Rx Pin which, when the SPI Interface is enabled acts as a signal pin, when the I2C Interface is enabled acts as a Serial Data Pin, and in case of UART Mode Activation acts as a Serial Data Input pin.\n"
    },
    {
        "id": 446,
        "Question": "Which frequency does the RFID Module operate in?",
        "Options": [
            "a) 12.98 MHz",
            "b) 14.67 MHz",
            "c) 19.56 MHz",
            "d) 13.56 MHz"
        ],
        "Answer": "Answer: a\nExplanation: The RFID Modules are mostly built to work on a voltage of approximately 3.3V. Any voltage lower than that and the board will not be able to power on, but however any voltage significantly above that and the board may suffer permanent damage.\n"
    },
    {
        "id": 447,
        "Question": "What is the maximum data rate of the RFID Module?",
        "Options": [
            "a) 11 Mbps",
            "b) 1 Kbps",
            "c) 10 Mbps",
            "d) 11 Gbps"
        ],
        "Answer": "Answer: d\nExplanation: The RFID Module operates in the 13.56 MHz frequency since it is the universal unregulated frequency for all scientific and medical research purposes. It was set as the standard international frequency to be followed by all, since it does not interfere significantly with the environment.\n"
    },
    {
        "id": 448,
        "Question": "What is the maximum read range of the RFID Module?",
        "Options": [
            "a) 2 cm",
            "b) 1 cm",
            "c) 10 cm",
            "d) 5 cm"
        ],
        "Answer": "Answer: c\nExplanation: The maximum data rate of any given device is the ability of that given device to transfer as many bits of information from one location to another in unit time. Here, the maximum data rate of the RFID Module is 10 Mbps, which means that the module can transfer a maximum of 10 Megabytes of data in 1 second.\n"
    },
    {
        "id": 449,
        "Question": "What is the minimum working current internally in the RFID Module?",
        "Options": [
            "a) 12 mA",
            "b) 13 mA",
            "c) 10 mA",
            "d) 1 mA"
        ],
        "Answer": "Answer: d\nExplanation: The maximum read range of an RFID Module is the maximum distance in space that the receiver module can read the signal sent by the transmitter module. In order for proper working of the module during operation, it is advised that both the modules are kept within the read range for accurate performance.\n"
    },
    {
        "id": 450,
        "Question": "Till what voltage are the logic pins on the RFID Module resistant to?",
        "Options": [
            "a) 5V",
            "b) 3.3V",
            "c) 2V",
            "d) 12V"
        ],
        "Answer": "Answer: a\nExplanation: There is an interrupt pin on the RFID Module which keeps the module alert to incoming connection requests from any RFID transmitter that approaches its maximum read range so that it can throw a subsequent software interrupt in order for the new transmitter to function in sync with the receiver.\n"
    },
    {
        "id": 451,
        "Question": "What is the use of the MQ2 Gas Sensor?",
        "Options": [
            "a) Object Identification",
            "b) To provide 3G Connectivity",
            "c) To measure presence of gas",
            "d) To measure Wi-Fi strength"
        ],
        "Answer": "Answer: c\nExplanation: The MQ2 Gas sensor is used to measure the degree of presence of particular types of gases in the surrounding air. It can detect Methane, Butane, LPG and smoke quantities present in the air surrounding the sensor.\n"
    },
    {
        "id": 452,
        "Question": "How many terminals does the MQ2 Gas Sensor have?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 2",
            "d) 4"
        ],
        "Answer": "Answer: d\nExplanation: The MQ2 Gas Sensor has 4 terminals. These include the Vcc for accepting positive voltage to power the sensor, GND for ground connections to complete the circuit and activate the sensor, Dout which provides a digital output terminal and an Aout which provides the analog output terminal.\n"
    },
    {
        "id": 453,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the MQ2 Gas Sensor?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: b\nExplanation: The sensitivity of any sensor is its ability to detect the smallest degree of change in the measuring medium that generates an accurate output in the sensor’s terminals. The sensitivity of the MQ2 Gas Sensor is not fixed in itself and can be varied using a potentiometer.\n"
    },
    {
        "id": 454,
        "Question": "What is the maximum output voltage that the MQ2 Gas Sensor can put out on its analog output pin?",
        "Options": [
            "a) 1V",
            "b) 140V",
            "c) 5V",
            "d) 10V"
        ],
        "Answer": "Answer: a\nExplanation: The MQ2 Gas Sensors are mostly built to work on a voltage of approximately 5V. Any voltage lower than that and the board will not be able to power on, but however any voltage significantly above that and the board may suffer permanent damage.\n"
    },
    {
        "id": 455,
        "Question": "If the PPM concentration of a gas that is being detected by the MQ2 Gas Sensor increases what will happen to its Digital Output pin?",
        "Options": [
            "a) Voltage Increases",
            "b) Voltage Decreases",
            "c) Voltage becomes 0",
            "d) Voltage doesn’t change"
        ],
        "Answer": "Answer: c\nExplanation: The maximum output voltage of the MQ2 Gas Sensor is 5V. Any PPM concentrations within that limit can be detected with accuracy by the sensor. However, one can detect higher or lower PPM concentrations to a certain degree by adjusting the potentiometer.\n"
    },
    {
        "id": 456,
        "Question": "If the PPM concentration of a gas that is being detected by the MQ2 Gas Sensor increases what will happen to its Analog Output pin?",
        "Options": [
            "a) Voltage Increases",
            "b) Voltage Decreases",
            "c) Voltage becomes 0",
            "d) Voltage doesn’t change"
        ],
        "Answer": "Answer: b\nExplanation: The MQ2 Gas Sensor is not designed to tell which gases are present in the air surrounding the module. It can only tell what is the concentration or PPM value of a gas. The nature or name of the gas has to be known beforehand while using this sensor.\n"
    },
    {
        "id": 457,
        "Question": "What is the full form of the abbreviation called PPM?",
        "Options": [
            "a) Parts Per Million",
            "b) Parts Per Milligram",
            "c) Parts Per Megagram",
            "d) Parts Per Millilitre"
        ],
        "Answer": "Answer: d\nExplanation: The MQ2 Gas Sensor has two output pins, one is digital and one is analog. The digital pin can only vary between two voltage levels which corresponds to 2 Logic Levels, 1 and 0 or 5V and 0V respectively. So if a gas is present then the digital output becomes 5V but cannot detect any kind of change in concentration of the gas.\n"
    },
    {
        "id": 458,
        "Question": "What is the name of the mesh surrounding the MQ2 Gas Sensor?",
        "Options": [
            "a) Anti-Heat Mesh",
            "b) Anti-Explosion Mesh",
            "c) Anti-Air Mesh",
            "d) Filtration Mesh"
        ],
        "Answer": "Answer: a\nExplanation: The MQ2 Gas Sensor has two output pins, one is digital and one is analog. The analog pin’s voltage is set so that it is directly proportional to the PPM value in the air subject to variation in calibration from the potentiometer, so as the PPM level rises so does the voltage in the analog output pin until it reaches 5V.\n"
    },
    {
        "id": 459,
        "Question": "What is the use of the rotary encoder?",
        "Options": [
            "a) To measure RPM or speed",
            "b) To provide 3G Connectivity",
            "c) To measure presence of gas",
            "d) To measure Wi-Fi strength"
        ],
        "Answer": "Answer: a\nExplanation: The rotary encoder is used to measure the RPM or speed or any other such motion and angular velocity related parameters of any robotic system or any other system in general. It provides a series of ticks which provide us with the necessary information to decode that into our required values.\n"
    },
    {
        "id": 460,
        "Question": "How many terminals does the rotary encoder have?",
        "Options": [
            "a) 1",
            "b) 3",
            "c) 5",
            "d) 4"
        ],
        "Answer": "Answer: c\nExplanation: The rotary encoder has 5 terminals which include the Vcc for power supply, the CLK for clock, DATA which provides us the output wave, and SWC which switches voltage to 0 and GND which is required for completing the circuit through the sensor and grounding it.\n"
    },
    {
        "id": 461,
        "Question": "What is the purpose of the CLK pin in the rotary encoder?",
        "Options": [
            "a) To provide pulse reference",
            "b) To power the module",
            "c) To shut down the module",
            "d) To provide analog reference voltage"
        ],
        "Answer": "Answer: a\nExplanation: The rotary encoder has a CLK pin and a DATA pin. The DATA pin gives out pulses which vary in phase depending upon the direction of rotation of the rotary encoder. However we cannot determine these variations until we compare the wave pattern with another steady non-variable pulse train. The CLK pin provides exactly that.\n"
    },
    {
        "id": 462,
        "Question": "What will happen if we supply a voltage of 25V to the Vcc of the rotary encoder?",
        "Options": [
            "a) Damage is caused",
            "b) Module will shut down",
            "c) Module will not respond for the time the voltage is applied",
            "d) Module will function normally"
        ],
        "Answer": "Answer: a\nExplanation: The rotary encoders are mostly built to work on a voltage of approximately 3.3V to 5V. Any voltage lower than that and the board will not be able to power on, but however any voltage significantly above that and the board may suffer permanent damage.\n"
    },
    {
        "id": 463,
        "Question": "What is the maximum output voltage that the rotary encoder can put out on its DATA output pin?",
        "Options": [
            "a) 1V",
            "b) 140V",
            "c) 5V",
            "d) 10V"
        ],
        "Answer": "Answer: c\nExplanation: The maximum output voltage of the DATA pin on the rotary encoder is 5V while the lowest is 0V. There is no voltage level in between them as the DATA out pin is a digital pin and can represent only 2 logic levels.\n"
    },
    {
        "id": 464,
        "Question": "What is the purpose of the DATA pin in the rotary encoder?",
        "Options": [
            "a) To provide direction of motion",
            "b) To power the module",
            "c) To shut down the module",
            "d) To provide analog reference voltage"
        ],
        "Answer": "Answer: a\nExplanation: The rotary encoder has a CLK pin and a DATA pin. The DATA pin gives out pulses which vary in phase depending upon the direction of rotation of the rotary encoder which is determined by comparing it with the non-variable pulse train of the CLK pin.\n"
    },
    {
        "id": 465,
        "Question": "Which direction is the rotary encoder moving?",
        "Options": [
            "a) Swinging both clockwise and anticlockwise",
            "b) Anticlockwise",
            "c) Clockwise",
            "d) Still"
        ],
        "Answer": "Answer: b\nExplanation: If the DATA pin is in sync with the CLK pin, then we can say that it is moving in the clockwise direction. However, here in this case, the DATA pin is not in sync with the CLK pin and has a 90 degree phase shift with respect to the train of the CLK pin so we can say that it is moving in the anticlockwise direction.\n"
    },
    {
        "id": 466,
        "Question": "Which direction is the rotary encoder moving?",
        "Options": [
            "a) Swinging both clockwise and anticlockwise",
            "b) Anticlockwise",
            "c) Clockwise",
            "d) Still"
        ],
        "Answer": "Answer: c\nExplanation: If the DATA pin is in sync with the CLK pin, then we can say that it is moving in the clockwise direction. Here, in this case, the DATA pin is in sync with the CLK pin and has no phase shift with respect to the train of the CLK pin so we can say that it is moving in the clockwise direction.\n"
    },
    {
        "id": 467,
        "Question": "Which direction is the rotary encoder moving?",
        "Options": [
            "a) Swinging both clockwise and anticlockwise",
            "b) Anticlockwise",
            "c) Clockwise",
            "d) Still"
        ],
        "Answer": "Answer: d\nExplanation: If the DATA pin is in sync with the CLK pin, then we can say that it is moving in the clockwise direction. However, here in this case, the DATA pin is not changing at all with respect to the CLK pin and is stalled at 1. This will happen if there is no rotation on the shaft of the rotary encoder. Hence we can say that the encoder is sitting idle or still.\n"
    },
    {
        "id": 468,
        "Question": "Which direction is the rotary encoder moving?",
        "Options": [
            "a) Swinging both clockwise and anticlockwise",
            "b) Anticlockwise",
            "c) Clockwise",
            "d) Still"
        ]
    }
]